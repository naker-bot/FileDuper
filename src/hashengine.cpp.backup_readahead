#include "hashengine.h"
#include <QDebug>
#include <QDir>
#include <QDateTime>
#include <QProcess>
#include <QUrl>
#include <QFileInfo>
#include <QStandardPaths>
#include <QSettings>
#include <QByteArray>
#include <QRegularExpression>
#include <QApplication>
#include <QThread>
#include <QMetaEnum>
#include <curl/curl.h>
#include <openssl/md5.h>
#include <limits>
#include <iostream>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/resource.h>

HashEngine::HashEngine(QObject *parent)
    : QObject(parent), currentAlgorithm(MD5), currentHashMode(FULL_HASH), currentUnit(CPU_ALL_CORES),
      gpuAvailable(false), intelGpuAvailable(false), npuAvailable(false),
      hashCount(0), hashRate(0), processedFiles(0), lastRateUpdate(0),
      ftpCurlHandle(nullptr), currentFtpHost("")
#ifdef ENABLE_OPENCL
      ,
      context(nullptr), queue(nullptr), program(nullptr), kernel(nullptr), md5Kernel(nullptr), device(nullptr), openclInitialized(false)
#endif
{
    qDebug() << "[HashEngine] üîß Multi-Algorithm Hardware-Accelerated Engine wird initialisiert...";
    emit statusUpdate("üîß Hash-Engine", "Multi-Algorithm Hardware-Accelerated Engine wird initialisiert...");
    
    // üöÄ FTP-DOWNLOAD-CACHE initialisieren
    cacheDirectory = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/fileduper_cache";
    QDir().mkpath(cacheDirectory);
    qDebug() << "[HashEngine] üìÅ Cache-Verzeichnis erstellt:" << cacheDirectory;
    emit statusUpdate("üìÅ Cache-System", "Cache-Verzeichnis erstellt: " + cacheDirectory);
    
    // ‚ö° CURL Connection Pool initialisieren
    ftpCurlHandle = curl_easy_init();
    if (ftpCurlHandle) {
        qDebug() << "[HashEngine] ‚ö° CURL Connection Pool initialisiert (FTP-Reuse aktiviert)";
    }
    
    // üßπ Cache-Bereinigung beim Start
    cleanupCache();

    // Timer f√ºr asynchrone Hash-Verarbeitung (Parallel Processing)
    processTimer = new QTimer(this);
    processTimer->setSingleShot(false);
    processTimer->setInterval(1); // 1ms f√ºr ultra-speed processing
    connect(processTimer, &QTimer::timeout, this, &HashEngine::processNextHash);

    // Timer f√ºr Hash-Rate √úberwachung
    rateTimer = new QTimer(this);
    rateTimer->setInterval(500); // 2x pro Sekunde f√ºr genauere Messungen
    connect(rateTimer, &QTimer::timeout, this, &HashEngine::updateHashRate);
    rateTimer->start();

    // Intel-optimierte Hardware-Erkennung
    detectHardwareCapabilities();

    // ‚ùå Kein AUTO_SELECT mehr - User muss explizit Hardware w√§hlen
    // ‚úÖ AUTO-SELECT: Beste verf√ºgbare Hardware automatisch w√§hlen
    setProcessingUnit(AUTO_SELECT);
    
    std::cout << "‚ö° HashEngine initialisiert - Hardware automatisch gew√§hlt" << std::endl;
}

HashEngine::~HashEngine()
{
    // ‚ö° Cleanup CURL Connection Pool
    if (ftpCurlHandle) {
        curl_easy_cleanup(static_cast<CURL*>(ftpCurlHandle));
        ftpCurlHandle = nullptr;
        qDebug() << "[HashEngine] ‚ö° CURL Connection Pool geschlossen";
    }
    
    cleanup();
}

void HashEngine::detectHardwareCapabilities()
{
    qDebug() << "[HashEngine] üîç Intel-optimierte Hardware-Erkennung gestartet...";
    emit statusUpdate("üîç Hardware-Scan", "Intel-optimierte Hardware-Erkennung gestartet...");

    // Intel GPU detection (Arc, Xe, UHD Graphics)
    QProcess intelGpuCheck;
    intelGpuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'intel.*graphics\\|intel.*arc\\|intel.*xe'");
    // ‚úÖ ANTI-HANG: 2-Sekunden Timeout f√ºr Intel GPU Check
    if (!intelGpuCheck.waitForFinished(2000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Intel GPU lspci-Timeout - √ºberspringe";
        intelGpuCheck.kill();
        intelGpuAvailable = false;
    } else {
        intelGpuAvailable = (intelGpuCheck.exitCode() == 0 && !intelGpuCheck.readAllStandardOutput().isEmpty());
    }

    // General GPU detection via lspci parsing
    QProcess gpuCheck;
    gpuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'vga\\|3d\\|display'");
    // ‚úÖ ANTI-HANG: 2-Sekunden Timeout f√ºr Generic GPU Check
    if (!gpuCheck.waitForFinished(2000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Generic GPU lspci-Timeout - √ºberspringe";
        gpuCheck.kill();
        gpuAvailable = false;
    } else {
        gpuAvailable = (gpuCheck.exitCode() == 0 && !gpuCheck.readAllStandardOutput().isEmpty());
    }

    // Intel NPU detection for AI acceleration
    QProcess npuCheck;
    npuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'Processing accelerators.*Intel.*Arrow Lake\\|neural\\|npu\\|intel.*ai\\|intel.*vpu'");
    // ‚úÖ ANTI-HANG: 2-Sekunden Timeout f√ºr NPU Check
    if (!npuCheck.waitForFinished(2000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è NPU lspci-Timeout - √ºberspringe";
        npuCheck.kill();
        npuAvailable = false;
    } else {
        QString npuOutput = npuCheck.readAllStandardOutput();
        npuAvailable = (npuCheck.exitCode() == 0 && !npuOutput.isEmpty());
    }
    
    // Intel Arrow Lake NPU support - verbesserte Erkennung mit TIMEOUT
    if (!npuAvailable) {
        qDebug() << "[HashEngine] üß† NPU nicht erkannt - pr√ºfe Intel Arrow Lake NPU erweitert...";
        QProcess arrowLakeCheck;
        arrowLakeCheck.start("lspci");
        
        // ‚úÖ ANTI-HANG: 3-Sekunden Timeout f√ºr lspci
        if (!arrowLakeCheck.waitForFinished(3000)) {
            qWarning() << "[HashEngine] ‚ö†Ô∏è lspci-Timeout nach 3s - NPU-Erkennung √ºbersprungen";
            arrowLakeCheck.kill();
        } else {
            QString allPciOutput = arrowLakeCheck.readAllStandardOutput();
            
            // Suche nach Arrow Lake NPU-spezifischen Strings
            if (allPciOutput.contains("Arrow Lake NPU", Qt::CaseInsensitive) ||
                allPciOutput.contains("Processing accelerators", Qt::CaseInsensitive) ||
                allPciOutput.contains("Intel Corporation", Qt::CaseInsensitive)) {
                npuAvailable = true;
                qDebug() << "[HashEngine] üöÄ Intel Arrow Lake NPU √ºber lspci-Vollscan erkannt!";
                qDebug() << "[HashEngine] üìã NPU gefunden in:" << allPciOutput.split('\n').filter("Arrow Lake", Qt::CaseInsensitive);
            }
        }
    }

    std::cout << "üîç Hardware-Capabilities erkannt:" << std::endl;
    std::cout << "   üéØ Intel GPU (Arc/Xe/UHD): " << (intelGpuAvailable ? "‚úÖ Verf√ºgbar" : "‚ùå Nicht gefunden") << std::endl;
    std::cout << "   üñ•Ô∏è  Generische GPU: " << (gpuAvailable ? "‚úÖ Verf√ºgbar" : "‚ùå Nicht gefunden") << std::endl;
    std::cout << "   ü§ñ Intel NPU/VPU: " << (npuAvailable ? "‚úÖ Verf√ºgbar" : "‚ùå Nicht gefunden") << std::endl;

#ifndef ENABLE_OPENCL
    std::cout << "‚ö†Ô∏è  OpenCL-Support nicht kompiliert - nur CPU-Hashing verf√ºgbar" << std::endl;
#else
    if (intelGpuAvailable || gpuAvailable)
    {
        qDebug() << "[HashEngine] üîß Starte OpenCL-Initialisierung...";
        emit statusUpdate("üîß GPU-Setup", "OpenCL-Initialisierung f√ºr GPU-Beschleunigung...");
        try {
            initializeOpenCL();
            emit statusUpdate("‚úÖ GPU-Setup", "OpenCL erfolgreich initialisiert - GPU-Beschleunigung aktiv");
        } catch (...) {
            qWarning() << "[HashEngine] ‚ö†Ô∏è OpenCL-Initialisierung fehlgeschlagen - CPU Fallback";
            emit statusUpdate("‚ö†Ô∏è GPU-Setup", "OpenCL-Initialisierung fehlgeschlagen - CPU-Fallback");
            openclInitialized = false;
        }
    } else {
        qDebug() << "[HashEngine] ‚ö†Ô∏è Keine GPU erkannt - √ºberspringe OpenCL-Initialisierung";
        openclInitialized = false;
    }
#endif

    // üß† NPU-FIRST: Wenn NPU verf√ºgbar ist, als prim√§re Einheit setzen
    if (npuAvailable) {
        currentUnit = NPU_LEVEL_ZERO;
        std::cout << "üöÄ NPU als prim√§re Einheit aktiviert: Intel Arrow Lake NPU" << std::endl;
        emit statusUpdate("Hardware-Setup", "NPU aktiviert (Intel Arrow Lake)");
    } else {
        std::cout << "üöÄ Optimal: Intel NPU (Level Zero) - aber nicht verf√ºgbar" << std::endl;
        
        // Fallback-Hierarchie nur wenn NPU nicht verf√ºgbar
        if (intelGpuAvailable) {
            currentUnit = INTEL_GPU_OPENCL;
            std::cout << "üéØ Fallback: Intel GPU aktiviert" << std::endl;
            emit statusUpdate("Hardware-Setup", "Intel GPU aktiviert (Fallback)");
        } else if (gpuAvailable) {
            currentUnit = GPU_OPENCL;
            std::cout << "üñ•Ô∏è Fallback: Generic GPU aktiviert" << std::endl;
            emit statusUpdate("Hardware-Setup", "Generic GPU aktiviert (Fallback)");
        } else {
            currentUnit = CPU_ALL_CORES;
            std::cout << "‚ö° Fallback: CPU (Alle Kerne) aktiviert" << std::endl;
            emit statusUpdate("Hardware-Setup", "CPU aktiviert (alle Kerne)");
        }
    }

    // Ausgabe der NPU-Informationen falls verf√ºgbar
    if (intelGpuAvailable)
    {
        configureIntelGpu();
    }

    if (gpuAvailable)
    {
        // GPU-spezifische Initialisierungen hier
        qDebug() << "[HashEngine] GPU-Hardware verf√ºgbar";
    }
    
    // üóÇÔ∏è Signal-Verbindung f√ºr Hash-Speicherung
    connect(this, &HashEngine::hashCalculated, this, &HashEngine::storeCalculatedHash);
    qDebug() << "[HashEngine] ‚úÖ Hash-Storage-System initialisiert";
}

// üöÄ GPU-BESCHLEUNIGTE HASH-BERECHNUNG
QString HashEngine::calculateGpuAcceleratedHash(const QString &filePath, Algorithm algo)
{
    // üîß TOLERANTER FALLBACK: CPU-Hash wenn GPU nicht verf√ºgbar
    if (!gpuAvailable && !intelGpuAvailable) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è GPU nicht verf√ºgbar ‚Üí CPU-Hash f√ºr:" << QFileInfo(filePath).fileName();
    // Wichtig: Direkt den CPU-Hash (ohne erneute GPU-Pfade) aufrufen, um Rekursion zu vermeiden
    return calculateFileHash(filePath, algo);
    }
    
    QFileInfo fileInfo(filePath);
    qint64 fileSize = fileInfo.size();
    
    // üîß CRITICAL FIX: GPU-Threshold von 1KB auf 5MB erh√∂hen
    if (fileSize < 5 * 1024 * 1024) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Kleine Datei ‚Üí CPU-Hash:" << QFileInfo(filePath).fileName() << "(" << fileSize << "bytes)";
        // Wichtig: Direkt den CPU-Hash (ohne erneute GPU-Pfade) aufrufen, um Rekursion zu vermeiden
        return calculateFileHash(filePath, algo);
    }
    
    qDebug() << "[HashEngine] ‚ö° GPU-Hash-Berechnung f√ºr" << fileSize << "Bytes";
    
    // Intel GPU priorisieren (nur wenn als aktuelle Einheit gew√§hlt)
    if (intelGpuAvailable && currentUnit == INTEL_GPU_OPENCL) {
        QString result = calculateIntelGpuHash(filePath, algo);
        if (result.isEmpty()) {
            emit criticalError("Intel GPU Hash fehlgeschlagen", 
                             QString("Intel GPU Hash-Berechnung f√ºr '%1' fehlgeschlagen. System stoppt.").arg(filePath));
            return QString("INTEL_GPU_HASH_FAILED");
        }
        return result;
    }
    
    // Generische GPU nur wenn als aktuelle Einheit gew√§hlt
    if (gpuAvailable && currentUnit == GPU_OPENCL) {
        QString result = calculateGenericGpuHash(filePath, algo);
        if (result.isEmpty()) {
            emit criticalError("GPU Hash fehlgeschlagen", 
                             QString("GPU Hash-Berechnung f√ºr '%1' fehlgeschlagen. System stoppt.").arg(filePath));
            return QString("GPU_HASH_FAILED");
        }
        return result;
    }
    
    // ‚ùå Kein GPU verf√ºgbar
    // Keine GPU gew√§hlt ‚Üí CPU-Fallback statt Abbruch
    qDebug() << "[HashEngine] ‚ÑπÔ∏è Keine GPU als Einheit aktiv ‚Üí CPU-Fallback f√ºr:" << QFileInfo(filePath).fileName();
    return calculateFileHash(filePath, algo);
}

// Intel GPU optimierte Hash-Berechnung
QString HashEngine::calculateIntelGpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üéØ Intel GPU Hash-Berechnung f√ºr:" << filePath;
    
#ifdef ENABLE_OPENCL
    // OpenCL Intel GPU Implementation
    if (openclInitialized && currentUnit == INTEL_GPU_OPENCL) {
        return calculateOpenCLHash(filePath, algo);
    }
#endif
    
    // ‚ùå Kein CPU-Fallback mehr - strikte Intel GPU-Behandlung
    emit criticalError("OpenCL f√ºr Intel GPU nicht verf√ºgbar", 
                     QString("Intel GPU wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
    return QString("INTEL_GPU_OPENCL_NOT_AVAILABLE");
}

// Generische GPU Hash-Berechnung
QString HashEngine::calculateGenericGpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üñ•Ô∏è Generic GPU Hash-Berechnung f√ºr:" << filePath;
    
#ifdef ENABLE_OPENCL
    // OpenCL generische GPU Implementation
    if (openclInitialized && currentUnit == GPU_OPENCL) {
        return calculateOpenCLHash(filePath, algo);
    }
#endif
    
    // ‚ùå Kein CPU-Fallback mehr - strikte GPU-Behandlung
    emit criticalError("OpenCL f√ºr Generic GPU nicht verf√ºgbar", 
                     QString("Generic GPU wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
    return QString("GENERIC_GPU_OPENCL_NOT_AVAILABLE");
}

// Optimierte CPU Hash-Berechnung (GPU-Simulation)
QString HashEngine::calculateOptimizedCpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] ‚ö° Optimierte CPU-Hash-Simulation f√ºr GPU";
    
    // Multi-Thread CPU hash mit gr√∂√üeren Bl√∂cken (GPU-√§hnlich)
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return QString();
    }
    
    QCryptographicHash hasher(static_cast<QCryptographicHash::Algorithm>(algo));
    
    // Gr√∂√üere Bl√∂cke f√ºr "GPU-√§hnliche" Performance (64KB statt 8KB)
    const int blockSize = 8388608;  // 8MB ULTRA-SPEED FOR FTP  // 4MB MAXIMUM SPEED // 64KB Bl√∂cke f√ºr bessere Performance
    QByteArray buffer(blockSize, 0);
    
    qint64 totalRead = 0;
    qint64 fileSize = file.size();
    
    while (!file.atEnd()) {
        qint64 bytesRead = file.read(buffer.data(), blockSize);
        if (bytesRead > 0) {
            hasher.addData(QByteArrayView(buffer.data(), bytesRead));
            totalRead += bytesRead;
            
            // Progress simulation (nicht blockierend) - BULLETPROOF Division-by-Zero Protection
            if (totalRead % (1024 * 1024) == 0 && fileSize > 0) { // Nur alle 1MB ausgeben + FileSize Check
                double progress = (double)totalRead / fileSize * 100.0;
                // qDebug() << "[HashEngine] üìä GPU Progress:" << QString::number(progress, 'f', 1) << "%"; // STILLE AUSGABE
            }
        } else {
            break;
        }
    }
    
    QString result = hasher.result().toHex();
    qDebug() << "[HashEngine] ‚úÖ GPU-Simulation Hash erfolgreich:" << result.left(16) + "...";
    return result;
}

#ifdef ENABLE_OPENCL
// üî• ECHTE OpenCL GPU Hash-Berechnung
// Callback function for libcurl FTP download
static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    QByteArray *mem = static_cast<QByteArray*>(userp);
    mem->append(static_cast<const char*>(contents), realsize);
    return realsize;
}

QString HashEngine::calculateOpenCLHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üî• ECHTE OpenCL GPU Hash-Berechnung f√ºr:" << QFileInfo(filePath).fileName();
    emit statusUpdate("GPU-Hashing", QString("Berechnet Hash f√ºr %1").arg(QFileInfo(filePath).fileName()));
    
    if (!openclInitialized) {
        emit criticalError("OpenCL nicht initialisiert", 
                         QString("OpenCL GPU Hash wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
        return QString("OPENCL_NOT_INITIALIZED");
    }
    
    // ‚úÖ FTP-DATEI HANDLING: Download vor Hash-Berechnung
    QByteArray fileData;
    if (filePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üì° FTP-Download erforderlich f√ºr:" << filePath;
        emit statusUpdate("FTP-Download", QString("L√§dt %1").arg(QFileInfo(filePath).fileName()));
        
        // FTP-File via libcurl downloaden
        CURL *curl = curl_easy_init();
        if (!curl) {
            qDebug() << "[HashEngine] ‚ùå libcurl init fehlgeschlagen f√ºr FTP-Download";
            return QString("FTP_DOWNLOAD_FAILED");
        }
        
        // Download direkt in memory
        curl_easy_setopt(curl, CURLOPT_URL, filePath.toUtf8().constData());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &fileData);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L); // 30s timeout
        
        // ‚úÖ FTP-Credentials mit Benutzer-Abfrage (konsistent mit calculateFtpFileHash)
        QUrl url(filePath);
        QString host = url.host();
        int port = url.port(21);
        
        // Pr√ºfe gespeicherte Credentials
        if (!ftpUsername.isEmpty() && !ftpPassword.isEmpty()) {
            curl_easy_setopt(curl, CURLOPT_USERNAME, ftpUsername.toUtf8().constData());
            curl_easy_setopt(curl, CURLOPT_PASSWORD, ftpPassword.toUtf8().constData());
            qDebug() << "[HashEngine] üîê OpenCL: Verwende gespeicherte FTP-Credentials f√ºr:" << host;
        } else {
            qWarning() << "[HashEngine] ‚ö†Ô∏è OpenCL: Keine FTP-Credentials verf√ºgbar f√ºr:" << host;
            qDebug() << "[HashEngine] üîê OpenCL: Sende Signal f√ºr FTP-Credential-Abfrage...";
            
            // Signal an GUI senden, dass Credentials ben√∂tigt werden
            emit error(QString("FTP_CREDENTIALS_REQUIRED_FOR_HOST: %1").arg(host));
            
            curl_easy_cleanup(curl);
            return QString("FTP_CREDENTIALS_REQUIRED");
        }
        
        CURLcode res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
        
        if (res != CURLE_OK || fileData.isEmpty()) {
            qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << curl_easy_strerror(res);
            
            // üîÑ Bei Login-Fehlern emittiere Credential-Request Signal
            if (res == CURLE_LOGIN_DENIED || res == CURLE_FTP_ACCESS_DENIED) {
                qDebug() << "[HashEngine] üîÑ Login fehlgeschlagen - emittiere Credential-Request Signal...";
                QString host = QUrl(filePath).host();
                int port = QUrl(filePath).port(21);
                emit ftpCredentialsRequiredForHost(host, port, "FTP");
                return QString("FTP_LOGIN_DENIED");
            }
            
            return QString("FTP_DOWNLOAD_FAILED");
        }
        
        qDebug() << "[HashEngine] ‚úÖ FTP-File downloaded:" << fileData.size() << "bytes";
        
    } else {
        // Lokale Datei einlesen
        QFile file(filePath);
        if (!file.open(QIODevice::ReadOnly)) {
            qDebug() << "[HashEngine] ‚ùå Datei kann nicht ge√∂ffnet werden:" << filePath;
            return QString();
        }
        
        fileData = file.readAll();
        file.close();
    }
    
    if (fileData.isEmpty()) {
        return QString();
    }
    
    // Kernel basierend auf Algorithmus ausw√§hlen
    cl_kernel currentKernel = kernel; // Default SHA256
    if (algo == MD5) {
        // MD5 Kernel erstellen falls noch nicht vorhanden
        if (!md5Kernel) {
            cl_int err;
            md5Kernel = clCreateKernel(program, "md5_hash", &err);
            if (err != CL_SUCCESS) {
                emit criticalError("MD5 Kernel Creation fehlgeschlagen", 
                                 QString("MD5 OpenCL Kernel konnte nicht erstellt werden f√ºr '%1'. System stoppt.").arg(filePath));
                return QString("MD5_KERNEL_CREATION_FAILED");
            } else {
                currentKernel = md5Kernel;
            }
        } else {
            currentKernel = md5Kernel;
        }
    }
    
    // OpenCL Buffer erstellen
    cl_int err;
    size_t dataSize = fileData.size();
    
    // GPU Memory allokieren
    cl_mem dataBuffer = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                                      dataSize, fileData.data(), &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå GPU Buffer Creation fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Hash-Output Buffer (8 uint f√ºr SHA256, 4 uint f√ºr MD5)
    int hashWords = (algo == MD5) ? 4 : 8;
    size_t numWorkItems = qMin((size_t)256, (dataSize / 1024) + 1); // 256 GPU Cores max
    cl_mem hashBuffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, 
                                      sizeof(cl_uint) * hashWords * numWorkItems, nullptr, &err);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(dataBuffer);
        qDebug() << "[HashEngine] ‚ùå Hash Buffer Creation fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Kernel Parameter setzen
    cl_uint chunkSize = dataSize / numWorkItems;
    if (chunkSize == 0) chunkSize = dataSize;
    
    clSetKernelArg(currentKernel, 0, sizeof(cl_mem), &dataBuffer);
    clSetKernelArg(currentKernel, 1, sizeof(cl_mem), &hashBuffer);
    clSetKernelArg(currentKernel, 2, sizeof(cl_uint), &dataSize);
    clSetKernelArg(currentKernel, 3, sizeof(cl_uint), &chunkSize);
    
    // GPU Kernel ausf√ºhren
    size_t globalWorkSize = numWorkItems;
    size_t localWorkSize = qMin((size_t)64, numWorkItems); // Intel GPU optimal: 64
    
    err = clEnqueueNDRangeKernel(queue, currentKernel, 1, nullptr, &globalWorkSize, 
                                &localWorkSize, 0, nullptr, nullptr);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(dataBuffer);
        clReleaseMemObject(hashBuffer);
        qDebug() << "[HashEngine] ‚ùå GPU Kernel Execution fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Warten auf GPU-Completion
    clFinish(queue);
    
    // Hash-Resultate von GPU zur√ºcklesen
    QVector<cl_uint> hashResult(hashWords * numWorkItems);
    err = clEnqueueReadBuffer(queue, hashBuffer, CL_TRUE, 0, 
                             sizeof(cl_uint) * hashWords * numWorkItems, 
                             hashResult.data(), 0, nullptr, nullptr);
    
    clReleaseMemObject(dataBuffer);
    clReleaseMemObject(hashBuffer);
    
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå GPU Hash Read fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Hash-Kombination aller GPU-Chunks
    QCryptographicHash finalHasher((algo == MD5) ? QCryptographicHash::Md5 : QCryptographicHash::Sha256);
    for (int i = 0; i < hashWords; i++) {
        cl_uint combinedHash = 0;
        for (size_t j = 0; j < numWorkItems; j++) {
            combinedHash ^= hashResult[j * hashWords + i]; // XOR aller Chunk-Hashes
        }
        finalHasher.addData(reinterpret_cast<const char*>(&combinedHash), sizeof(combinedHash));
    }
    
    QString result = finalHasher.result().toHex();
    qDebug() << "[HashEngine] ‚úÖ ECHTE GPU Hash erfolgreich berechnet:" << result.left(16) + "...";
    qDebug() << "[HashEngine] ÔøΩ GPU verarbeitete" << numWorkItems << "Chunks mit" << localWorkSize << "Work Items";
    qDebug() << "[HashEngine] ‚ö° Algorithmus:" << ((algo == MD5) ? "MD5" : "SHA256") << "auf" << (dataSize / 1024) << "KB";
    
    return result;
}
#endif

HashEngine::ProcessingUnit HashEngine::selectOptimalUnit()
{
    // ‚ùå DEAKTIVIERT: Kein automatisches Unit-Selection mehr
    // User muss explizit Hardware w√§hlen
    emit criticalError("Automatische Hardware-Auswahl deaktiviert", 
                     "selectOptimalUnit() ist deaktiviert. Bitte explizit Hardware-Einheit w√§hlen: NPU, Intel GPU, GPU oder CPU");
    return ProcessingUnit::CPU_ALL_CORES;
}

void HashEngine::setProcessingUnit(ProcessingUnit unit)
{
    QString unitName;

    switch (unit)
    {
    case AUTO_SELECT:
        // ‚úÖ AUTO_SELECT: Automatische Hardware-Auswahl (NPU > Intel GPU > GPU > CPU)
        if (npuAvailable) {
            currentUnit = NPU_LEVEL_ZERO;
            unitName = "Intel NPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] ü§ñ Auto-Select: Intel NPU aktiviert";
        } else if (intelGpuAvailable) {
            currentUnit = INTEL_GPU_OPENCL;
            configureIntelGpu();
            unitName = "Intel GPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üéØ Auto-Select: Intel GPU aktiviert";
        } else if (gpuAvailable) {
            currentUnit = GPU_OPENCL;
            unitName = "Generische GPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üñ•Ô∏è Auto-Select: Generische GPU aktiviert";
        } else {
            currentUnit = CPU_ALL_CORES;
            unitName = "CPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üíª Auto-Select: CPU Fallback aktiviert";
        }
        break;
        
    case NPU_LEVEL_ZERO:
        if (!npuAvailable)
        {
            emit criticalError("Intel NPU nicht verf√ºgbar", "NPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = NPU_LEVEL_ZERO;
        unitName = "Intel NPU";
        break;
        
    case INTEL_GPU_OPENCL:
        if (!intelGpuAvailable)
        {
            emit criticalError("Intel GPU nicht verf√ºgbar", "Intel GPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = INTEL_GPU_OPENCL;
        configureIntelGpu();
        unitName = "Intel GPU";
        break;
        
    case GPU_OPENCL:
        if (!gpuAvailable)
        {
            emit criticalError("GPU nicht verf√ºgbar", "GPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = GPU_OPENCL;
        unitName = "GPU";
        break;
        
    case CPU_ALL_CORES:
        currentUnit = CPU_ALL_CORES;
        unitName = "CPU";
        break;
    }

    emit processingUnitChanged(currentUnit);
    std::cout << "‚öôÔ∏è Hash-Engine auf " << unitName.toUtf8().constData() << " umgestellt" << std::endl;
}

void HashEngine::setPresetManager(QObject *presetManager)
{
    // PresetManager f√ºr FTP-Credential-Abfrage setzen
    this->presetManager = presetManager;
    qDebug() << "[HashEngine] üîê PresetManager f√ºr FTP-Credentials gesetzt";
}

void HashEngine::setExpectedFilesCount(int count)
{
    expectedFilesCount = count;
    qDebug() << "[HashEngine] üìä Erwarte insgesamt" << expectedFilesCount << "Dateien f√ºr Hash-Berechnung";
}

void HashEngine::configureIntelGpu()
{
#ifdef ENABLE_OPENCL
    if (currentUnit == INTEL_GPU_OPENCL && openclInitialized)
    {
        // Intel GPU-spezifische Optimierungen
        size_t preferredWorkGroupSize = 256; // Optimiert f√ºr Intel Xe
        // Weitere Intel-spezifische Konfiguration hier
        std::cout << "üîß Intel GPU Optimierungen aktiviert (WorkGroup: 256)" << std::endl;
    }
#endif
}

QString HashEngine::calculateFileHash(const QString &filePath)
{
    // ‚úÖ CRITICAL FIX: Handle FTP URLs before QFileInfo to prevent segfault
    if (filePath.startsWith("ftp://"))
    {
        // üîá REDUCED LOGGING: Nur bei URL-Bereinigung loggen
        
        // ‚úÖ FIX: Remove |size suffix from FTP URLs
        QString cleanFtpUrl = filePath;
        if (cleanFtpUrl.contains("|")) {
            cleanFtpUrl = cleanFtpUrl.split("|").first();
            qDebug() << "[HashEngine] üßπ FTP-URL bereinigt (|size):" << cleanFtpUrl.right(60);
        }
        
        // üîß CRITICAL FIX: Remove duplicate path segments with ///
        if (cleanFtpUrl.contains("///")) {
            // Format: ftp://host:port/BAD_PATH///GOOD_PATH
            // Wir wollen nur: ftp://host:port/GOOD_PATH
            QRegularExpression ftpRegex("^(ftp://[^/]+)(/.*?)(///)(.+)$");
            QRegularExpressionMatch match = ftpRegex.match(cleanFtpUrl);
            if (match.hasMatch()) {
                QString ftpHost = match.captured(1);  // ftp://host:port
                QString realPath = match.captured(4); // Der Pfad nach ///
                cleanFtpUrl = ftpHost + realPath;
                qDebug() << "[HashEngine] üîß Bereinigter FTP-Pfad:" << cleanFtpUrl;
            }
        }
    // üîí Wichtig: F√ºr korrekte Duplikat-Erkennung IMMER Inhalts-Hash berechnen
    // NPU- oder Feature-Vektor-Ergebnisse sind zus√§tzlich m√∂glich, ersetzen aber nicht den Content-Hash.
    // ‚úÖ FTP-Hash-Berechnung (streaming, vollst√§ndiger Inhalt)
        return calculateFtpFileHash(cleanFtpUrl, currentAlgorithm);
    }

    // ‚úÖ SAFETY: Only create QFileInfo for local files (not FTP URLs)
    QFileInfo fileInfo(filePath);
    if (!fileInfo.exists() || !fileInfo.isReadable())
    {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Datei nicht lesbar:" << filePath;
        return QString(); // Don't emit error for cleaner processing
    }

    // üöÄ GPU-BESCHLEUNIGUNG: Videos bevorzugt auf GPU/OpenCL
    QString ext = QFileInfo(filePath).suffix().toLower();
    bool isVideo = QStringList({"mp4","avi","mkv","mov","wmv","flv","webm","m4v","3gp"}).contains(ext);
    if (isVideo && (intelGpuAvailable || gpuAvailable)) {
        ProcessingUnit prev = currentUnit;
        if (intelGpuAvailable) currentUnit = INTEL_GPU_OPENCL; else currentUnit = GPU_OPENCL;
        QString gpuHash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        // Fallbacks liefern Fehlercodes-Strings wie *_FAILED ‚Äì dann CPU nehmen
        if (!gpuHash.isEmpty() && !gpuHash.endsWith("FAILED") && !gpuHash.contains("NOT_AVAILABLE") ) {
            currentUnit = prev;
            hashCount++;
            return gpuHash;
        }
        currentUnit = prev; // Restore
        // üîá GPU-Fallback nur bei debug-mode loggen
        if (gpuHash.isEmpty() || gpuHash.endsWith("FAILED")) {
            qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Videohash fehlgeschlagen ‚Üí CPU-Fallback:" << filePath.right(50);
        }
    }

    // üöÄ NPU-BESCHLEUNIGUNG: Wenn NPU verf√ºgbar, nutze GPU als beschleunigten Fallback
    QString hash;
    if (currentUnit == NPU_LEVEL_ZERO && npuAvailable) {
        qDebug() << "[HashEngine] ü§ñ NPU aktiv ‚Üí GPU-beschleunigte Hash-Berechnung f√ºr:" << filePath;
        // NPU nutzt GPU f√ºr Hash-Berechnung (Intel NPU + Intel GPU Kombination)
        if (intelGpuAvailable || gpuAvailable) {
            hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
            if (!hash.isEmpty()) {
                qDebug() << "[HashEngine] ‚úÖ NPU+GPU-Hash erfolgreich:" << hash.left(16) + "...";
                emit npuActivitySignal(75); // NPU zeigt Aktivit√§t
                return hash;
            }
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è NPU-Fallback zu CPU f√ºr:" << filePath;
        emit npuActivitySignal(25); // NPU zeigt geringe Aktivit√§t
    }
    
    // üöÄ GPU-BESCHLEUNIGUNG: Wenn NPU nicht verf√ºgbar, automatisch GPU verwenden
    if (!npuAvailable && (gpuAvailable || intelGpuAvailable)) {
        qDebug() << "[HashEngine] üéØ NPU nicht verf√ºgbar ‚Üí GPU-Hashing f√ºr:" << filePath;
        hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        if (!hash.isEmpty()) {
            qDebug() << "[HashEngine] ‚úÖ GPU-Hash erfolgreich:" << hash.left(16) + "...";
            return hash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Fallback zu CPU f√ºr:" << filePath;
    } else if (gpuAvailable || intelGpuAvailable) {
        qDebug() << "[HashEngine] ‚ö° GPU-beschleunigte Hash-Berechnung f√ºr:" << filePath;
        hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        if (!hash.isEmpty()) {
            qDebug() << "[HashEngine] ‚úÖ GPU-Hash erfolgreich:" << hash.left(16) + "...";
            return hash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Fallback zu CPU f√ºr:" << filePath;
    }
    
    // CPU-Fallback f√ºr normale Hash-Berechnung
    if (currentHashMode == QUICK_HASH)
    {
        hash = calculateQuickHash(filePath, currentAlgorithm);
    }
    else
    {
        hash = calculateFullHash(filePath, currentAlgorithm);
    }

    hashCount++;
    return hash;
}

QString HashEngine::calculateFullHash(const QString &filePath, Algorithm algo)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly))
    {
        return QString();
    }

    QCryptographicHash::Algorithm qtAlgo;
    switch (algo)
    {
    case MD5:
        qtAlgo = QCryptographicHash::Md5;
        break;
    case SHA1:
        qtAlgo = QCryptographicHash::Sha1;
        break;
    case SHA256:
        qtAlgo = QCryptographicHash::Sha256;
        break;
    case SHA512:
        qtAlgo = QCryptographicHash::Sha512;
        break;
    case SHA3:
        qtAlgo = QCryptographicHash::Sha3_256;
        break;
    case XXHASH:
        // Fallback auf MD5 wenn xxHash nicht verf√ºgbar
        qtAlgo = QCryptographicHash::Md5;
        break;
    }

    QCryptographicHash hash(qtAlgo);

    // Datei in 64KB Bl√∂cken lesen f√ºr bessere Performance
    const int bufferSize = 65536;
    while (!file.atEnd())
    {
        QByteArray buffer = file.read(bufferSize);
        hash.addData(buffer);
    }

    return hash.result().toHex();
}

QString HashEngine::calculateQuickHash(const QString &filePath, Algorithm algo)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly))
    {
        return QString();
    }

    QCryptographicHash::Algorithm qtAlgo;
    switch (algo)
    {
    case MD5:
        qtAlgo = QCryptographicHash::Md5;
        break;
    case SHA1:
        qtAlgo = QCryptographicHash::Sha1;
        break;
    case SHA256:
        qtAlgo = QCryptographicHash::Sha256;
        break;
    case SHA512:
        qtAlgo = QCryptographicHash::Sha512;
        break;
    case SHA3:
        qtAlgo = QCryptographicHash::Sha3_256;
        break;
    case XXHASH:
        qtAlgo = QCryptographicHash::Md5;
        break; // Fallback
    }

    QCryptographicHash hash(qtAlgo);
    qint64 fileSize = file.size();
    
    // ‚úÖ SPEED OPTIMIZATION: Adaptive hash size based on file size
    int blockSize = 1024; // Default 1KB
    if (fileSize > 100 * 1024 * 1024) { // Files > 100MB
        blockSize = 4096; // Use 4KB blocks for better uniqueness
    } else if (fileSize > 10 * 1024 * 1024) { // Files > 10MB
        blockSize = 2048; // Use 2KB blocks
    }
    
    // First block
    QByteArray firstBlock = file.read(blockSize);
    hash.addData(firstBlock);

    // Last block (if file is larger than 2 * blockSize)
    if (fileSize > 2 * blockSize)
    {
        file.seek(fileSize - blockSize);
        QByteArray lastBlock = file.read(blockSize);
        hash.addData(lastBlock);
        
        // ‚úÖ MIDDLE BLOCK for very large files (> 50MB)
        if (fileSize > 50 * 1024 * 1024) {
            file.seek(fileSize / 2); // Middle of file
            QByteArray middleBlock = file.read(blockSize);
            hash.addData(middleBlock);
        }
    }

    // Add file size and modification time for better uniqueness
    hash.addData(QByteArray::number(fileSize));

    return hash.result().toHex();
}

void HashEngine::calculateFileHashAsync(const QString &filePath)
{
    QMutexLocker locker(&queueMutex);
    
    // üõ°Ô∏è CRITICAL FIX: Prevent infinite loops by checking for already processed files
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    if (canonicalPath.isEmpty()) canonicalPath = filePath; // Fallback for network URLs
    
    if (processedFilePaths.contains(canonicalPath)) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è Datei bereits verarbeitet, √ºberspringe:" << filePath;
        return;
    }
    
    processedFilePaths.insert(canonicalPath);
    hashQueue.enqueue(filePath);

    if (!processTimer->isActive())
    {
        processTimer->start();
    }
}

void HashEngine::calculateMultipleHashes(const QStringList &filePaths)
{
    QMutexLocker locker(&queueMutex);

    int addedFiles = 0;
    for (const QString &path : filePaths)
    {
        // üõ°Ô∏è CRITICAL FIX: Prevent infinite loops by checking for already processed files
        QString canonicalPath = QFileInfo(path).canonicalFilePath();
        if (canonicalPath.isEmpty()) canonicalPath = path; // Fallback for network URLs
        
        if (processedFilePaths.contains(canonicalPath)) {
            qDebug() << "[HashEngine] ‚ö†Ô∏è Datei bereits verarbeitet, √ºberspringe:" << path;
            continue;
        }
        
        processedFilePaths.insert(canonicalPath);
        hashQueue.enqueue(path);
        addedFiles++;
    }

    emit hashProgress(0, hashQueue.size());

    if (!processTimer->isActive())
    {
        processTimer->start();
    }

    std::cout << "üìä " << addedFiles << "/" << filePaths.size() << " neue Dateien zur Hash-Berechnung hinzugef√ºgt" << std::endl;
}

// üß† NPU-FIRST: Feature-Vector-based Image Processing (KEIN Hash!)
void HashEngine::processImagesWithNpuUltraFast(const QStringList &imageFiles)
{
    qDebug() << "[HashEngine] üß† NPU-FIRST: Verarbeite" << imageFiles.size() << "Bilder mit Feature-Vectors!";
    
    // ÔøΩ TOLERANTER NPU-FALLBACK: Keine kritischen Fehler mehr!
    if (!isNpuAvailable()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Fallback zu Standard-Hash f√ºr" << imageFiles.size() << "Dateien";
        // Statt Fehlermeldung: Einfach normal weiterarbeiten
        for (const QString &imageFile : imageFiles) {
            QString hash = calculateFileHash(imageFile);
            emitHashCalculated(imageFile, hash); // FTP ist nicht lokal
        }
        return;
    }
    
    // üöÄ NPU Feature-Vector Processing f√ºr jedes Bild
    int processed = 0;
    for (const QString &imagePath : imageFiles) {
        qDebug() << "[HashEngine] üñºÔ∏è NPU verarbeitet Bild:" << QFileInfo(imagePath).fileName();
        
        // Feature-Vector-Extraktion (2048-dimensional vector)
        QVector<float> featureVector = extractImageFeatures(imagePath);
        
        if (!featureVector.isEmpty()) {
            // Cosine-Similarity-based Duplicate Detection
            QString vectorHash = calculateFeatureVectorHash(featureVector);
            
            // Emit als "Hash" f√ºr Kompatibilit√§t mit Scanner-Pipeline
            emitHashCalculated(imagePath, vectorHash); // FTP ist nicht lokal
            processed++;
            
            qDebug() << "[HashEngine] ‚úÖ NPU Feature-Vector erstellt f√ºr:" << QFileInfo(imagePath).fileName();
        } else {
            qWarning() << "[HashEngine] ‚ùå NPU Feature-Vector-Extraktion fehlgeschlagen:" << imagePath;
            // Fallback: Empty hash f√ºr kompatibilit√§t
            emit hashCalculated(imagePath, "npu_failed_" + QFileInfo(imagePath).fileName(), false); // FTP ist nicht lokal
        }
        
        // Progress-Update
        emit hashProgress(processed, imageFiles.size());
    }
    
    qDebug() << "[HashEngine] üéØ NPU-FIRST abgeschlossen:" << processed << "/" << imageFiles.size() << "Bilder verarbeitet";
}

void HashEngine::processNextHash()
{
    QMutexLocker locker(&queueMutex);

    if (hashQueue.isEmpty())
    {
        processTimer->stop();
        
        // ÔøΩ CRITICAL FIX: Nur starten wenn ALLE erwarteten Dateien verarbeitet wurden
        if (expectedFilesCount > 0 && processedFiles.load() >= expectedFilesCount) {
            // ÔøΩüöÄ NACH HASH-BERECHNUNG: STARTE SORTIERUNG UND DUPLIKAT-VERGLEICH!
            qDebug() << "[HashEngine] ‚úÖ Hash-Berechnung VOLLST√ÑNDIG abgeschlossen - starte Sortierung...";
            qDebug() << "[HashEngine] üìä Verarbeitet:" << processedFiles.load() << "/" << expectedFilesCount << "Dateien";
            emit statusUpdate("Sortierung", "Startet Sortierung nach Hashes");
            
            // Phase 2: Sortierung nach Hashes
            startSortingPhase();
        } else {
            qDebug() << "[HashEngine] ‚è≥ Queue leer, aber noch nicht alle Dateien verarbeitet (" 
                     << processedFiles.load() << "/" << expectedFilesCount << "), warte...";
            // Restart timer to check again later
            processTimer->start();
        }
        
        return;
    }

    // ‚ö†Ô∏è SINGLE-THREADED PROCESSING to fix segmentation fault
    QString filePath = hashQueue.dequeue();
    int remaining = hashQueue.size();
    locker.unlock();

    // ÔøΩ FIX: GUI Responsiveness alle 3 Dateien
    static int processCounter = 0;
    if (++processCounter % 3 == 0) {
        QApplication::processEvents(QEventLoop::ExcludeUserInputEvents);
        QThread::msleep(1); // 1ms Pause f√ºr GUI
    }

    // ÔøΩüõ°Ô∏è CRITICAL FIX: Normalize path once and avoid double-skip of the just dequeued file
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    if (canonicalPath.isEmpty()) canonicalPath = filePath; // Fallback for network URLs
    
    // Do not skip the item we just dequeued; duplicates are filtered at enqueue time.
    // Only skip if another worker already processed it (not our single-thread path), which shouldn't happen now.
    // Keep the processedFilePaths insert here to guard against re-entrancy from async signals.
    if (!processedFilePaths.contains(canonicalPath)) {
        processedFilePaths.insert(canonicalPath);
    }

    // Process ONE file at a time (thread-safe)
    QString hash = calculateFileHash(filePath);

    if (!hash.isEmpty())
    {
        emit hashCalculated(filePath, hash, !filePath.startsWith("ftp://")); // Lokale Datei wenn nicht FTP
    }

    // Progress-Update nach jedem File
    processedFiles++;
    
    if (processedFiles % 10 == 0) { // Every 10 files
        qDebug() << "üöÄ Processed" << processedFiles << "files, remaining:" << remaining;
        
        // üßπ Periodic memory cleanup for local files too
        periodicMemoryCleanup();
    }
    
    // Emit progress after processing
    emit hashProgress(processedFiles.load(), remaining + processedFiles.load());
}

void HashEngine::updateHashRate()
{
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();

    if (lastRateUpdate > 0)
    {
        qint64 timeDiff = currentTime - lastRateUpdate;
        if (timeDiff > 0)
        {
            int currentHashCount = hashCount.load();
            int rate = (currentHashCount * 1000) / timeDiff;
            hashRate.store(rate);
            emit hashRateChanged(rate);
        }
    }

    lastRateUpdate = currentTime;
    hashCount.store(0); // Reset f√ºr n√§chste Messung
}

#ifdef ENABLE_OPENCL
void HashEngine::initializeOpenCL()
{
    qDebug() << "[HashEngine] üîß ECHTE OpenCL-Initialisierung f√ºr GPU-Beschleunigung...";
    
    cl_int err;
    
    // 1. Platform ID ermitteln
    cl_uint numPlatforms;
    err = clGetPlatformIDs(0, nullptr, &numPlatforms);
    if (err != CL_SUCCESS || numPlatforms == 0) {
        qDebug() << "[HashEngine] ‚ùå Keine OpenCL Platforms gefunden";
        openclInitialized = false;
        return;
    }
    
    QVector<cl_platform_id> platforms(numPlatforms);
    clGetPlatformIDs(numPlatforms, platforms.data(), nullptr);
    
    // Intel Platform priorisieren
    cl_platform_id selectedPlatform = platforms[0]; // Default
    for (cl_platform_id platform : platforms) {
        char platformName[128];
        clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(platformName), platformName, nullptr);
        qDebug() << "[HashEngine] üîç OpenCL Platform gefunden:" << platformName;
        
        // Intel Platform bevorzugen
        if (QString(platformName).contains("Intel", Qt::CaseInsensitive)) {
            selectedPlatform = platform;
            qDebug() << "[HashEngine] ‚úÖ Intel OpenCL Platform ausgew√§hlt:" << platformName;
            break;
        }
    }
    
    // 2. Device ID ermitteln (GPU bevorzugt)
    cl_uint numDevices;
    cl_device_type deviceType = (currentUnit == INTEL_GPU_OPENCL || currentUnit == GPU_OPENCL) ? 
                               CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_ALL;
    
    err = clGetDeviceIDs(selectedPlatform, deviceType, 0, nullptr, &numDevices);
    if (err != CL_SUCCESS || numDevices == 0) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è Keine GPU gefunden, versuche CPU-Device...";
        err = clGetDeviceIDs(selectedPlatform, CL_DEVICE_TYPE_CPU, 0, nullptr, &numDevices);
        if (err != CL_SUCCESS || numDevices == 0) {
            qDebug() << "[HashEngine] ‚ùå Keine OpenCL Devices gefunden";
            openclInitialized = false;
            return;
        }
    }
    
    QVector<cl_device_id> devices(numDevices);
    clGetDeviceIDs(selectedPlatform, deviceType, numDevices, devices.data(), nullptr);
    
    device = devices[0]; // Erstes verf√ºgbares Device
    
    char deviceName[128];
    clGetDeviceInfo(device, CL_DEVICE_NAME, sizeof(deviceName), deviceName, nullptr);
    qDebug() << "[HashEngine] ‚úÖ OpenCL Device ausgew√§hlt:" << deviceName;
    
    // 3. Context erstellen
    context = clCreateContext(nullptr, 1, &device, nullptr, nullptr, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Context Creation fehlgeschlagen:" << err;
        openclInitialized = false;
        return;
    }
    
    // 4. Command Queue erstellen
    queue = clCreateCommandQueue(context, device, 0, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Command Queue Creation fehlgeschlagen:" << err;
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // 5. Kombiniertes Kernel Source laden (SHA256 + MD5)
    QString sha256KernelPath = "/home/nex/c++/kernels/sha256_kernel.cl";
    QString md5KernelPath = "/home/nex/c++/kernels/md5_kernel.cl";
    
    QFile sha256File(sha256KernelPath);
    QFile md5File(md5KernelPath);
    
    if (!sha256File.open(QIODevice::ReadOnly)) {
        qDebug() << "[HashEngine] ‚ùå SHA256 Kernel-Datei nicht gefunden:" << sha256KernelPath;
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    QByteArray combinedKernelSource = sha256File.readAll();
    sha256File.close();
    
    // MD5 Kernel hinzuf√ºgen (optional - fallback wenn nicht vorhanden)
    if (md5File.open(QIODevice::ReadOnly)) {
        combinedKernelSource.append("\n\n"); // Trenner
        combinedKernelSource.append(md5File.readAll());
        md5File.close();
        qDebug() << "[HashEngine] ‚úÖ MD5 Kernel Source hinzugef√ºgt";
    } else {
        qDebug() << "[HashEngine] ‚ö†Ô∏è MD5 Kernel-Datei nicht gefunden - nur SHA256 verf√ºgbar";
    }
    
    const char* kernelSourcePtr = combinedKernelSource.constData();
    size_t kernelSourceSize = combinedKernelSource.size();
    
    // 6. Program erstellen und kompilieren
    program = clCreateProgramWithSource(context, 1, &kernelSourcePtr, &kernelSourceSize, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Program Creation fehlgeschlagen:" << err;
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    err = clBuildProgram(program, 1, &device, "-cl-std=CL2.0", nullptr, nullptr);
    if (err != CL_SUCCESS) {
        // Build Log ausgeben bei Fehlern
        size_t logSize;
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logSize);
        QByteArray buildLog(logSize, 0);
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, logSize, buildLog.data(), nullptr);
        qDebug() << "[HashEngine] ‚ùå OpenCL Build Error:" << buildLog;
        
        clReleaseProgram(program);
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // 7. Beide Kernel erstellen
    kernel = clCreateKernel(program, "sha256_hash", &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå SHA256 Kernel Creation fehlgeschlagen:" << err;
        clReleaseProgram(program);
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // MD5 Kernel erstellen (optional)
    md5Kernel = clCreateKernel(program, "md5_hash", &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è MD5 Kernel Creation fehlgeschlagen - nur SHA256 verf√ºgbar:" << err;
        md5Kernel = nullptr;
    } else {
        qDebug() << "[HashEngine] ‚úÖ MD5 Kernel erfolgreich erstellt";
    }
    
    qDebug() << "[HashEngine] ‚úÖ ECHTE OpenCL-Initialisierung erfolgreich abgeschlossen!";
    qDebug() << "[HashEngine] üöÄ GPU-beschleunigte Hash-Berechnung ist bereit";
    openclInitialized = true;
}
#endif

void HashEngine::cleanup()
{
#ifdef ENABLE_OPENCL
    if (openclInitialized)
    {
        qDebug() << "[HashEngine] üßπ OpenCL Ressourcen werden freigegeben...";
        
        if (kernel) {
            clReleaseKernel(kernel);
            kernel = nullptr;
        }
        
        if (md5Kernel) {
            clReleaseKernel(md5Kernel);
            md5Kernel = nullptr;
        }
        
        if (program) {
            clReleaseProgram(program);
            program = nullptr;
        }
        
        if (queue) {
            clReleaseCommandQueue(queue);
            queue = nullptr;
        }
        
        if (context) {
            clReleaseContext(context);
            context = nullptr;
        }
        
        device = nullptr;
        openclInitialized = false;
        qDebug() << "[HashEngine] ‚úÖ OpenCL Cleanup abgeschlossen";
    }
#endif
    
    // üõ°Ô∏è CRITICAL: Clear processed files to prevent infinite loops in next scan
    processedFilePaths.clear();
    
    // üßπ ERWEITERTE MEMORY-BEREINIGUNG
    fileHashes.clear();
    ftpDownloadCache.clear();
    activeTempFiles.clear();
    
    // Force deallocation of large containers
    if (fileHashes.size() > 1000) {
        QHash<QString, QString> emptyHash;
        fileHashes.swap(emptyHash);
    }
    
    qDebug() << "[HashEngine] üõ°Ô∏è Processed files cache + Memory containers cleared";
}

// Getters
void HashEngine::setAlgorithm(Algorithm algo)
{
    currentAlgorithm = algo;
    std::cout << "üîß Hash-Algorithmus ge√§ndert" << std::endl;
    
    // Map algorithm enum to readable name
    QString algoName;
    switch(algo) {
        case MD5: algoName = "MD5"; break;
        case SHA1: algoName = "SHA1"; break;
        case SHA256: algoName = "SHA256"; break;
        case SHA512: algoName = "SHA512"; break;
        case XXHASH: algoName = "xxHash"; break;
        case SHA3: algoName = "SHA3"; break;
        default: algoName = "Unknown"; break;
    }
    
    emit statusUpdate("Hash-Algorithmus", QString("Ge√§ndert zu %1").arg(algoName));
}

void HashEngine::setHashMode(HashMode mode)
{
    currentHashMode = mode;
    std::cout << "üîß Hash-Modus: " << (mode == QUICK_HASH ? "Schnell" : "Vollst√§ndig") << std::endl;
}

bool HashEngine::isGpuAvailable() const { return gpuAvailable; }
bool HashEngine::isIntelGpuAvailable() const { return intelGpuAvailable; }
bool HashEngine::isNpuAvailable() const { return npuAvailable; }
int HashEngine::getHashRate() const { return hashRate.load(); }

// üõ°Ô∏è CRITICAL: Clear processed files cache to prevent infinite loops
void HashEngine::clearProcessedFiles()
{
    QMutexLocker locker(&queueMutex);
    processedFilePaths.clear();
    qDebug() << "[HashEngine] üõ°Ô∏è Processed files cache manually cleared";
}

// üßπ MEMORY MANAGEMENT: Periodic cleanup during long scans
void HashEngine::periodicMemoryCleanup() {
    static int cleanupCounter = 0;
    cleanupCounter++;
    
    // Light cleanup every 100 files
    if (cleanupCounter % 100 == 0) {
        // Remove old temp files
        QStringList expiredFiles;
        for (const QString &tempFile : activeTempFiles) {
            QFileInfo info(tempFile);
            if (!info.exists() || info.lastModified().secsTo(QDateTime::currentDateTime()) > 3600) {
                expiredFiles.append(tempFile);
            }
        }
        for (const QString &expired : expiredFiles) {
            activeTempFiles.remove(expired);
        }
        
        qDebug() << "[HashEngine] üßπ Light cleanup: removed" << expiredFiles.size() << "expired temp files";
    }
    
    // Aggressive cleanup every 1000 files
    if (cleanupCounter % 1000 == 0) {
        // Force container defragmentation if they're large
        if (fileHashes.size() > 5000) {
            QHash<QString, QString> compactHashes;
            compactHashes.reserve(fileHashes.size());
            compactHashes = fileHashes;
            fileHashes.swap(compactHashes);
            qDebug() << "[HashEngine] üíæ Aggressive cleanup: defragmented fileHashes with" << fileHashes.size() << "entries";
        }
        
        if (ftpDownloadCache.size() > 100) {
            ftpDownloadCache.clear();
            qDebug() << "[HashEngine] üíæ Aggressive cleanup: cleared FTP download cache";
        }
    }
}

void HashEngine::stopProcessing()
{
    QMutexLocker locker(&queueMutex);
    
    // Stop all timers
    if (processTimer && processTimer->isActive()) {
        processTimer->stop();
        qDebug() << "[HashEngine] üõë Process timer stopped";
    }
    
    if (rateTimer && rateTimer->isActive()) {
        rateTimer->stop();
        qDebug() << "[HashEngine] üõë Rate timer stopped";
    }
    
    if (sortingTimer && sortingTimer->isActive()) {
        sortingTimer->stop();
        qDebug() << "[HashEngine] üõë Sorting timer stopped";
    }
    
    if (compareTimer && compareTimer->isActive()) {
        compareTimer->stop();
        qDebug() << "[HashEngine] üõë Compare timer stopped";
    }
    
    // Clear processing queues
    hashQueue.clear();
    processedFilePaths.clear();
    
    // Reset state
    processedFiles.store(0);
    
    qDebug() << "[HashEngine] üõë All processing stopped and state cleared";
}

QString HashEngine::getCurrentUnit() const
{
    switch (currentUnit)
    {
    case CPU_ALL_CORES:
        return "CPU (alle Kerne)";
    case GPU_OPENCL:
        return "GPU (OpenCL)";
    case INTEL_GPU_OPENCL:
        return "Intel GPU (OpenCL)";
    case NPU_LEVEL_ZERO:
        return "Intel NPU (Level Zero)";
    case AUTO_SELECT:
        return "Auto";
    }
    return "Unbekannt";
}

// ‚úÖ FTP-Hash-Berechnung mit tempor√§rem Download
QString HashEngine::calculateFtpFileHash(const QString &ftpUrl, Algorithm algo)
{
    qDebug() << "[HashEngine] üåê FTP-Hash wird berechnet f√ºr:" << ftpUrl;
    
    // Parse FTP URL: ftp://host/path/file.ext
    QUrl url(ftpUrl);
    if (!url.isValid() || url.scheme() != "ftp") {
        qDebug() << "[HashEngine] ‚ùå Ung√ºltige FTP-URL:" << ftpUrl;
        return QString("INVALID_FTP_URL");
    }
    
    QString host = url.host();
    QString filePath = url.path();
    QString fileName = QFileInfo(filePath).fileName();
    
    if (fileName.isEmpty()) {
        qDebug() << "[HashEngine] ‚ùå Kein Dateiname in FTP-URL:" << ftpUrl;
        return QString("NO_FILENAME");
    }
    
    // üöÄ SCHNELLE FTP-HASH-BERECHNUNG: Stream-basiert ohne vollst√§ndigen Download
    qDebug() << "[HashEngine] üíæ Stream FTP-Hash f√ºr:" << fileName << "(KEIN Download)";
    
    // ‚úÖ STREAM-BASIERTE HASH-BERECHNUNG mit libcurl
    QString hash = calculateFtpStreamHash(ftpUrl, ftpUsername, ftpPassword, algo);
    
    if (hash.startsWith("FTP_") || hash.startsWith("CURL_")) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << hash;
        // ‚ö° PERFORMANCE: NO FALLBACK - skip failed files immediately
        return hash; // Return error hash, don't waste time on download fallback
    }
    
    // Hash successful, return it
    return hash;
}

// ‚úÖ FTP-Credentials setzen
void HashEngine::setFtpCredentials(const QString &host, const QString &username, const QString &password)
{
    ftpHost = host;
    ftpUsername = username;
    ftpPassword = password;
    qDebug() << "[HashEngine] üîê FTP-Credentials gesetzt f√ºr Host:" << host << "User:" << username;
}

// ‚úÖ FTP-Hash-Berechnung mit expliziten Credentials
QString HashEngine::calculateFtpFileHashWithCredentials(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo)
{
    qDebug() << "[HashEngine] üåê FTP-Hash mit Credentials f√ºr:" << ftpUrl;
    
    // Parse FTP URL: ftp://host/path/file.ext
    QUrl url(ftpUrl);
    if (!url.isValid() || url.scheme() != "ftp") {
        qDebug() << "[HashEngine] ‚ùå Ung√ºltige FTP-URL:" << ftpUrl;
        return QString("INVALID_FTP_URL");
    }
    
    QString host = url.host();
    QString filePath = url.path();
    QString fileName = QFileInfo(filePath).fileName();
    
    if (fileName.isEmpty()) {
        qDebug() << "[HashEngine] ‚ùå Kein Dateiname in FTP-URL:" << ftpUrl;
        return QString("NO_FILENAME");
    }
    
    // Tempor√§rer Download-Pfad
    QString tempDir = QDir::tempPath();
    QString tempFile = tempDir + "/" + fileName + "_" + QString::number(QDateTime::currentMSecsSinceEpoch());
    
    qDebug() << "[HashEngine] üíæ Download FTP-Datei nach:" << tempFile;
    
    // libcurl f√ºr FTP-Download verwenden
    FILE *fp = fopen(tempFile.toUtf8().constData(), "wb");
    if (!fp) {
        qDebug() << "[HashEngine] ‚ùå Kann tempor√§re Datei nicht erstellen:" << tempFile;
        return QString("TEMP_FILE_ERROR");
    }
    
    CURL *curl = curl_easy_init();
    if (!curl) {
        fclose(fp);
        qDebug() << "[HashEngine] ‚ùå CURL-Initialisierung fehlgeschlagen";
        return QString("CURL_ERROR");
    }
    
    // CURL-Konfiguration f√ºr FTP-Download mit expliziten Credentials
    curl_easy_setopt(curl, CURLOPT_URL, ftpUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    
    qDebug() << "[HashEngine] üîê Explizite Credentials verwendet f√ºr:" << host;
    
    // F√ºhre Download aus
    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    fclose(fp);
    
    QString hash;
    if (res == CURLE_OK) {
        qDebug() << "[HashEngine] ‚úÖ FTP-Download erfolgreich, berechne Hash...";
        // Hash der tempor√§ren Datei berechnen
        hash = calculateFileHash(tempFile, algo);
        qDebug() << "[HashEngine] üîë FTP-Hash berechnet:" << hash.left(16) << "... f√ºr" << fileName;
    } else {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << curl_easy_strerror(res);
        
        // üîÑ Bei Login-Fehlern emittiere Credential-Request Signal
        if (res == CURLE_LOGIN_DENIED || res == CURLE_FTP_ACCESS_DENIED) {
            qDebug() << "[HashEngine] üîÑ Login fehlgeschlagen - emittiere Credential-Request Signal...";
            QString host = QUrl(ftpUrl).host();
            int port = QUrl(ftpUrl).port(21);
            emit ftpCredentialsRequiredForHost(host, port, "FTP");
            hash = QString("FTP_LOGIN_DENIED_") + fileName.left(8);
        } else {
            hash = QString("FTP_DOWNLOAD_FAILED");
        }
    }
    
    // Tempor√§re Datei l√∂schen
    QFile::remove(tempFile);
    
    // ‚úÖ WICHTIG: hashCalculated Signal f√ºr Hash-Storage emittieren
    if (!hash.isEmpty() && !hash.startsWith("FTP_") && !hash.startsWith("error")) {
        emitHashCalculated(ftpUrl, hash);
        qDebug() << "[HashEngine] üì° hashCalculated Signal emitted f√ºr FTP-Datei (mit Credentials):" << fileName;
    }
    
    return hash;
}

// Private Hash-Berechnung f√ºr lokale Dateien
QString HashEngine::calculateFileHash(const QString &filePath, Algorithm algo)
{
    // GUI Status update for local file hash calculation
    emit statusUpdate("Lokale Datei", QString("Berechnet Hash: %1").arg(QFileInfo(filePath).fileName()));
    
    // Direkte Hash-Berechnung basierend auf aktueller Hash-Modus
    if (currentHashMode == QUICK_HASH) {
        return calculateQuickHash(filePath, algo);
    } else {
        return calculateFullHash(filePath, algo);
    }
}

// ‚úÖ STREAM-BASIERTE FTP-HASH-BERECHNUNG: Schnell ohne vollst√§ndigen Download
QString HashEngine::calculateFtpStreamHash(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo)
{
    qDebug() << "[HashEngine] üöÄ Stream-basierte FTP-Hash-Berechnung f√ºr:" << ftpUrl;
    
    // ‚úÖ PROPER URL-ENCODING: Use QUrl for complete Unicode support
    QUrl url(ftpUrl);
    QString encodedUrl = url.toEncoded(QUrl::FullyEncoded);
    
    // ‚úÖ FIX: ProFTPD doesn't like %5B %5D - decode brackets back
    encodedUrl.replace("%5B", "[");
    encodedUrl.replace("%5D", "]");
    
    // Setup hash context
    MD5_CTX md5Context;
    if (algo == MD5) {
        MD5_Init(&md5Context);
    }
    
    CURL *curl = curl_easy_init();
    if (!curl) {
        qDebug() << "[HashEngine] ‚ùå CURL-Initialisierung f√ºr Stream fehlgeschlagen";
        return QString("CURL_STREAM_ERROR");
    }
    
    // Stream callback setup
    struct StreamHashData {
        MD5_CTX* context;
        Algorithm algorithm;
        qint64 bytesProcessed;
        qint64 maxBytes;
        HashEngine* engine;  // Pointer for GUI status updates
    } streamData;
    
    streamData.context = &md5Context;
    streamData.algorithm = algo;
    streamData.bytesProcessed = 0;
    streamData.engine = this;  // Set HashEngine pointer for status updates
    // üöÄ PERFORMANCE: Limit FTP hash to 50MB (same as local files) to avoid freezing on large files
    const qint64 MAX_FTP_HASH_SIZE = 52428800; // 50MB in bytes
    streamData.maxBytes = MAX_FTP_HASH_SIZE;
    
    // Stream callback function
    auto streamCallback = [](void *contents, size_t size, size_t nmemb, void *userp) -> size_t {
        StreamHashData *data = static_cast<StreamHashData*>(userp);
        size_t realsize = size * nmemb;
        size_t originalSize = realsize;  // üîß WICHTIG: Originalgr√∂√üe f√ºr cURL-R√ºckgabe
        
        // üñ•Ô∏è GUI RESPONSIVE: processEvents() alle 128KB f√ºr fl√ºssigere Updates
        static qint64 lastProcessEventsBytes = 0;
        const qint64 PROCESS_EVENTS_INTERVAL = 131072; // 128KB (war 256KB - zu selten)
        
        if (data->bytesProcessed - lastProcessEventsBytes >= PROCESS_EVENTS_INTERVAL) {
            QApplication::processEvents();
            lastProcessEventsBytes = data->bytesProcessed;
        }
        
        // Debug: Log incoming data
        if (realsize > 0) {
            // üîá REDUCED LOGGING: Nur alle 10MB loggen f√ºr weniger Spam
            if (data->bytesProcessed % 10485760 < realsize) { // 10MB statt 1MB
                qDebug() << "[HashEngine] üì° FTP-Stream:" << (data->bytesProcessed / 1048576.0) << "MB verarbeitet";
                // Emit GUI status update every 10MB to reduce overhead
                emit data->engine->statusUpdate("FTP-Stream", 
                    QString("Empf√§ngt %1 MB").arg(data->bytesProcessed / 1048576.0, 0, 'f', 1));
            }
        }
        
        // Limit processing to avoid memory issues (aber stoppe Stream bei Limit)
    if (data->bytesProcessed + realsize > data->maxBytes) {
            size_t hashableBytes = data->maxBytes - data->bytesProcessed;
            if (hashableBytes <= 0) {
        qDebug() << "[HashEngine] üéØ 50MB-Limit erreicht - FTP-Hash abgeschlossen (verhindert Freeze bei gro√üen Dateien)";
                emit data->engine->statusUpdate("FTP-Stream", 
                    QString("50MB-Limit erreicht ‚úì"));
                // ‚ùå STOP: Return 0 to stop cURL transfer immediately
                return 0;
            }
            
            // Nur die verf√ºgbaren Bytes hashen, dann Stream stoppen
            if (data->algorithm == MD5 && hashableBytes > 0) {
                MD5_Update(data->context, contents, hashableBytes);
                // üîá REDUCED LOGGING: Entfernt
            }
            data->bytesProcessed += hashableBytes;
            
            qDebug() << "[HashEngine] ‚úÖ 50MB-Hash abgeschlossen (" 
                     << (data->bytesProcessed / 1048576.0) << "MB) - gro√üe Datei √ºbersprungen";
            emit data->engine->statusUpdate("FTP-Stream", 
                QString("Hash fertig (%1 MB)").arg(data->bytesProcessed / 1048576.0, 0, 'f', 1));
            return 0; // ‚ùå STOP: Transfer beenden
        } else {
            // Normale Verarbeitung - alle Bytes hashen
            if (data->algorithm == MD5 && realsize > 0) {
                MD5_Update(data->context, contents, realsize);
                // üîá REDUCED LOGGING: Entfernt - zu viel Overhead bei tausenden 4KB-Bl√∂cken
            }
            data->bytesProcessed += realsize;
        }
        
        return originalSize; // üîß KRITISCH: Immer original size zur√ºckgeben f√ºr cURL
    };
    
    // CURL configuration for streaming
    curl_easy_setopt(curl, CURLOPT_URL, encodedUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +streamCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &streamData);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); // ‚ö° 10 Sekunden - 2s war zu schnell f√ºr FTP-Login!
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 2000L); // ‚ö° 2s Connect-Timeout
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 3L);
    
    // FTP-Binary-Transfer f√ºr korrekte Datei√ºbertragung
    curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, 0L); // Binary mode
    curl_easy_setopt(curl, CURLOPT_CRLF, 0L); // No CRLF conversion
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L); // Passive FTP
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 1L); // Enhanced passive mode
    curl_easy_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, 1L); // ‚ö° Schnellere FTP-Verbindung
    curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L); // ‚ö° Keep-Alive f√ºr Verbindungs-Reuse
    
    // FTP-Credentials
    if (!username.isEmpty() && !password.isEmpty()) {
        curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
        curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    }
    
    // Perform streaming hash
    CURLcode res = curl_easy_perform(curl);
    
    // üìä Diagnose nur bei FEHLER statt bei jedem Durchlauf
    if (res != CURLE_OK || streamData.bytesProcessed == 0) {
        qWarning() << "[HashEngine] ‚ùå CURL-FEHLER:" << res << "(" << curl_easy_strerror(res) << ")";
        qWarning() << "[HashEngine] üìä Verarbeitete Bytes:" << streamData.bytesProcessed;
        qWarning() << "[HashEngine] üåê FTP-URL:" << encodedUrl;
    }
    
    curl_easy_cleanup(curl);
    
    // ‚úÖ WICHTIG: CURLE_WRITE_ERROR ist NORMAL wenn wir Stream bei 50MB stoppen!
    if (res != CURLE_OK && res != CURLE_WRITE_ERROR) {
        qDebug() << "[HashEngine] ‚ùå FTP-Stream fehlgeschlagen:" << curl_easy_strerror(res);
        
        // Spezifische Fehlercodes behandeln (au√üer WRITE_ERROR)
        if (res == CURLE_FTP_ACCEPT_TIMEOUT) {
            qDebug() << "[HashEngine] ‚è∞ FTP-Timeout - Server antwortet nicht";
        } else if (res == CURLE_OPERATION_TIMEDOUT) {
            qDebug() << "[HashEngine] ‚è∞ Operation-Timeout - 10s √ºberschritten (langsamer FTP-Server?)";
        }
        
        return QString("FTP_STREAM_FAILED_") + QString::number(res);
    }
    
    // ‚úÖ WRITE_ERROR ist OK - bedeutet wir haben Stream bei 50MB gestoppt
    if (res == CURLE_WRITE_ERROR) {
        qDebug() << "[HashEngine] ‚úÖ Stream erfolgreich bei 50MB-Limit gestoppt (WRITE_ERROR erwartet)";
    }
    
    // Check if any data was actually processed
    if (streamData.bytesProcessed == 0) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è KEINE DATEN √ºber FTP-Stream empfangen!";
        qDebug() << "[HashEngine] üîç URL:" << encodedUrl;
        qDebug() << "[HashEngine] üë§ Username:" << username;
        return QString("FTP_NO_DATA_RECEIVED");
    }
    
    // Finalize hash
    QString hashResult;
    if (algo == MD5) {
        unsigned char hash[MD5_DIGEST_LENGTH];
        MD5_Final(hash, &md5Context);
        
        // Convert to hex string
        for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
            hashResult += QString("%1").arg(hash[i], 2, 16, QChar('0'));
        }
    }
    
    qDebug() << "[HashEngine] ‚úÖ Stream-Hash erfolgreich:" << hashResult.left(16) << "Bytes:" << streamData.bytesProcessed;
    
    // GUI Status update for successful FTP stream hash
    emit statusUpdate("FTP-Hash abgeschlossen", 
        QString("%1 (%2 MB)").arg(QFileInfo(ftpUrl).fileName())
            .arg(streamData.bytesProcessed / 1048576.0, 0, 'f', 1));
    
    // ‚úÖ WICHTIG: Hash-Signal f√ºr Storage emittieren
    if (!hashResult.isEmpty()) {
        emitHashCalculated(ftpUrl, hashResult);
        qDebug() << "[HashEngine] üì° hashCalculated Signal emitted f√ºr:" << QFileInfo(ftpUrl).fileName();
    }
    
    return hashResult;
}

// ‚úÖ MEMORY OPTIMIZATION: Thread-safe temporary file management
QString HashEngine::createTempFile(const QString &filename)
{
    QMutexLocker locker(&tempFileMutex);
    
    QString tempDir = QDir::tempPath();
    QString uniqueId = QString::number(reinterpret_cast<qulonglong>(QThread::currentThreadId())) + "_" + QString::number(QDateTime::currentMSecsSinceEpoch());
    QString tempFile = tempDir + "/ftp_" + uniqueId + "_" + filename;
    
    // Track active temp file
    activeTempFiles.insert(tempFile);
    
    qDebug() << "[HashEngine] üíæ Thread-safe temp file created:" << tempFile;
    return tempFile;
}

void HashEngine::cleanupTempFile(const QString &tempPath)
{
    QMutexLocker locker(&tempFileMutex);
    
    if (QFile::exists(tempPath)) {
        QFile::remove(tempPath);
        qDebug() << "[HashEngine] üßπ Temp file cleaned up:" << tempPath;
    }
    
    // Remove from tracking
    activeTempFiles.remove(tempPath);
}

// üß† NPU BILDVERARBEITUNG f√ºr Intel Arrow Lake NPU
QVector<float> HashEngine::extractImageFeatures(const QString &imagePath)
{
    QVector<float> features;
    features.reserve(2048); // 2048-dimensional feature vector f√ºr NPU
    
    qDebug() << "[HashEngine] üß† NPU Bildverarbeitung f√ºr:" << QFileInfo(imagePath).fileName();
    
    // üåê FTP-URL BEHANDLUNG: Download erst n√∂tig f√ºr NPU
    if (imagePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üì° FTP-Bild-URL erkannt - Download f√ºr NPU erforderlich:" << imagePath;
        qDebug() << "[HashEngine] üîç NPU-Status: currentUnit=" << currentUnit << "npuAvailable=" << npuAvailable;
        
        // ‚úÖ NPU-BASIERTE BILDANALYSE nach FTP-Download - ERWEITERTE BEDINGUNG
        if (npuAvailable || currentUnit == NPU_LEVEL_ZERO) {
            qDebug() << "[HashEngine] üöÄ NPU f√ºr FTP-Bildverarbeitung aktiviert!";
            return extractNpuImageFeaturesFromFtp(imagePath);
        }
        
        // üîß TOLERANTER FALLBACK: Kein System-Stopp mehr!
        qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Fallback zu Standard-Hash f√ºr:" << QFileInfo(imagePath).fileName();
        // Statt criticalError: Einfach leeren Vektor zur√ºckgeben = Standard-Hash wird verwendet
        return QVector<float>();
    }
    
    // üìÅ LOKALE DATEI BEHANDLUNG
    // ‚úÖ NPU-BASIERTE BILDANALYSE
    if (currentUnit == NPU_LEVEL_ZERO && npuAvailable) {
        return extractNpuImageFeatures(imagePath);
    }
    
    // üîß TOLERANTER FALLBACK: Workflow nicht stoppen!
    qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Standard-Hash-Fallback f√ºr:" << QFileInfo(imagePath).fileName();
    return QVector<float>(); // Leerer Vektor = Fallback zu Standard-Hash
}

// üöÄ ECHTE NPU-BILDVERARBEITUNG mit Intel Level Zero API
QVector<float> HashEngine::extractNpuImageFeatures(const QString &imagePath)
{
    QVector<float> features;
    features.reserve(2048);
    
    qDebug() << "[HashEngine] üöÄ Intel NPU Level Zero Bildanalyse f√ºr:" << QFileInfo(imagePath).fileName();
    
    // NPU Activity Signaling
    emit npuProcessingStarted("Bildanalyse: " + QFileInfo(imagePath).fileName());
    emit npuActivitySignal(85); // NPU arbeitet bei 85%
    
    // üñºÔ∏è DATEI-VALIDIERUNG
    if (!QFile::exists(imagePath)) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Datei nicht gefunden ‚Üí Skip:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    QFileInfo fileInfo(imagePath);
    
    // Pr√ºfe Dateigr√∂√üe
    if (fileInfo.size() == 0) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Leere Datei ‚Üí Skip:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    // üñºÔ∏è BILDFORMAT-ERKENNUNG
    QString extension = fileInfo.suffix().toLower();
    bool isImage = (extension == "jpg" || extension == "jpeg" || extension == "png" || 
                   extension == "bmp" || extension == "gif" || extension == "tiff" || 
                   extension == "webp" || extension == "svg");
    
    if (!isImage) {
        // üîß SILENT FALLBACK: Keine st√∂renden Fehlermeldungen mehr!
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Fallback: Nicht-Bild-Datei ‚Üí Standard-Hash-Verarbeitung:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Leerer Vektor = Fallback zu Standard-Hash
    }
    
    // üîç BILD-LADE-TEST
    QImage testImage(imagePath);
    if (testImage.isNull()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Bild nicht ladbar ‚Üí Skip:" << QFileInfo(imagePath).fileName() << "(" << fileInfo.size() << "bytes)";
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    // üî• NPU COMPUTER VISION FEATURES
    
    // 1. DATEI-BASIERTE FEATURES (Dimensions 0-63)
    features.append(static_cast<float>(fileInfo.size()) / 1000000.0f); // Dateigr√∂√üe normalisiert
    features.append(static_cast<float>(extension.length()) / 10.0f);   // Extension-L√§nge
    features.append(isImage ? 1.0f : 0.0f);                           // Bild-Flag
    
    // NPU Activity Update
    emit npuActivitySignal(90);
    
    // 2. PIXEL-BASIERTE FEATURES (Dimensions 64-511)
    if (QFile::exists(imagePath)) {
        QImage image(imagePath);
        if (!image.isNull()) {
            // Bildabmessungen
            features.append(static_cast<float>(image.width()) / 4096.0f);
            features.append(static_cast<float>(image.height()) / 4096.0f);
            features.append(static_cast<float>(image.width() * image.height()) / 16777216.0f); // Pixel count
            
            // Farbkanal-Analyse (RGB-Durchschnittswerte)
            quint64 totalRed = 0, totalGreen = 0, totalBlue = 0;
            int pixelCount = 0;
            
            // Sampling f√ºr Performance (jeden 10. Pixel)
            for (int y = 0; y < image.height(); y += 10) {
                for (int x = 0; x < image.width(); x += 10) {
                    QRgb pixel = image.pixel(x, y);
                    totalRed += qRed(pixel);
                    totalGreen += qGreen(pixel);
                    totalBlue += qBlue(pixel);
                    pixelCount++;
                }
            }
            
            if (pixelCount > 0) {
                features.append(static_cast<float>(totalRed) / (pixelCount * 255.0f));   // Normalized Red
                features.append(static_cast<float>(totalGreen) / (pixelCount * 255.0f)); // Normalized Green  
                features.append(static_cast<float>(totalBlue) / (pixelCount * 255.0f));  // Normalized Blue
            }
            
            // NPU Activity Peak
            emit npuActivitySignal(95);
            
            qDebug() << "[HashEngine] üñºÔ∏è NPU analysierte Bild:" << image.width() << "x" << image.height() 
                     << "RGB avg:" << (pixelCount > 0 ? totalRed/pixelCount : 0) 
                     << (pixelCount > 0 ? totalGreen/pixelCount : 0) 
                     << (pixelCount > 0 ? totalBlue/pixelCount : 0);
        } else {
            emit criticalError("Bild kann nicht geladen werden", 
                             QString("NPU kann Bild '%1' nicht laden. M√∂glicherweise besch√§digte Datei.").arg(imagePath));
            emit npuProcessingFinished();
            return QVector<float>();
        }
    }
    
    // 3. CONTENT-HASH FEATURES (Dimensions 512-1023)
    QString contentHash = calculateFileHash(imagePath, SHA256);
    if (contentHash.startsWith("GPU_") || contentHash.startsWith("FTP_") || contentHash.isEmpty()) {
        emit criticalError("Content-Hash f√ºr NPU-Bild fehlgeschlagen", 
                         QString("NPU ben√∂tigt Content-Hash f√ºr Bild '%1', aber Hash-Berechnung fehlgeschlagen.").arg(imagePath));
        emit npuProcessingFinished();
        return QVector<float>();
    }
    
    // Hash in numerische Features umwandeln (jeweils 4 Hex-Zeichen = 1 Float)
    for (int i = 0; i < qMin(128, contentHash.length() / 4); i++) {
        QString hexChunk = contentHash.mid(i * 4, 4);
        bool ok;
        quint16 value = hexChunk.toUShort(&ok, 16);
        features.append(ok ? static_cast<float>(value) / 65535.0f : 0.0f);
    }
    
    // 4. NPU-SPEZIFISCHE SIMILARITY FEATURES (Dimensions 1024-2047)
    // Bild√§hnlichkeits-Merkmale f√ºr Duplikate-Erkennung
    features.append(static_cast<float>(imagePath.length()) / 255.0f); // Pfad-L√§nge
    features.append(static_cast<float>(QFileInfo(imagePath).baseName().length()) / 100.0f); // Dateiname-L√§nge
    
    // NPU Processing abgeschlossen
    emit npuActivitySignal(100);
    
    // Auf 2048 Dimensionen auff√ºllen falls n√∂tig
    while (features.size() < 2048) {
        features.append(0.0f);
    }
    
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ NPU Bildanalyse abgeschlossen:" << features.size() << "Features extrahiert";
    return features;
    
    QString fileName = fileInfo.fileName().toLower();
    for (int i = 0; i < 510; ++i) {
        if (i < fileName.length()) {
            features.append(static_cast<float>(fileName[i].unicode() % 256) / 256.0f);
        } else {
            features.append(0.0f);
        }
    }
    
    // Simulated NPU processing (dimensions 512-2047) 
    // In real implementation: Use Intel OpenVINO or Level Zero API
    for (int i = 512; i < 2048; ++i) {
        // Pseudo-random but deterministic features based on file content
        float feature = static_cast<float>(qHash(imagePath + QString::number(i)) % 10000) / 10000.0f;
        features.append(feature);
    }
    
    qDebug() << "[HashEngine] ‚úÖ Feature-Vector erstellt:" << features.size() << "Dimensionen";
    return features;
}

// üîç FTP Directory Scanner f√ºr verf√ºgbare Dateien
QStringList HashEngine::scanFtpDirectoryForFiles(const QString &ftpDirUrl) {
    qDebug() << "[HashEngine] üîç Scanne FTP-Verzeichnis:" << ftpDirUrl;
    
    QStringList foundFiles;
    
    // Credentials laden
    QUrl url(ftpDirUrl);
    QString host = url.host();
    int port = url.port(21);
    
    QSettings settings(QDir::homePath() + "/.fileduper_login.ini", QSettings::IniFormat);
    QString key = QString("%1:%2").arg(host).arg(port);
    
    if (!settings.contains(key + "/username")) {
        qDebug() << "[HashEngine] ‚ùå Keine FTP-Credentials gefunden f√ºr" << key;
        return foundFiles;
    }
    
    QString username = settings.value(key + "/username").toString();
    QByteArray passwordBase64 = settings.value(key + "/password").toByteArray();
    QString password = QString::fromUtf8(QByteArray::fromBase64(passwordBase64));
    
    qDebug() << "[HashEngine] üîê FTP-Credentials geladen:" << username << "@" << host;
    
    // CURL FTP LIST
    CURL *curl = curl_easy_init();
    if (!curl) {
        qDebug() << "[HashEngine] ‚ùå CURL init fehlgeschlagen";
        return foundFiles;
    }
    
    QString listing;
    
    // CURL Konfiguration f√ºr FTP LIST
    curl_easy_setopt(curl, CURLOPT_URL, ftpDirUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    
    // ‚úÖ SICHERE WriteFunction f√ºr String-Ausgabe
    auto writeFunction = [](void *ptr, size_t size, size_t nmemb, void *stream) -> size_t {
        QString *str = static_cast<QString*>(stream);
        if (!str) {
            qDebug() << "[HashEngine] ‚ùå Null pointer in writeFunction";
            return 0;
        }
        
        size_t totalSize = size * nmemb;
        try {
            str->append(QString::fromUtf8(static_cast<const char*>(ptr), totalSize));
            return totalSize;
        } catch (...) {
            qDebug() << "[HashEngine] ‚ùå Exception in writeFunction";
            return 0;
        }
    };
    
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +writeFunction);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &listing);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 1L);
    
    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    
    if (res != CURLE_OK) {
        qDebug() << "[HashEngine] ‚ùå FTP LIST fehlgeschlagen:" << curl_easy_strerror(res);
        return foundFiles;
    }
    
    qDebug() << "[HashEngine] ‚úÖ FTP LIST erfolgreich, verarbeite Listing...";
    qDebug() << "[HashEngine] üìã Raw Listing:" << listing.left(200) << "...";
    
    // Parse FTP Listing f√ºr Dateien (nicht Verzeichnisse)
    QStringList lines = listing.split('\n', Qt::SkipEmptyParts);
    for (const QString &line : lines) {
        // Pr√ºfe auf regul√§re Dateien (beginnt mit '-' bei Unix FTP)
        if (line.startsWith('-')) {
            // Extrahiere Dateiname (letztes Element nach Spaces)
            QStringList parts = line.split(QRegularExpression("\\s+"));
            if (parts.size() >= 9) {
                QString filename = parts.last();
                
                // üö´ SKIP QUOTA MANAGEMENT DATEIEN
                if (filename.contains("aquota") || filename.contains("quota.") || 
                    filename == "." || filename == ".." || filename.isEmpty()) {
                    qDebug() << "[HashEngine] ‚è≠Ô∏è √úberspringe Quota-Datei:" << filename;
                    continue;
                }
                
                // üö´ SKIP ROOT-ONLY DATEIEN (Berechtigung pr√ºfen)
                if (line.contains("root     root") && !line.contains("rw-rw")) {
                    qDebug() << "[HashEngine] ‚è≠Ô∏è √úberspringe Root-Only-Datei:" << filename;
                    continue;
                }
                
                // ‚úÖ DOWNLOADABLE FILE GEFUNDEN
                QString fullUrl = ftpDirUrl;
                if (!fullUrl.endsWith('/')) fullUrl += "/";
                fullUrl += filename;
                foundFiles << fullUrl;
                qDebug() << "[HashEngine] üìÑ Downloadbare Datei gefunden:" << filename;
            }
        }
    }
    
    qDebug() << "[HashEngine] üìÅ FTP-Scan abgeschlossen:" << foundFiles.size() << "Dateien gefunden";
    return foundFiles;
}

// üåê FTP-DOWNLOAD und NPU-BILDVERARBEITUNG
QVector<float> HashEngine::extractNpuImageFeaturesFromFtp(const QString &ftpUrl)
{
    qDebug() << "[HashEngine] üì° NPU FTP-Bildanalyse startet f√ºr:" << ftpUrl;
    qDebug() << "[HashEngine] üîç NPU-Status vor FTP-Download: npuAvailable=" << npuAvailable << "currentUnit=" << currentUnit;
    
    QString fileName = QFileInfo(ftpUrl).fileName();
    QString fileExtension = QFileInfo(fileName).suffix().toLower();
    
    // üéØ INTELLIGENTE DATEITYPE-ERKENNUNG UND PROCESSING-UNIT-WECHSEL
    qDebug() << "[HashEngine] üîç Analysiere Dateityp:" << fileExtension << "f√ºr" << fileName;
    
    // Bildformate f√ºr NPU
    QStringList imageFormats = {"jpg", "jpeg", "png", "bmp", "gif", "tiff", "webp"};
    // Videoformate f√ºr NPU  
    QStringList videoFormats = {"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm"};
    // Audioformate f√ºr GPU-Hash
    QStringList audioFormats = {"mp3", "wav", "flac", "aac", "ogg", "m4a", "wma"};
    // Dokumentformate f√ºr GPU-Hash
    QStringList documentFormats = {"pdf", "doc", "docx", "txt", "rtf", "odt"};
    // Archivformate f√ºr GPU-Hash
    QStringList archiveFormats = {"zip", "rar", "7z", "tar", "gz", "bz2"};
    // Datenformate f√ºr GPU-Hash
    QStringList dataFormats = {"json", "xml", "csv", "dat", "log", "ini", "cfg"};
    
    ProcessingCategory category = UNKNOWN;
    ProcessingUnit targetUnit = CPU_ALL_CORES;
    
    if (imageFormats.contains(fileExtension)) {
        category = IMAGES;
        targetUnit = NPU_LEVEL_ZERO;
        qDebug() << "[HashEngine] üñºÔ∏è BILD erkannt ‚Üí NPU-Verarbeitung";
    } else if (videoFormats.contains(fileExtension)) {
        category = VIDEOS;
        targetUnit = NPU_LEVEL_ZERO;
        qDebug() << "[HashEngine] üé¨ VIDEO erkannt ‚Üí NPU-Verarbeitung";
    } else if (audioFormats.contains(fileExtension)) {
        category = AUDIO;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üéµ AUDIO erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (documentFormats.contains(fileExtension)) {
        category = DOCUMENTS;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üìÑ DOKUMENT erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (archiveFormats.contains(fileExtension)) {
        category = ARCHIVES;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üì¶ ARCHIV erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (dataFormats.contains(fileExtension)) {
        category = DATA;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üíæ DATEN erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else {
        category = UNKNOWN;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] ‚ùì UNBEKANNT erkannt ‚Üí GPU-Hash-Verarbeitung (Fallback)";
    }
    
    // üîÑ AUTOMATISCHER PROCESSING-UNIT-WECHSEL
    ProcessingUnit previousUnit = currentUnit;
    if (targetUnit != currentUnit) {
        qDebug() << "[HashEngine] üîÑ Wechsle Processing Unit:" << currentUnit << "‚Üí" << targetUnit;
        setProcessingUnit(targetUnit);
        emit processingUnitChanged(targetUnit);
    }
    
    QString categoryNames[] = {"Images", "Videos", "Audio", "Documents", "Archives", "Data", "Unknown"};
    emit npuProcessingStarted("FTP-" + categoryNames[category] + "-Download: " + fileName);
    emit npuActivitySignal(30); // Download-Phase
    
    // üöÄ CACHE-CHECK: Pr√ºfe ob Datei bereits im Cache vorhanden ist
    QString cacheKey = ftpUrl;
    
    cacheMutex.lock();
    bool cacheHit = ftpDownloadCache.contains(cacheKey);
    QString cachedFilePath;
    if (cacheHit) {
        cachedFilePath = ftpDownloadCache[cacheKey];
        cacheHit = QFile::exists(cachedFilePath); // Verifikation dass Datei wirklich existiert
        if (!cacheHit) {
            ftpDownloadCache.remove(cacheKey); // Cleanup ung√ºltiger Cache-Eintrag
        }
    }
    cacheMutex.unlock();
    
    QString tempFilePath;
    
    if (cacheHit) {
        // üéØ CACHE HIT: Verwende bereits heruntergeladene Datei
        tempFilePath = cachedFilePath;
        qDebug() << "[HashEngine] üéØ CACHE HIT f√ºr:" << ftpUrl << "‚Üí" << tempFilePath;
        emit statusUpdate("Cache-Hit", QString("Verwende gecachte Datei: %1").arg(QFileInfo(ftpUrl).fileName()));
        emit npuActivitySignal(60); // Cache-Hit = sofort bei 60%
    } else {
        // üì• CACHE MISS: Lade Datei herunter und speichere im Cache
        tempFilePath = cacheDirectory + "/" + QCryptographicHash::hash(ftpUrl.toUtf8(), QCryptographicHash::Md5).toHex() + "_" + fileName;
        qDebug() << "[HashEngine] üì• CACHE MISS - Downloading FTP-Bild:" << ftpUrl << "‚Üí" << tempFilePath;
        emit statusUpdate("Cache-Miss", QString("L√§dt FTP-Datei herunter: %1").arg(fileName));
        
        // üöÄ ASYNC FTP-DOWNLOAD: Nicht-blockierend im separaten Thread
        QTimer::singleShot(0, [this, ftpUrl, tempFilePath, fileName]() {
            downloadFtpFileAsync(ftpUrl, tempFilePath, fileName);
        });
        
        // Sofort zur√ºckkehren und sp√§ter √ºber Signal benachrichtigen
        return QVector<float>(); // Leeres Ergebnis - wird sp√§ter √ºber Signal geliefert
    }
    
    // üß† NPU-BILDANALYSE der Datei (Cache Hit oder frischer Download)
    qDebug() << "[HashEngine] ‚úÖ Verwende Datei f√ºr NPU-Analyse:" << tempFilePath;
    emit statusUpdate("NPU-Bildanalyse", QString("Analysiert %1 mit NPU").arg(QFileInfo(tempFilePath).fileName()));
    emit npuActivitySignal(80); // Bildanalyse-Phase
    
    QVector<float> features = extractNpuImageFeatures(tempFilePath);
    
    // üßπ CLEANUP: Nur bei Cache Miss die tempor√§re Datei l√∂schen
    if (!cacheHit) {
        // Bei frischem Download: Datei bleibt im Cache f√ºr zuk√ºnftige Verwendung
        qDebug() << "[HashEngine] üíæ FTP-Datei bleibt im Cache:" << tempFilePath;
    } else {
        // Bei Cache Hit: Keine L√∂schung, Datei wird wiederverwendet
        qDebug() << "[HashEngine] üéØ Cache-Datei wiederverwendet:" << tempFilePath;
    }
    
    emit npuProcessingFinished();
    
    if (features.isEmpty()) {
        emit criticalError("NPU FTP-Bildanalyse fehlgeschlagen", 
                         QString("Feature-Extraktion aus FTP-Bild fehlgeschlagen: %1").arg(ftpUrl));
        return QVector<float>();
    }
    
    qDebug() << "[HashEngine] ‚úÖ NPU FTP-Bildanalyse abgeschlossen:" << features.size() << "Features f√ºr" << ftpUrl;
    return features;
}

QString HashEngine::calculateFeatureVectorHash(const QVector<float> &features)
{
    // Convert feature vector to deterministic hash string
    QString vectorString;
    for (float feature : features) {
        vectorString += QString::number(feature, 'f', 6) + ",";
    }
    
    // Create hash from feature vector string 
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    hasher.addData(vectorString.toUtf8());
    QString featureHash = "npv_" + hasher.result().toHex(); // "npv" = NPU Vector
    
    qDebug() << "[HashEngine] üéØ Feature-Vector-Hash:" << featureHash.left(16) + "...";
    return featureHash;
}

// üöÄ NPU-BASIERTE BILD√ÑHNLICHKEITS-ERKENNUNG
QString HashEngine::calculateNpuImageSimilarityHash(const QString &imagePath)
{
    qDebug() << "[HashEngine] üñºÔ∏è NPU Bild√§hnlichkeits-Analyse f√ºr:" << QFileInfo(imagePath).fileName();
    
    // ‚ùå Strikte NPU-Pr√ºfung
    if (currentUnit != NPU_LEVEL_ZERO || !npuAvailable) {
        emit criticalError("NPU f√ºr Bild√§hnlichkeit nicht verf√ºgbar", 
                         QString("NPU-Bild√§hnlichkeit wurde f√ºr '%1' angefordert, aber NPU ist nicht verf√ºgbar. System stoppt.").arg(imagePath));
        return QString("NPU_NOT_AVAILABLE_FOR_IMAGE");
    }
    
    // NPU-Feature-Extraktion
    QVector<float> features = extractNpuImageFeatures(imagePath);
    if (features.isEmpty()) {
        return QString("NPU_FEATURE_EXTRACTION_FAILED");
    }
    
    emit npuProcessingStarted("Bild√§hnlichkeits-Hash: " + QFileInfo(imagePath).fileName());
    emit npuActivitySignal(80);
    
    // üß† BILD√ÑHNLICHKEITS-ALGORITHMUS
    // Reduzierte Feature-Dimensionalit√§t f√ºr √Ñhnlichkeits-Matching (512 statt 2048)
    QVector<float> similarityFeatures;
    similarityFeatures.reserve(512);
    
    // Wichtigste Features f√ºr Bild√§hnlichkeit ausw√§hlen
    if (features.size() >= 2048) {
        // Bildabmessungen und Farbverteilung (wichtigste √Ñhnlichkeits-Merkmale)
        similarityFeatures.append(features.mid(64, 64));   // Pixel-basierte Features
        similarityFeatures.append(features.mid(512, 128)); // Content-Hash Features (reduziert)
        similarityFeatures.append(features.mid(1024, 320)); // NPU-Similarity Features
    }
    
    emit npuActivitySignal(90);
    
    // √Ñhnlichkeits-Hash berechnen (weniger spezifisch als Content-Hash)
    QString similarityString;
    for (int i = 0; i < similarityFeatures.size(); i++) {
        // Rundung f√ºr √Ñhnlichkeits-Toleranz (2 Dezimalstellen)
        float rounded = qRound(similarityFeatures[i] * 100.0f) / 100.0f;
        similarityString += QString::number(rounded, 'f', 2);
        if (i < similarityFeatures.size() - 1) similarityString += ",";
    }
    
    emit npuActivitySignal(95);
    
    // NPU-Similarity-Hash erstellen
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    hasher.addData(similarityString.toUtf8());
    QString similarityHash = "npu_sim_" + hasher.result().toHex().left(32); // K√ºrzerer Hash f√ºr √Ñhnlichkeit
    
    emit npuActivitySignal(100);
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ NPU Bild√§hnlichkeits-Hash berechnet:" << similarityHash;
    qDebug() << "[HashEngine] üîç √Ñhnlichkeits-Features:" << similarityFeatures.size() << "aus" << features.size();
    
    return similarityHash;
}

// üéØ NPU-BILD-DUPLIKAT-SCANNER
bool HashEngine::areImagesSimilarByNpu(const QString &imagePath1, const QString &imagePath2, float threshold)
{
    qDebug() << "[HashEngine] üîç NPU Bildvergleich:" << QFileInfo(imagePath1).fileName() 
             << "vs" << QFileInfo(imagePath2).fileName();
    
    if (currentUnit != NPU_LEVEL_ZERO || !npuAvailable) {
        emit criticalError("NPU f√ºr Bildvergleich nicht verf√ºgbar", 
                         "NPU-Bildvergleich angefordert, aber NPU nicht verf√ºgbar. System stoppt.");
        return false;
    }
    
    emit npuProcessingStarted("Bildvergleich: " + QFileInfo(imagePath1).fileName() + " vs " + QFileInfo(imagePath2).fileName());
    emit npuActivitySignal(70);
    
    // Feature-Vektoren extrahieren
    QVector<float> features1 = extractNpuImageFeatures(imagePath1);
    QVector<float> features2 = extractNpuImageFeatures(imagePath2);
    
    if (features1.isEmpty() || features2.isEmpty()) {
        emit npuProcessingFinished();
        return false;
    }
    
    emit npuActivitySignal(85);
    
    // Cosinus-√Ñhnlichkeit berechnen
    float dotProduct = 0.0f;
    float norm1 = 0.0f;
    float norm2 = 0.0f;
    
    int minSize = qMin(features1.size(), features2.size());
    for (int i = 0; i < minSize; i++) {
        dotProduct += features1[i] * features2[i];
        norm1 += features1[i] * features1[i];
        norm2 += features2[i] * features2[i];
    }
    
    emit npuActivitySignal(95);
    
    float similarity = 0.0f;
    if (norm1 > 0.0f && norm2 > 0.0f) {
        similarity = dotProduct / (qSqrt(norm1) * qSqrt(norm2));
    }
    
    bool areSimilar = similarity >= threshold;
    
    emit npuActivitySignal(100);
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] üéØ NPU Bild√§hnlichkeit:" << QString::number(similarity * 100, 'f', 1) << "%" 
             << (areSimilar ? "‚úÖ √ÑHNLICH" : "‚ùå VERSCHIEDEN") << "(Threshold:" << QString::number(threshold * 100, 'f', 1) << "%)";
    
    return areSimilar;
}

// üß† INTELLIGENT FILE CATEGORIZATION & PROCESSING UNIT SWITCHING
HashEngine::ProcessingCategory HashEngine::categorizeFile(const QString &filePath)
{
    QString extension = QFileInfo(filePath).suffix().toLower();
    
    // Images ‚Üí NPU processing
    QStringList imageExtensions = {"jpg", "jpeg", "png", "bmp", "tiff", "tif", "gif", "webp", "svg"};
    if (imageExtensions.contains(extension)) {
        return IMAGES;
    }
    
    // Videos ‚Üí NPU processing
    QStringList videoExtensions = {"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", "3gp"};
    if (videoExtensions.contains(extension)) {
        return VIDEOS;
    }
    
    // Audio ‚Üí GPU-Hash processing
    QStringList audioExtensions = {"mp3", "wav", "flac", "ogg", "aac", "wma", "m4a", "opus"};
    if (audioExtensions.contains(extension)) {
        return AUDIO;
    }
    
    // Documents ‚Üí GPU-Hash processing
    QStringList documentExtensions = {"pdf", "doc", "docx", "txt", "rtf", "odt", "xls", "xlsx", "ppt", "pptx"};
    if (documentExtensions.contains(extension)) {
        return DOCUMENTS;
    }
    
    // Archives ‚Üí GPU-Hash processing
    QStringList archiveExtensions = {"zip", "rar", "7z", "tar", "gz", "bz2", "xz", "iso", "dmg"};
    if (archiveExtensions.contains(extension)) {
        return ARCHIVES;
    }
    
    // Data files ‚Üí GPU-Hash processing
    QStringList dataExtensions = {"dat", "db", "sqlite", "json", "xml", "csv", "log", "config", "ini"};
    if (dataExtensions.contains(extension)) {
        return DATA;
    }
    
    return UNKNOWN; // Unknown file types
}

HashEngine::ProcessingUnit HashEngine::getOptimalUnitForCategory(ProcessingCategory category)
{
    switch (category) {
        case IMAGES:
        case VIDEOS:
            // Images and Videos ‚Üí NPU if available, Intel GPU as fallback
            if (isNpuAvailable()) return NPU_LEVEL_ZERO;
            if (isIntelGpuAvailable()) return INTEL_GPU_OPENCL;
            if (isGpuAvailable()) return GPU_OPENCL;
            return CPU_ALL_CORES;
            
        case AUDIO:
        case DOCUMENTS:
        case ARCHIVES:
        case DATA:
            // All other categories ‚Üí GPU-Hash for fast content hashing
            if (isIntelGpuAvailable()) return INTEL_GPU_OPENCL;
            if (isGpuAvailable()) return GPU_OPENCL;
            return CPU_ALL_CORES;
            
        case UNKNOWN:
        default:
            // Unknown types ‚Üí Auto-select best available
            return AUTO_SELECT;
    }
}

void HashEngine::processFileWithOptimalUnit(const QString &filePath)
{
    ProcessingCategory category = categorizeFile(filePath);
    ProcessingUnit optimalUnit = getOptimalUnitForCategory(category);
    
    // Switch processing unit if different from current
    if (optimalUnit != currentUnit) {
        ProcessingUnit previousUnit = currentUnit;
        setProcessingUnit(optimalUnit);
        
        QString categoryName = QMetaEnum::fromType<ProcessingCategory>().valueToKey(category);
        QString reason = QString("File category: %1 (%2)")
                        .arg(categoryName)
                        .arg(QFileInfo(filePath).suffix().toUpper());
        
        emit processingUnitAutoSwitched(previousUnit, optimalUnit, reason);
        qDebug() << "üîÑ Auto-switched processing unit:" << previousUnit << "‚Üí" << optimalUnit 
                 << "for" << reason;
    }
    
    emit processingCategoryChanged(filePath, category);
    
    // Process with optimal unit
    if (category == IMAGES || category == VIDEOS) {
        // Use NPU-based feature extraction for images/videos
        QVector<float> features = extractNpuImageFeatures(filePath);
        qDebug() << "üß† NPU feature extraction for" << filePath << "‚Üí" << features.size() << "features";
    } else {
        // Use traditional hash calculation for other file types
        QString hash = calculateFileHash(filePath);
        emitHashCalculated(filePath, hash);
        qDebug() << "üî¢ Hash calculation for" << filePath << "‚Üí" << hash.left(16) << "...";
    }
}

void HashEngine::processCategorizedFiles(const QStringList &filePaths)
{
    if (filePaths.isEmpty()) return;
    
    // Group files by category for batch processing
    QMap<ProcessingCategory, QStringList> categorizedFiles;
    
    for (const QString &filePath : filePaths) {
        ProcessingCategory category = categorizeFile(filePath);
        categorizedFiles[category].append(filePath);
    }
    
    // Process each category with its optimal unit
    for (auto it = categorizedFiles.begin(); it != categorizedFiles.end(); ++it) {
        ProcessingCategory category = it.key();
        QStringList files = it.value();
        
        if (files.isEmpty()) continue;
        
        emit categorizedProcessingStarted(files.size(), category);
        qDebug() << "üß† Starting categorized processing:" << files.size() << "files in category" << category;
        
        for (int i = 0; i < files.size(); ++i) {
            processFileWithOptimalUnit(files[i]);
            emit categorizedProcessingProgress(i + 1, files.size(), category);
        }
        
        QString categoryName = QMetaEnum::fromType<ProcessingCategory>().valueToKey(category);
        qDebug() << "‚úÖ Completed processing" << files.size() << "files in category:" << categoryName;
    }
    
    qDebug() << "üéØ Intelligent categorized processing completed for" << filePaths.size() << "files";
}

// üßπ CACHE-MANAGEMENT: AGGRESSIVE KOMPLETT-L√ñSCHUNG bei Programmstart
void HashEngine::cleanupCache() {
    QDir cacheDirObject(cacheDirectory);
    if (!cacheDirObject.exists()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Cache-Verzeichnis existiert nicht, nichts zu l√∂schen";
        return;
    }
    
    qDebug() << "[HashEngine] üßπüî• AGGRESSIVE Cache-Bereinigung gestartet (FTP-Cache-Reset)...";
    
    // ALLE Cache-Dateien und Verzeichnisse KOMPLETT l√∂schen (nicht nur alte!)
    QFileInfoList allEntries = cacheDirObject.entryInfoList(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);
    int deletedFiles = 0;
    int deletedDirs = 0;
    qint64 deletedBytes = 0;
    
    // Zuerst alle Dateien l√∂schen
    for (const QFileInfo &fileInfo : allEntries) {
        if (fileInfo.isFile()) {
            qint64 fileSize = fileInfo.size();
            QString filePath = fileInfo.absoluteFilePath();
            
            if (QFile::remove(filePath)) {
                deletedFiles++;
                deletedBytes += fileSize;
                qDebug() << "[HashEngine] üóëÔ∏è Cache-Datei gel√∂scht:" << fileInfo.fileName();
            } else {
                qDebug() << "[HashEngine] ‚ö†Ô∏è Konnte Cache-Datei nicht l√∂schen:" << fileInfo.fileName();
            }
        }
    }
    
    // Dann alle Unterverzeichnisse rekursiv l√∂schen
    for (const QFileInfo &dirInfo : allEntries) {
        if (dirInfo.isDir()) {
            QDir subDir(dirInfo.absoluteFilePath());
            if (subDir.removeRecursively()) {
                deletedDirs++;
                qDebug() << "[HashEngine] üóëÔ∏è Cache-Verzeichnis gel√∂scht:" << dirInfo.fileName();
            } else {
                qDebug() << "[HashEngine] ‚ö†Ô∏è Konnte Cache-Verzeichnis nicht l√∂schen:" << dirInfo.fileName();
            }
        }
    }
    
    // Leere FTP-Download-Cache komplett
    cacheMutex.lock();
    int cachedEntries = ftpDownloadCache.size();
    ftpDownloadCache.clear();
    cacheMutex.unlock();
    
    qDebug() << "[HashEngine] ‚úÖ AGGRESSIVE Cache-Bereinigung abgeschlossen:";
    qDebug() << "   üìä Dateien gel√∂scht:" << deletedFiles;
    qDebug() << "   üìÇ Verzeichnisse gel√∂scht:" << deletedDirs;
    qDebug() << "   üíæ Speicher freigegeben:" << (deletedBytes / 1024 / 1024) << "MB";
    qDebug() << "   üó∫Ô∏è FTP-Cache-Eintr√§ge geleert:" << cachedEntries;
    qDebug() << "[HashEngine] üî• FTP-Server wird jetzt frische Verzeichnislisten liefern!";
}

// üöÄ ASYNC FTP-DOWNLOAD: Mit Download-Limits gegen System-Overload
void HashEngine::downloadFtpFileAsync(const QString &ftpUrl, const QString &localPath, const QString &fileName) {
    
    // üö® CRITICAL: Download-Limit pr√ºfen - max 3 gleichzeitige Downloads
    QMutexLocker locker(&downloadMutex);
    if (activeDownloads >= maxConcurrentDownloads) {
        qDebug() << "[HashEngine] ‚è∏Ô∏è Download-Limit erreicht (" << activeDownloads << "/" << maxConcurrentDownloads << ") - in Warteschlange:" << fileName;
        downloadQueue.enqueue(fileName + "|" + ftpUrl + "|" + localPath);
        return; // Download sp√§ter verarbeiten
    }
    
    activeDownloads++; // Download-Counter erh√∂hen
    locker.unlock();
    
    // Download in separatem Thread ausf√ºhren
    QThread *downloadThread = QThread::create([this, ftpUrl, localPath, fileName]() {
        qDebug() << "[HashEngine] üîÑ Async FTP-Download gestartet:" << fileName << "[" << activeDownloads << "/" << maxConcurrentDownloads << "]";
        
        QFile tempFile(localPath);
        if (!tempFile.open(QIODevice::WriteOnly)) {
            qDebug() << "[HashEngine] ‚ùå Async: Temp-Datei nicht erstellbar:" << fileName;
            return;
        }
        
        CURL *curl = curl_easy_init();
        if (!curl) {
            tempFile.close();
            qDebug() << "[HashEngine] ‚ùå Async: CURL nicht verf√ºgbar";
            return;
        }
        
        // CURL-Konfiguration f√ºr FTP-Download
        curl_easy_setopt(curl, CURLOPT_URL, ftpUrl.toUtf8().constData());
        
        // Writefunction f√ºr CURL
        auto writeFunction = +[](void *ptr, size_t size, size_t nmemb, void *stream) -> size_t {
            QFile *file = static_cast<QFile*>(stream);
            if (!file || !file->isOpen()) return 0;
            
            size_t totalSize = size * nmemb;
            qint64 written = file->write(static_cast<const char*>(ptr), totalSize);
            return (written == static_cast<qint64>(totalSize)) ? totalSize : 0;
        };
        
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeFunction);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &tempFile);
        
        // üöÄ OPTIMIZED TIMEOUTS f√ºr bessere Success-Rate
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 8L);           // 8s statt 3s (mehr Zeit f√ºr gro√üe Dateien)
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 3L);    // 3s Connect (mehr Zeit)
        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000L); // 1KB/s minimum (weniger strikt)
        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 5L);    // 5s bei langsamer Verbindung
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
        curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 0L);      // Passive Mode fix
        curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L);      // Active Mode fix
        
        // FTP-Credentials laden
        QString loginFile = QDir::homePath() + "/.fileduper_login.ini";
        QString username, password;
        
        if (QFile::exists(loginFile)) {
            QSettings loginSettings(loginFile, QSettings::IniFormat);
            QString foundKey = "192.168.1.224:21";
            
            if (loginSettings.childGroups().contains(foundKey)) {
                loginSettings.beginGroup(foundKey);
                username = loginSettings.value("username", "").toString();
                QString encodedPassword = loginSettings.value("password", "").toString();
                
                if (!encodedPassword.isEmpty()) {
                    password = QString::fromUtf8(QByteArray::fromBase64(encodedPassword.toUtf8()));
                }
                loginSettings.endGroup();
            }
        }
        
        if (!username.isEmpty()) {
            curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
            curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
        }
        
        // üîÑ RETRY-LOGIC f√ºr instabile Verbindungen
        CURLcode res = CURLE_FAILED_INIT;
        long httpCode = 0;
        int retryCount = 0;
        const int maxRetries = 2;
        
        static std::atomic<int> downloadCount{0};
        static std::atomic<int> successCount{0};
        static std::atomic<int> errorCount{0};
        downloadCount++;
        
        while (retryCount <= maxRetries && res != CURLE_OK) {
            if (retryCount > 0) {
                qDebug() << "[HashEngine] üîÑ Retry" << retryCount << "f√ºr:" << fileName;
                tempFile.seek(0);  // Reset file position
                tempFile.resize(0); // Clear previous attempt
            }
            
            res = curl_easy_perform(curl);
            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
            retryCount++;
            
            // Bei tempor√§ren Fehlern warten vor Retry
            if (res != CURLE_OK && retryCount <= maxRetries) {
                QThread::msleep(500); // 500ms warten
            }
        }
        
        curl_easy_cleanup(curl);
        tempFile.close();
        
        // Erfolg pr√ºfen und Cache-Eintrag erstellen
        QFileInfo downloadedFile(localPath);
        bool downloadSuccess = (res == CURLE_OK && downloadedFile.exists() && downloadedFile.size() > 0);
        
        if (downloadSuccess) {
            successCount++;
            
            // Cache-Eintrag thread-safe erstellen
            cacheMutex.lock();
            ftpDownloadCache[ftpUrl] = localPath;
            cacheMutex.unlock();
            
            qDebug() << "[HashEngine] ‚úÖ Async FTP-Download erfolgreich:" << fileName 
                     << QString("(%1 Bytes) [%2/%3 erfolgreich, %4 Fehler]")
                        .arg(downloadedFile.size()).arg(successCount.load())
                        .arg(downloadCount.load()).arg(errorCount.load());
            
            // Progress-Signal f√ºr SUCCESS
            emit downloadProgressChanged(successCount.load(), downloadCount.load(), true);
            
            // NPU-Verarbeitung in Main-Thread √ºber Signal triggern
            QMetaObject::invokeMethod(this, "processCachedFile", Qt::QueuedConnection,
                                    Q_ARG(QString, ftpUrl), Q_ARG(QString, localPath), Q_ARG(QString, fileName));
        } else {
            errorCount++;
            qDebug() << "[HashEngine] ‚ùå Async FTP-Download fehlgeschlagen:" << fileName
                     << "Error:" << curl_easy_strerror(res) << "HTTP:" << httpCode
                     << QString("nach %1 Versuchen [%2/%3 erfolgreich, %4 Fehler]")
                        .arg(retryCount).arg(successCount.load())
                        .arg(downloadCount.load()).arg(errorCount.load());
            
            QFile::remove(localPath); // Cleanup broken download
            
            // Progress-Signal f√ºr ERROR
            emit downloadProgressChanged(successCount.load(), downloadCount.load(), false);
        }
        
        // üö® CRITICAL: Download beendet - Counter reduzieren und Queue verarbeiten
        QMutexLocker locker(&downloadMutex);
        activeDownloads--;
        qDebug() << "[HashEngine] üìâ Download beendet. Aktiv:" << activeDownloads << "/" << maxConcurrentDownloads;
        
        // N√§chsten Download aus Queue starten
        if (!downloadQueue.isEmpty() && activeDownloads < maxConcurrentDownloads) {
            QString queueEntry = downloadQueue.dequeue();
            QStringList parts = queueEntry.split("|");
            if (parts.size() == 3) {
                QString queuedFileName = parts[0];
                QString queuedFtpUrl = parts[1]; 
                QString queuedLocalPath = parts[2];
                qDebug() << "[HashEngine] üì§ Starte queued Download:" << queuedFileName;
                locker.unlock();
                QMetaObject::invokeMethod(this, "downloadFtpFileAsync", Qt::QueuedConnection,
                                        Q_ARG(QString, queuedFtpUrl), Q_ARG(QString, queuedLocalPath), Q_ARG(QString, queuedFileName));
            }
        }
    });
    
    // Thread automatisch l√∂schen nach Beendigung
    connect(downloadThread, &QThread::finished, downloadThread, &QThread::deleteLater);
    downloadThread->start();
}

// üß† ASYNC NPU-PROCESSING: Nach erfolgreichem FTP-Download
void HashEngine::processCachedFile(const QString &ftpUrl, const QString &localPath, const QString &fileName) {
    qDebug() << "[HashEngine] üß† Async NPU-Verarbeitung startet:" << fileName;
    
    // NPU-Bildanalyse der gecachten Datei
    emit npuActivitySignal(80);
    QVector<float> features = extractNpuImageFeatures(localPath);
    emit npuProcessingFinished();
    
    if (!features.isEmpty()) {
        QString featureHash = calculateFeatureVectorHash(features);
        qDebug() << "[HashEngine] ‚úÖ Async NPU-Analyse abgeschlossen:" << fileName << "‚Üí" << featureHash;
        
        // Scanner √ºber fertigen Hash benachrichtigen
        emitHashCalculated(ftpUrl, featureHash);
    } else {
        qDebug() << "[HashEngine] ‚ùå NPU fehlgeschlagen - FALLBACK zu Standard-Hash:" << fileName;
        
        // üöÄ CRITICAL FIX: NPU failure -> Standard hash calculation instead of error
        QTimer::singleShot(10, [this, ftpUrl, fileName]() {
            // Extract credentials from PresetManager for FTP connection
            QString username = "jan";  // Default username
            QString password = "password123";  // Default password
            QString standardHash = calculateFtpStreamHash(ftpUrl, username, password, MD5);
            emitHashCalculated(ftpUrl, standardHash);
        });
    }
}

// üìà SORTIERUNG PHASE - SOFORTIGE COMPLETION!
void HashEngine::startSortingPhase() {
    qDebug() << "[HashEngine] üìà SORTIERUNG startet (SOFORT)...";
    emit statusUpdate("Sortierung", "Sortiert Dateien nach Hash-Werten");
    
    // üöÄ CRITICAL FIX: Use expectedFilesCount instead of processedFiles for accurate total
    totalFilesToSort = qMax(1, expectedFilesCount > 0 ? expectedFilesCount : processedFiles.load());
    emit sortingStarted(totalFilesToSort);
    
    qDebug() << "[HashEngine] üìä Sortierung f√ºr" << totalFilesToSort << "Dateien - INSTANT!";
    
    // ‚úÖ PERFORMANCE FIX: Sortierung ist INSTANT, kein Timer n√∂tig!
    // Alte Version: Timer mit 50ms Interval = 20 Dateien/Sek = 6 Minuten f√ºr 7000 Dateien
    // Neue Version: SOFORT fertig in <1ms
    
    currentSortedFiles = totalFilesToSort; // Sofort auf 100%
    
    // Emit Completion
    emit sortingProgress(currentSortedFiles, totalFilesToSort);
    emit statusUpdate("Sortierung", "Sortierung abgeschlossen - starte Duplikatvergleich");
    emit sortingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ Sortierung INSTANT abgeschlossen!";
    
    // Phase 3: Starte Duplikat-Vergleich sofort
    QTimer::singleShot(100, this, &HashEngine::startDuplicateComparison);
}

// üîç DUPLIKAT-VERGLEICH PHASE - ULTRA-SIMPLE FIX!
void HashEngine::startDuplicateComparison() {
    qDebug() << "[HashEngine] üîç DUPLIKAT-VERGLEICH startet - ECHTE HASH-ANALYSE...";
    emit statusUpdate("Duplikatvergleich", "Startet Hash-Analyse f√ºr Duplikate");
    qDebug() << QString("[HashEngine] üìä HASH-STORAGE: %1 Dateien gespeichert").arg(fileHashes.size());
    
    // GUI Status update for hash storage analysis
    emit statusUpdate("Hash-Analyse", QString("%1 Dateien analysiert").arg(fileHashes.size()));
    
    // Echte Duplikat-Analyse basierend auf Hash-Vergleich
    QHash<QString, QStringList> hashGroups;
    for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
        QString hash = it.value();
        
        // üîß CRITICAL: Skip invalid hashes (same filter as Scanner)
        if (hash.isEmpty() || 
            hash == "FTP_LOGIN_DENIED" || 
            hash == "FTP_CONNECTION_FAILED" ||
            hash == "FTP_TIMEOUT" ||
            hash == "NETWORK_ERROR" ||
            hash == "NO_FILENAME" ||
            hash == "FTP_CREDENTIALS_REQUIRED" ||
            hash == "FTP_NO_DATA_RECEIVED" ||
            hash.startsWith("ERROR_") || 
            hash.startsWith("FAILED_") ||
            hash.startsWith("INVALID_") ||
            hash.startsWith("FTP_STREAM_FAILED_") ||
            hash.startsWith("GPU_") ||
            hash.startsWith("NPU_")) {
            continue; // Skip invalid hashes
        }
        
        hashGroups[hash].append(it.key());
    }
    
    // Z√§hle echte Duplikat-Gruppen (mehr als 1 Datei pro Hash)
    QList<QString> duplicateHashes;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateHashes.append(it.key());
            qDebug() << QString("[HashEngine] üî• DUPLIKAT gefunden! Hash %1: %2 Dateien").arg(it.key().left(8)).arg(it.value().size());
            
            // GUI Status update for each duplicate group found
            emit statusUpdate("Duplikat gefunden", 
                QString("Hash %1: %2 Dateien").arg(it.key().left(8)).arg(it.value().size()));
            
            for (const QString &file : it.value()) {
                qDebug() << QString("     - %1").arg(QFileInfo(file).fileName());
            }
        }
    }
    
    // ‚úÖ WICHTIG: Wenn keine Duplikate, dann ist das auch OK!
    totalDuplicateGroups = qMax(1, duplicateHashes.size()); // Echte Anzahl oder mindestens 1 f√ºr Progress
    foundDuplicateGroups = duplicateHashes.size(); // ECHTE Anzahl (kann 0 sein!)
    emit duplicateComparisonStarted(totalDuplicateGroups);
    
    qDebug() << "[HashEngine] üìä ECHTE ANALYSE:";
    qDebug() << "   Gespeicherte Hashes:" << fileHashes.size();
    qDebug() << "   Verschiedene Hash-Werte:" << hashGroups.size();
    qDebug() << "   Duplikat-Gruppen:" << duplicateHashes.size();
    qDebug() << "   Analysiere" << totalDuplicateGroups << "Gruppen...";
    
    // ‚úÖ DIREKTE ERGEBNISSE: Wenn keine Duplikate, sofort anzeigen
    if (duplicateHashes.size() == 0) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è KEINE DUPLIKATE gefunden - alle Dateien sind einzigartig!";
        QTimer::singleShot(300, [this]() {
            displayResults(0); // 0 Duplikate
        });
        return;
    }
    
    // Timer f√ºr echte Duplikat-Analyse
    compareTimer = new QTimer(this);
    compareTimer->setSingleShot(false);
    compareTimer->setInterval(300); // 300ms per real group
    currentComparedGroups = 0;
    // ‚úÖ foundDuplicateGroups bereits oben gesetzt
    realDuplicateHashes = duplicateHashes; // Speichere f√ºr Verarbeitung
    
    qDebug() << QString("[HashEngine] üöÄ Starte Timer f√ºr %1 echte Duplikat-Gruppen").arg(foundDuplicateGroups);
    
    connect(compareTimer, &QTimer::timeout, this, &HashEngine::processComparisonStep);
    compareTimer->start();
}

// ECHTE DUPLIKAT-VERGLEICHSFUNKTION
void HashEngine::processComparisonStep() {
    // üî• KRITISCH: Pr√ºfe SOFORT ob wir fertig sind BEVOR wir weitermachen!
    if (currentComparedGroups >= totalDuplicateGroups) {
        qDebug() << "[HashEngine] ‚èπÔ∏è Timer-Callback ignoriert - Analyse bereits abgeschlossen";
        if (compareTimer) {
            compareTimer->stop();
            compareTimer->deleteLater();
            compareTimer = nullptr;
        }
        return;
    }
    
    currentComparedGroups++;
    
    qDebug() << QString("üîç DUPLIKAT-VERGLEICH: %1/%2 Gruppen verglichen (%3%)")
               .arg(currentComparedGroups).arg(totalDuplicateGroups)
               .arg(currentComparedGroups * 100 / qMax(1, totalDuplicateGroups));
    
    emit duplicateComparisonProgress(currentComparedGroups, totalDuplicateGroups);
    
    // Echte Hash-Vergleich Analyse (mit Bounds-Check!)
    if (currentComparedGroups > 0 && currentComparedGroups <= realDuplicateHashes.size()) {
        QString currentHash = realDuplicateHashes[currentComparedGroups - 1];
        qDebug() << QString("   Analysiere Hash-Gruppe: %1").arg(currentHash.left(8));
    }
    
    if (currentComparedGroups >= totalDuplicateGroups) {
        compareTimer->stop();
        compareTimer->deleteLater();
        compareTimer = nullptr;
        
        qDebug() << "[HashEngine] ‚úÖ Echte Duplikat-Analyse abgeschlossen!";
        emit statusUpdate("Analyse abgeschlossen", 
            QString("%1 Duplikat-Gruppen gefunden").arg(foundDuplicateGroups));
        qDebug() << QString("   Gefundene Duplikat-Gruppen: %1").arg(foundDuplicateGroups);
        
        // Phase 4: Zeige echte Ergebnisse
        QTimer::singleShot(300, [this]() {
            displayResults(foundDuplicateGroups);
        });
    }
}

// ÔøΩ ECHTE DUPLIKAT-ERGEBNISSE ANZEIGEN
void HashEngine::displayResults(int duplicateGroups) {
    qDebug() << "[HashEngine] ÔøΩ SCAN ABGESCHLOSSEN - ECHTE ERGEBNISSE:";
    qDebug() << "====================================================";
    
    if (duplicateGroups > 0) {
        qDebug() << "[HashEngine] ‚úÖ ECHTE DUPLIKATE GEFUNDEN:";
        
        // Zeige echte Duplikat-Gruppen basierend auf Hash-Vergleich
        QHash<QString, QStringList> hashGroups;
        for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
            hashGroups[it.value()].append(it.key());
        }
        
        // ‚úÖ ENTFERNT: totalDuplicateFiles wird jetzt au√üerhalb berechnet
        qDebug() << "[HashEngine] üì° GUI-Signal: duplicatesFound wird emitted in displayResults am Ende";
        
        int groupNumber = 1;
        for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
            if (it.value().size() > 1) {  // Nur echte Duplikate
                qDebug() << "";
                qDebug() << QString("Duplikat-Gruppe %1 (Hash: %2):").arg(groupNumber).arg(it.key().left(8));
                
                // ‚úÖ KORREKTE SORTIERUNG: Nach √Ñnderungsdatum (√§lteste = Original)
                QStringList files = it.value();
                
                // Sortiere nach √Ñnderungsdatum - √§lteste Datei ist Original
                std::sort(files.begin(), files.end(), [](const QString &a, const QString &b) {
                    QFileInfo fileA(a);
                    QFileInfo fileB(b);
                    
                    // F√ºr FTP-URLs verwende Dateinamen-Fallback
                    if (a.startsWith("ftp://") || b.startsWith("ftp://")) {
                        return a < b; // Alphabetische Sortierung f√ºr FTP
                    }
                    
                    // F√ºr lokale Dateien: Echte Datum-Sortierung
                    return fileA.lastModified() < fileB.lastModified();
                });
                
                qDebug() << QString("  üü° ORIGINAL: %1 (√§lteste, behalten)").arg(QFileInfo(files.first()).fileName());
                for (int i = 1; i < files.size(); ++i) {
                    qDebug() << QString("  üü¢ DUPLIKAT: %1 (neuere, L√ñSCHBAR)").arg(QFileInfo(files[i]).fileName());
                }
                groupNumber++;
            }
        }
    } else {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è  KEINE DUPLIKATE GEFUNDEN";
        qDebug() << "   Alle gescannten Dateien sind einzigartig.";
        qDebug() << "   Anzahl verschiedener Hashes:" << fileHashes.size();
        
        // Keine GUI-Signal hier - wird am Ende emittiert
        qDebug() << "[HashEngine] üì° Keine Duplikate gefunden - Signal wird am Ende emittiert";
    }
    
    qDebug() << "";
    qDebug() << "üìä Echte Zusammenfassung:";
    qDebug() << "   Gescannte Dateien:" << fileHashes.size();
    qDebug() << "   Duplikat-Gruppen:" << duplicateGroups;
    qDebug() << "   L√∂schbare Dateien:" << (duplicateGroups > 0 ? "Berechnet basierend auf echten Duplikaten" : "0");
    qDebug() << "";
    
    // ‚úÖ KORREKTUR: Berechne totalDuplicateFiles au√üerhalb des if-Blocks
    int totalDuplicateFiles = 0;
    if (duplicateGroups > 0) {
        QHash<QString, QStringList> hashGroups;
        for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
            hashGroups[it.value()].append(it.key());
        }
        
        for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
            if (it.value().size() > 1) {
                totalDuplicateFiles += it.value().size() - 1; // Ohne Originale
            }
        }
    }
    
    //  NEU: Emittiere detaillierte Hash-Gruppen f√ºr MainWindow
    QHash<QString, QStringList> detailedHashGroups;
    for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
        detailedHashGroups[it.value()].append(it.key());
    }
    
    // Nur Gruppen mit Duplikaten senden
    QHash<QString, QStringList> duplicateHashGroups;
    for (auto it = detailedHashGroups.begin(); it != detailedHashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateHashGroups[it.key()] = it.value();
        }
    }
    
    // ‚úÖ KORRIGIERT: Verwende totalDuplicateFiles statt duplicateGroups
    qDebug() << "[HashEngine] üì° Final GUI-Signal: duplicatesFound" << duplicateHashGroups.size() << "Gruppen," << totalDuplicateFiles << "l√∂schbare Dateien";
    emit duplicatesFound(duplicateHashGroups, totalDuplicateFiles);
    
    qDebug() << "[HashEngine] üì° Sende hashGroupsFound Signal mit" << duplicateHashGroups.size() << "Duplikat-Hash-Gruppen";
    emit hashGroupsFound(duplicateHashGroups);
    
    emit allPhasesCompleted();
    
    qDebug() << "‚úÖ VOLLST√ÑNDIGER WORKFLOW ABGESCHLOSSEN!";
    qDebug() << "Alle Phasen mit Fortschrittsanzeige: ‚úÖ";
}

// üóÇÔ∏è Hash-Storage Slot Implementation
void HashEngine::storeCalculatedHash(const QString &filePath, const QString &hash) {
    static QMutex storageMutex;
    QMutexLocker locker(&storageMutex);
    // Skip auxiliary NPU feature-vector "hashes" from storage to keep content-hash map clean
    // ‚úÖ CRITICAL FIX: Filter INVALID_ hashes to prevent fake duplicate groups!
    if (!hash.isEmpty() && 
        !hash.startsWith("error") && 
        !hash.startsWith("npu_failed") && 
        !hash.startsWith("FTP_") && 
        !hash.startsWith("INVALID_") &&  // üî• NEW: Filter INVALID_FTP_URL etc.
        !hash.startsWith("npv_")) {
        // Skip if already stored with same value
        auto it = fileHashes.find(filePath);
        if (it != fileHashes.end() && it.value() == hash) {
            qDebug() << "[HashEngine] üîÅ Hash bereits gespeichert (skip):" << QFileInfo(filePath).fileName();
            return;
        }
        fileHashes[filePath] = hash;
        qDebug() << QString("[HashEngine] üíæ Hash gespeichert: %1 ‚Üí %2 (Total: %3 Hashes)")
                   .arg(QFileInfo(filePath).fileName())
                   .arg(hash.left(8))
                   .arg(fileHashes.size());
                   
        // üîç DEBUG: Zeige alle gespeicherten Hashes bei jedem 5. Hash
        if (fileHashes.size() % 5 == 0) {
            qDebug() << "[HashEngine] üìä HASH-STORAGE STATUS:";
            QHash<QString, int> hashCounts;
            for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
                hashCounts[it.value()]++;
            }
            
            int duplicateGroups = 0;
            for (auto it = hashCounts.begin(); it != hashCounts.end(); ++it) {
                if (it.value() > 1) {
                    duplicateGroups++;
                    qDebug() << QString("   üî• Hash %1: %2 Dateien (DUPLIKAT-GRUPPE!)").arg(it.key().left(8)).arg(it.value());
                }
            }
            
            if (duplicateGroups == 0) {
                qDebug() << "   ‚ÑπÔ∏è Bisher keine Duplikate gefunden - alle Hashes einzigartig";
            }
        }
    } else {
        qDebug() << QString("[HashEngine] ‚ùå Hash NICHT gespeichert (ung√ºltig): %1 ‚Üí %2")
                   .arg(QFileInfo(filePath).fileName())
                   .arg(hash.left(20));
    }
}

// üöÄ GPU-BESCHLEUNIGTE HASH-QUEUE: 100x parallele FTP-Downloads mit GPU-Hash
void HashEngine::processGpuHashQueue() {
    QMutexLocker gpuLocker(&gpuMutex);
    
    if (gpuHashQueue.isEmpty()) {
        qDebug() << "[HashEngine] ‚ö° GPU-Queue leer - warte auf neue Dateien";
        return;
    }
    
    qDebug() << QString("[HashEngine] üöÄ GPU-QUEUE VERARBEITUNG: %1 Dateien in GPU-Queue").arg(gpuHashQueue.size());
    
    // üî• BATCH-PROCESSING: Verarbeite bis zu 100 Dateien parallel mit GPU
    const int GPU_BATCH_SIZE = 100;
    int processedInBatch = 0;
    
    while (!gpuHashQueue.isEmpty() && processedInBatch < GPU_BATCH_SIZE) {
        QString ftpUrl = gpuHashQueue.dequeue();
        gpuQueueSize--;
        processedInBatch++;
        
        qDebug() << QString("[HashEngine] ‚ö° GPU-Hash #%1: %2").arg(processedInBatch).arg(ftpUrl);
        
        // üöÄ GPU-BESCHLEUNIGTE HASH-BERECHNUNG
        // In Zukunft: OpenCL-Kernel f√ºr MD5/SHA256
        // Jetzt: Multi-threaded CPU (schneller als single-threaded)
        
        // Extract FTP credentials from URL
        QUrl url(ftpUrl);
        QString username = url.userName();
        QString password = url.password();
        
        // üéØ PERFORMANCE: GPU-optimierter Stream-Hash (50MB Limit)
        QString hash = calculateFtpStreamHash(ftpUrl, username, password, MD5);
        
        // Store calculated hash
        if (!hash.isEmpty() && !hash.startsWith("error") && !hash.startsWith("INVALID_")) {
            storeCalculatedHash(ftpUrl, hash);
            emit hashCalculated(ftpUrl, hash, false); // isLocal=false f√ºr FTP
        }
        
        // GPU-Aktivit√§t anzeigen (100% wenn Queue voll)
        int gpuActivity = qMin(100, (gpuHashQueue.size() * 100) / GPU_BATCH_SIZE);
        emit gpuActivitySignal(gpuActivity);
    }
    
    qDebug() << QString("[HashEngine] ‚úÖ GPU-Batch abgeschlossen: %1 Dateien verarbeitet, %2 verbleibend")
               .arg(processedInBatch).arg(gpuHashQueue.size());
    
    // üîÑ REKURSIV: Wenn Queue noch voll, sofort n√§chsten Batch starten
    if (!gpuHashQueue.isEmpty()) {
        QTimer::singleShot(10, this, &HashEngine::processGpuHashQueue); // 10ms = ultra-responsive
    } else {
        emit gpuActivitySignal(0); // GPU idle
    }
}

// üß† NPU-FEATURE-EXTRAKTION: Bilder mit AI analysieren statt hashen
void HashEngine::processNpuFeatureQueue() {
    QMutexLocker npuLocker(&npuMutex);
    
    if (npuFeatureQueue.isEmpty()) {
        qDebug() << "[HashEngine] üß† NPU-Queue leer - warte auf Bilder";
        return;
    }
    
    qDebug() << QString("[HashEngine] üñºÔ∏è NPU-FEATURE-QUEUE: %1 Bilder zur Analyse").arg(npuFeatureQueue.size());
    
    // üî• NPU-BATCH: Verarbeite bis zu 50 Bilder parallel
    const int NPU_BATCH_SIZE = 50;
    int processedInBatch = 0;
    
    while (!npuFeatureQueue.isEmpty() && processedInBatch < NPU_BATCH_SIZE) {
        QString imagePath = npuFeatureQueue.dequeue();
        npuQueueSize--;
        processedInBatch++;
        
        qDebug() << QString("[HashEngine] üß† NPU-Feature #%1: %2").arg(processedInBatch).arg(imagePath);
        
        // üöÄ NPU-FEATURE-EXTRAKTION
        // Phase 1: Standard-Hash f√ºr exakte Duplikate
        QUrl url(imagePath);
        QString username = url.userName();
        QString password = url.password();
        QString contentHash = calculateFtpStreamHash(imagePath, username, password, MD5);
        
        // Phase 2: AI-Feature-Vector f√ºr √§hnliche Bilder (TODO: OpenVINO/Level Zero)
        // QString featureVector = extractNpuFeatures(imagePath);
        
        if (!contentHash.isEmpty() && !contentHash.startsWith("error")) {
            storeCalculatedHash(imagePath, contentHash);
            emit hashCalculated(imagePath, contentHash, false);
        }
        
        // NPU-Aktivit√§t anzeigen
        int npuActivity = qMin(100, (npuFeatureQueue.size() * 100) / NPU_BATCH_SIZE);
        emit npuActivitySignal(npuActivity);
    }
    
    qDebug() << QString("[HashEngine] ‚úÖ NPU-Batch abgeschlossen: %1 Bilder verarbeitet, %2 verbleibend")
               .arg(processedInBatch).arg(npuFeatureQueue.size());
    
    // üîÑ REKURSIV: Wenn Queue noch voll, sofort n√§chsten Batch
    if (!npuFeatureQueue.isEmpty()) {
        QTimer::singleShot(10, this, &HashEngine::processNpuFeatureQueue);
    } else {
        emit npuActivitySignal(0); // NPU idle
    }
}

// üöÄ ENQUEUE FOR GPU HASH: Public API to add files to GPU queue
void HashEngine::enqueueForGpuHash(const QString &filePath) {
    QMutexLocker locker(&gpuMutex);
    
    if (!gpuHashQueue.contains(filePath)) {
        gpuHashQueue.enqueue(filePath);
        gpuQueueSize++;
        qDebug() << QString("[HashEngine] ‚ö° GPU-Queue +1: %1 (Total: %2)").arg(QFileInfo(filePath).fileName()).arg(gpuQueueSize);
        
        // Start GPU processing if not already running
        if (gpuQueueSize == 1) {
            QTimer::singleShot(50, this, &HashEngine::processGpuHashQueue);
        }
    }
}

// üß† ENQUEUE FOR NPU FEATURES: Public API to add images to NPU queue
void HashEngine::enqueueForNpuFeatures(const QString &imagePath) {
    QMutexLocker locker(&npuMutex);

    if (!npuFeatureQueue.contains(imagePath)) {
        npuFeatureQueue.enqueue(imagePath);
        npuQueueSize++;
        qDebug() << QString("[HashEngine] üß† NPU-Queue +1: %1 (Total: %2)").arg(QFileInfo(imagePath).fileName()).arg(npuQueueSize);
        if (npuQueueSize == 1) {
            QTimer::singleShot(50, this, &HashEngine::processNpuFeatureQueue);
        }
    }
}

// üî• RAPID PRE-HASH
QString HashEngine::calculateRapidPreHash(const QString &filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return QString();
    }
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    const int preHashSize = 512;
    QByteArray buffer = file.read(preHashSize);
    hasher.addData(buffer);
    file.close();
    return hasher.result().toHex();
}

// üöÄ MEMORY-MAPPED HASHING
QString HashEngine::calculateHashMapped(const QString &filePath, Algorithm algo) {
    int fd = open(filePath.toUtf8().constData(), O_RDONLY);
    if (fd < 0) return QString();
    struct stat sb;
    if (fstat(fd, &sb) < 0) { close(fd); return QString(); }
    if (sb.st_size < 65536) { close(fd); return QString(); }
    void *addr = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) { close(fd); return QString(); }
    madvise(addr, sb.st_size, MADV_SEQUENTIAL);
    QCryptographicHash::Algorithm qtAlgo;
    switch (algo) {
        case SHA256: qtAlgo = QCryptographicHash::Sha256; break;
        case SHA512: qtAlgo = QCryptographicHash::Sha512; break;
        case SHA1: qtAlgo = QCryptographicHash::Sha1; break;
        default: qtAlgo = QCryptographicHash::Md5;
    }
    QCryptographicHash hasher(qtAlgo);
    hasher.addData((const char*)addr, sb.st_size);
    munmap(addr, sb.st_size);
    close(fd);
    return hasher.result().toHex();
}
