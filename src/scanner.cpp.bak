#include "scanner.h"
#include "hashengine.h"
#include "presetmanager.h"
#include "ftpclient.h"
#include "sftpclient.h"          // ‚úÖ SFTP Client Include
#include "smbclient.h"           // ‚úÖ SMB Client Include
#include "nfsclient.h"           // ‚úÖ NFS Client Include
#include "hardwarebenchmark.h"   // ‚ö° Hardware Auto-Detect & Optimization
#include <QApplication>
#include <QDebug>
#include <QDir>
#include <QDirIterator>
#include <QDateTime>
#include <QCryptographicHash>
#include <QFileInfo>
#include <QUrl>
#include <QFile>
#include <QStandardPaths>
#include <iostream>

Scanner::Scanner(QObject *parent)
    : QObject(parent), hashEngine(nullptr), presetManager(nullptr), ftpClient(nullptr), 
      sftpClient(nullptr), smbClient(nullptr), nfsClient(nullptr), npuManager(nullptr),
      scanning(false), paused(false), currentPhase(IDLE), ftpDirectoriesProcessed(0),
      currentSimilarityMode(NpuManager::NEAR_DUPLICATES)  // Default: Sehr √§hnliche Bilder
{
    std::cout << "[Scanner] Scanner initialisiert" << std::endl;
    
    // THREADPOOL: Intelligente Thread-Anzahl f√ºr lokale + FTP-Scans
    // Lokal: 1000 Threads f√ºr SSD/NVMe Performance
    // FTP: Begrenzt durch maxParallelFtpScans (35 default, 500 discovery)
    QThreadPool::globalInstance()->setMaxThreadCount(1000);
    QThreadPool::globalInstance()->setExpiryTimeout(-1);  // Threads bleiben IMMER aktiv!
    
    // üöÄ EMERGENCY SPEED BOOST: Chunk-basierte Pipeline mit 200 Files pro Chunk
    chunkSize = 200;  // Verarbeite 200 Dateien parallel (4x schneller!)
    qDebug() << "[Scanner] üöÄ TURBO MODE: 1000 Threads f√ºr lokale Scans, FTP-Limit dynamisch";
    qDebug() << "[Scanner] QThreadPool konfiguriert: 1000 parallele Worker (MAXIMUM SPEED!)";
    
    // CHEF-APPROVED: MAXIMUM PERFORMANCE CONFIGURATION
    HardwareBenchmark *benchmark = new HardwareBenchmark(this);
    connect(benchmark, &HardwareBenchmark::benchmarkProgress, this, 
            [](const QString &msg, int progress) {
        qDebug() << "[Scanner] üîß" << progress << "%" << msg;
    });
    
    // ‚ö†Ô∏è NOTE: Hardware benchmark wird im Hintergrund asynchron ausgef√ºhrt
    // Der Main Thread wird nicht blockiert, damit GUI responsive bleibt
    QTimer::singleShot(0, this, [this, benchmark]() {
        hardwareCaps = benchmark->detectAndBenchmark();
        
        // üöÄ EMIT Hardware Status nach Detection mit ECHTEN CPUID-Werten
        bool hasSHANI = hardwareCaps.hasSHANI;
        bool hasSHA512NI = hardwareCaps.hasSHA512NI;
        bool hasAVX2 = hardwareCaps.hasAVX2;
        bool hasAVX512 = hardwareCaps.hasAVX512;
        
        emit hardwareStatusUpdate(hasSHANI, hasSHA512NI, hasAVX2, hasAVX512);
        qDebug() << "[Scanner] üöÄ Hardware-Status emittiert: SHA-NI=" << hasSHANI 
                 << "SHA512-NI=" << hasSHA512NI << "AVX2=" << hasAVX2 << "AVX512=" << hasAVX512;
    });
    
    // Setze Default-Werte sofort (werden sp√§ter √ºberschrieben)
    hardwareCaps.maxParallelFtpScans = 35;
    maxParallelFtpScans = 35;
    
    // üöÄ OPTIMIERUNG 2 & 3: Aktiviere Smart Features basierend auf Hardware
    if (hardwareCaps.hasNPU) {
        useNpuForHashing = true;
        qDebug() << "   üß† NPU-Hash-Beschleunigung: AKTIVIERT";
    }
    if (hardwareCaps.hasGPU) {
        useGpuForHashing = true;
        qDebug() << "   üéÆ GPU-Hash-Beschleunigung: AKTIVIERT";
    }
    if (hardwareCaps.ioScore > 80) {
        minFileSizeForHashing = 512;  // Super-SSD: Auch kleinere Dateien hashen
        qDebug() << "   ‚ö° Smart Pre-Filter: 512 Bytes (SSD-optimiert)";
    } else {
        minFileSizeForHashing = 2048;  // Normale HDD: Nur gr√∂√üere Dateien
        qDebug() << "   ‚ö° Smart Pre-Filter: 2048 Bytes (HDD-optimiert)";
    }
    
    qDebug() << "[Scanner] ‚ö° Optimiert f√ºr Hardware:";
    qDebug() << "   üî¢ CPU-Kerne:" << hardwareCaps.cpuCores;
    qDebug() << "   üíæ RAM:" << hardwareCaps.availableRamMB << "MB";
    qDebug() << "   üß† NPU:" << (hardwareCaps.hasNPU ? "Verf√ºgbar ‚úÖ" : "Nicht verf√ºgbar ‚ùå");
    qDebug() << "   üéÆ GPU:" << (hardwareCaps.hasGPU ? hardwareCaps.gpuName + " ‚úÖ" : "Nicht verf√ºgbar ‚ùå");
    qDebug() << "   üì° Parallele FTP-Scans:" << maxParallelFtpScans;
    qDebug() << "   üîê Paralleles Hashing:" << hardwareCaps.maxParallelHashing;
    qDebug() << "   üí™ CPU Score:" << hardwareCaps.cpuScore << "/100";
    qDebug() << "   üíø I/O Score:" << hardwareCaps.ioScore << "/100";
    qDebug() << "   üì∂ Network Score:" << hardwareCaps.networkScore << "/100";

    // üîê SCAN-HISTORY: Lade persistente History beim Start
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
    scanHistoryFile = configPath + "/.fileduper_scan_history.dat";
    loadScanHistory();
    qDebug() << "[Scanner] üìú Scan-History geladen:" << scannedDirectoriesHistory.size() << "Verzeichnisse," 
             << scannedFilesHistory.size() << "Dateien";

    // Ultra-responsive Timer f√ºr GUI
    processTimer = new QTimer(this);
    processTimer->setSingleShot(false);
    processTimer->setInterval(10); // üöÄ 10ms = 100 FPS f√ºr schnellere FTP-Verarbeitung
    connect(processTimer, &QTimer::timeout, this, &Scanner::processNextFile);

    // ‚úÖ Asynchroner Timer f√ºr Dateisammlung - verhindert GUI-Blockierung
    fileCollectionTimer = new QTimer(this);
    fileCollectionTimer->setSingleShot(false);
    fileCollectionTimer->setInterval(25); // üöÄ 25ms = 40 FPS f√ºr ultra-responsive Dateisammlung
    connect(fileCollectionTimer, &QTimer::timeout, this, &Scanner::processNextDirectoryChunk);

    // üöÄ FTP Queue Drain Timer: Periodically check FTP queue and start new scans
    ftpQueueDrainTimer = new QTimer(this);
    ftpQueueDrainTimer->setSingleShot(false);
    ftpQueueDrainTimer->setInterval(50); // üöÄ 50ms = schnellere Queue-Verarbeitung (war 200ms)
    connect(ftpQueueDrainTimer, &QTimer::timeout, this, [this]() {
        // Check all hosts with queued directories
        for (auto it = ftpQueuePerHost.begin(); it != ftpQueuePerHost.end(); ++it) {
            QString host = it.key();
            if (it.value().isEmpty()) continue;
            
            int currentActive = activeFtpScansPerHost.value(host, 0);
            int queueSize = it.value().size();
            
            // ÔøΩüöÄ DISCOVERY-MODUS: SEHR HOHE PARALLELIT√ÑT (500 statt 50)
            int adaptiveLimit = maxParallelFtpScans;
            if (ftpDiscoveryPhase) {
                adaptiveLimit = 50;  // Discovery kann 500 parallel
            } else if (queueSize > 2000) {
                adaptiveLimit = maxParallelFtpScans * 5 / 4;  // 125%
            } else if (queueSize > 1000) {
                adaptiveLimit = maxParallelFtpScans * 9 / 8;  // 112.5%
            }
            adaptiveLimit = qMin(adaptiveLimit, ftpDiscoveryPhase ? 500 : 75);
            
            // ÔøΩüîç DEBUG: Log IMMER wenn Queue nicht leer (alle 50 Checks = 10 Sekunden)
            static int timerCheckCount = 0;
            timerCheckCount++;
            if (queueSize > 0 && timerCheckCount % 50 == 0) {
                qDebug() << "[FTP-Timer] üìä Check #" << timerCheckCount << "| Queue:" << queueSize 
                         << "| Active:" << currentActive << "/" << adaptiveLimit 
                         << (ftpDiscoveryPhase ? " (DISCOVERY-500)" : " (SCAN-75)");
            }
            
            // Start new scans if below limit
            if (currentActive < adaptiveLimit && queueSize > 0) {
                int availableSlots = adaptiveLimit - currentActive;
                int maxBatch = (queueSize > 2000) ? 30 : (queueSize > 1000) ? 20 : 15;
                int batchSize = qMin(availableSlots, qMin(queueSize, maxBatch));
                
                qDebug() << "[FTP-Timer] üîÑ Queue-Drain f√ºr" << host << ":" << batchSize << "neue Scans | Queue:" << queueSize << "| Active:" << currentActive << "/" << adaptiveLimit;
                
                for (int i = 0; i < batchSize && !ftpQueuePerHost[host].isEmpty(); ++i) {
                    QString nextDir = ftpQueuePerHost[host].takeFirst();
                    collectFtpFiles(nextDir, this->processedFiles, true);
                }
            }
        }
    });

    // Initialisiere Pfad-Deduplicator f√ºr optimierte Verarbeitung
}

Scanner::~Scanner()
{
    stopScan();
}

void Scanner::setHashEngine(HashEngine *engine)
{
    hashEngine = engine;
    if (hashEngine)
    {
        connect(hashEngine, &HashEngine::hashCalculated,
                this, &Scanner::onHashCalculated);
    }
}

void Scanner::setPresetManager(PresetManager *manager)
{
    presetManager = manager;
}

void Scanner::setFtpClient(FtpClient *client)
{
    // Disconnect previous client safely to avoid duplicate signal deliveries
    if (ftpClient) {
        QObject::disconnect(ftpClient, nullptr, this, nullptr);
    }
    ftpClient = client;
    // Note: We intentionally do NOT connect filesListFinished here.
    // Per-host clients created in collectFtpFiles() are connected with a
    // scoped lambda using Qt::UniqueConnection to avoid double-processing
    // and race conditions when multiple FTP directories are scanned.
}

// üß† NPU-INTEGRATION: NPU-Manager f√ºr intelligente Bildverarbeitung
void Scanner::setNpuManager(NpuManager *manager)
{
    npuManager = manager;
    if (npuManager)
    {
        connect(npuManager, &NpuManager::imageBatchProcessed,
                this, &Scanner::onNpuImageBatchProcessed);
        qDebug() << "[Scanner] üß† NPU-Manager f√ºr Bildverarbeitung verbunden";
    }
}

void Scanner::setNpuEnabled(bool enabled)
{
    npuEnabled = enabled;
    qDebug() << "[Scanner] üß† NPU enabled set to" << npuEnabled;
}

void Scanner::startScan(const QStringList &directories, const QString &hashAlgorithm, const QString &fileFilter)
{
    qDebug() << "[Scanner] üöÄ startScan aufgerufen mit" << directories.size() << "Verzeichnissen:" << directories;
    qDebug() << "[Scanner] Hash-Algorithmus:" << hashAlgorithm << "FileFilter:" << fileFilter;
    qDebug() << "[Scanner] üß† NPU enabled?" << npuEnabled << "(Hash-only when false)";

    // üìä SOFORTIGER PROGRESS-UPDATE: Scan-Initialisierung
    emit scanProgress(0, 0, directories.size());
    emit scanStatusChanged(QString("üîç Initialisiere Scan f√ºr %1 Verzeichnisse...").arg(directories.size()));
    emit currentFileProcessing("Initialisierung", "üîç Scan-Vorbereitung", 0, directories.size());
    emit processActivityUpdate("üîç Starte Duplikat-Scan", QString("Bereite %1 Verzeichnisse vor").arg(directories.size()));

    // Defensive pointer checks (log-only, allow scan to proceed where possible)
    if (!hashEngine) qWarning() << "[Scanner] ‚ö†Ô∏è hashEngine ist null ‚Äì Hashing wird sp√§ter eventuell √ºbersprungen.";
    if (!presetManager) qWarning() << "[Scanner] ‚ö†Ô∏è presetManager ist null ‚Äì FTP-Logins verwenden Default-Credentials.";

    // üß† NPU-Counter zur√ºcksetzen bei neuem Scan
    npuProcessedImages = 0;
    qDebug() << "[Scanner] üîÑ NPU-Counter zur√ºckgesetzt f√ºr neuen Scan";

    // ‚úÖ FIX: Clear processed files cache f√ºr neuen Scan
    if (hashEngine) {
        hashEngine->clearProcessedFiles();
        qDebug() << "[Scanner] üßπ HashEngine processed files cache geleert";
    }
    
    // üî• RESET ALL STATIC VARIABLES: Verhindert Datei-Vervielfachung bei zweitem Scan!
    globalHashedFiles.clear();
    qDebug() << "[Scanner] üßπ globalHashedFiles cleared f√ºr neuen Scan";

    // üî• CRITICAL FIX: L√∂sche Scan-History bei jedem neuen Scan!
    // Andernfalls werden alle Verzeichnisse als "bereits gescannt" √ºbersprungen
    clearScanHistory();
    qDebug() << "[Scanner] üóëÔ∏è Scan-History gel√∂scht f√ºr neuen Scan";

    // ‚úÖ FIX: Pr√ºfe ob bereits ein Scan l√§uft
    if (scanning.load()) {
        qDebug() << "[Scanner] ‚è∏Ô∏è Stoppe vorherigen Scan, starte neuen...";
        stopScan(); // Stoppe aktuellen Scan
        scanning.store(false); // Reset scanning state
    }

    if (directories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå Keine Verzeichnisse zum Scannen!";
        emit scanProgress(100, 0, 0);
        emit scanStatusChanged("‚ùå Keine Verzeichnisse ausgew√§hlt - Scan abgebrochen");
        // ‚ö†Ô∏è WICHTIG: Emittiere KEIN scanCompleted - Scan wurde nicht gestartet!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT - verwirrt GUI
        return;
    }
    
    // üîê HISTORY-CHECK: Filtere bereits gescannte Verzeichnisse
    QStringList newDirectories;
    QStringList skippedDirectories;
    
    for (const QString &dir : directories) {
        if (isDirectoryInHistory(dir)) {
            skippedDirectories.append(dir);
            qDebug() << "[Scanner] ‚è≠Ô∏è √úberspringe bereits gescanntes Verzeichnis:" << dir;
        } else {
            newDirectories.append(dir);
        }
    }
    
    if (!skippedDirectories.isEmpty()) {
        qDebug() << "[Scanner] üìú History-Filter:" << skippedDirectories.size() << "√ºbersprungen," 
                 << newDirectories.size() << "neu";
        // ‚úÖ Zeige Info nur wenn auch neue Verzeichnisse da sind
        if (!newDirectories.isEmpty()) {
            emit scanStatusChanged(QString("üîç Starte Scan (%1 neu, %2 √ºbersprungen)").arg(newDirectories.size()).arg(skippedDirectories.size()));
        }
    }
    
    if (newDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Alle Verzeichnisse bereits in History - nichts zu tun!";
        emit scanProgress(100, 0, 0);
        emit scanStatusChanged("‚è≠Ô∏è Alle Verzeichnisse bereits gescannt - nichts zu tun!");
        emit currentFileProcessing("Keine neuen Verzeichnisse", "‚úÖ Alle bereits gescannt", 0, 0);
        // ‚ö†Ô∏è WICHTIG: Emittiere KEIN scanCompleted - w√ºrde "0 Duplikate" anzeigen!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT
        return;
    }
    
    // ‚úÖ WICHTIG: Status f√ºr aktiven Scan setzen
    emit scanStatusChanged(QString("üîç Starte Duplikat-Scan mit %1 Verzeichnissen...").arg(newDirectories.size()));
    // ‚úÖ NEU: Separiere lokale und FTP-Pfade f√ºr parallele Verarbeitung
    QStringList localDirectories;
    QStringList ftpDirectories;
    
    for (const QString &dir : newDirectories) {  // ‚úÖ USE newDirectories (history-filtered)
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            ftpDirectories.append(dir);
        } else {
            localDirectories.append(dir);
        }
    }
    
    qDebug() << "[Scanner] üìÇ Lokale Verzeichnisse:" << localDirectories.size();
    qDebug() << "[Scanner] üì° Netzwerk-Verzeichnisse:" << ftpDirectories.size();

    // Deduplicate directories to prevent redundant work
    QStringList optimizedDirectories = deduplicateDirectories(newDirectories);  // ‚úÖ USE newDirectories
    
    if (optimizedDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå Nach Pfad-Optimierung keine Verzeichnisse √ºbrig!";
        emit scanStatusChanged("‚ö†Ô∏è Pfad-Optimierung: Alle Verzeichnisse redundant");
        // ‚ö†Ô∏è WICHTIG: KEIN scanCompleted - Scan wurde nicht gestartet!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT
        return;
    }

    scanDirectories = optimizedDirectories;
    currentHashAlgorithm = hashAlgorithm;
    currentFileFilter = fileFilter;

    // üõ°Ô∏è KRITISCH: Deduplication-Caches f√ºr NEUEN Scan zur√ºcksetzen
    clearDeduplicationCaches();
    
    // üîê F√ºge neue Verzeichnisse zur History hinzu
    for (const QString &dir : optimizedDirectories) {
        addToScanHistory(dir, true);
    }
    qDebug() << "[Scanner] üîÑ Neuer Scan gestartet - Deduplication-Caches zur√ºckgesetzt";

    // Reset state
    allFiles.clear();
    fileSizeGroups.clear();
    hashGroups.clear();
    
    // ÔøΩ CRITICAL FIX: processedFiles auch l√∂schen f√ºr neuen Scan!
    {
        QMutexLocker locker(&processedFilesMutex);
        processedFiles.clear();
    }
    qDebug() << "[Scanner] üßπ processedFiles gel√∂scht f√ºr neuen Scan";
    
    // ÔøΩüî• KRITISCH: Reset m_totalCollectedFiles f√ºr neuen Scan
    m_totalCollectedFiles = 0;

    scanning.store(true);
    paused.store(false);
    currentPhase = COLLECTING;
    
    // üî• GUARD FLAG RESET: Erlaube neue scanCompleted-Emission f√ºr diesen Scan
    m_scanCompletedEmitted.store(false);

    qDebug() << "[Scanner] üîç Pfad-Optimierung:" << directories.size()
              << "‚Üí" << optimizedDirectories.size() << "Verzeichnisse";
    emit scanStatusChanged("Sammle Dateien (parallel: lokal + netzwerk)...");

    // üöÄ START FTP QUEUE DRAIN TIMER: Falls bereits Queue existiert (z.B. nach Neustart)
    bool hasQueuedFtpDirs = false;
    for (auto it = ftpQueuePerHost.begin(); it != ftpQueuePerHost.end(); ++it) {
        if (!it.value().isEmpty()) {
            hasQueuedFtpDirs = true;
            break;
        }
    }
    if (hasQueuedFtpDirs && ftpQueueDrainTimer && !ftpQueueDrainTimer->isActive()) {
        ftpQueueDrainTimer->start();
        qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestartet (existierende Queue gefunden)";
    }

    // ‚ö° ASYNC via QTimer: Already non-blocking - timers run in GUI event loop
    // QtConcurrent wurde entfernt weil QTimer nicht aus Worker-Thread gestartet werden kann
    startAsyncFileCollection();
}

QStringList Scanner::deduplicateDirectories(const QStringList &directories)
{
    QSet<QString> canonicalPaths;
    QStringList result;

    // Convert all paths to canonical form (handle both local and FTP paths)
    QMap<QString, QString> originalToCanonical;
    for (const QString &dir : directories)
    {
        QString canonical;
        
        // üõ°Ô∏è CRASH-FIX: SAFE URL/path handling f√ºr FTP und lokale Pfade
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            canonical = dir; // FTP/Network paths bleiben unver√§ndert
            qDebug() << "[Scanner] üì° Network-URL beibehalten:" << canonical;
        } else {
            // SAFE: Nur auf lokale Pfade canonicalPath() anwenden
            QDir dirObj(dir);
            if (dirObj.exists()) {
                canonical = dirObj.canonicalPath();
                qDebug() << "[Scanner] üìÇ Lokaler Pfad kanonisch:" << canonical;
            } else {
                canonical = dir; // Falls nicht existiert, Original beibehalten
                qDebug() << "[Scanner] ‚ö†Ô∏è Pfad existiert nicht, Original beibehalten:" << canonical;
            }
        }
        
        if (!canonical.isEmpty())
        {
            originalToCanonical[dir] = canonical;
        }
    }

    // Remove parent-child relationships and duplicates
    for (auto it = originalToCanonical.begin(); it != originalToCanonical.end(); ++it)
    {
        QString currentPath = it.value();
        bool isRedundant = false;

        // ‚úÖ FIX: √úberspringe Deduplication f√ºr FTP/Netzwerk-Pfade
        if (currentPath.startsWith("ftp://") || currentPath.startsWith("sftp://") || currentPath.startsWith("smb://")) {
            canonicalPaths.insert(currentPath);
            result.append(it.key());
            qDebug() << "[Scanner] üì° Network-Pfad hinzugef√ºgt ohne Deduplication:" << currentPath;
            continue; // √úberspringe Parent-Child-Pr√ºfung f√ºr Netzwerk-Pfade
        }

        // Check if this path is a child of any already processed path (nur f√ºr lokale Pfade)
        for (const QString &existingPath : canonicalPaths)
        {
            // √úberspringe Vergleich mit Netzwerk-Pfaden
            if (existingPath.startsWith("ftp://") || existingPath.startsWith("sftp://") || existingPath.startsWith("smb://")) {
                continue;
            }
            
            if (currentPath.startsWith(existingPath + "/"))
            {
                isRedundant = true;
                std::cout << "‚è≠Ô∏è  √úberspringe Unterverzeichnis: " << it.key().toLocal8Bit().constData()
                          << " (enthalten in " << existingPath.toLocal8Bit().constData() << ")" << std::endl;
                break;
            }
        }

        if (!isRedundant)
        {
            // Remove any existing paths that are children of the current path
            auto existing = canonicalPaths.begin();
            while (existing != canonicalPaths.end())
            {
                if (existing->startsWith(currentPath + "/"))
                {
                    std::cout << "üîÑ Ersetze Unterverzeichnis " << existing->toLocal8Bit().constData()
                              << " durch Elternverzeichnis " << currentPath.toLocal8Bit().constData() << std::endl;
                    existing = canonicalPaths.erase(existing);
                }
                else
                {
                    ++existing;
                }
            }

            canonicalPaths.insert(currentPath);
            result.append(it.key());
        }
    }

    return result;
}
void Scanner::stopScan()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] ‚èπÔ∏è FORCE-STOP: Stoppe alle Scan-Aktivit√§ten";
    
    scanning.store(false);
    paused.store(false);
    currentPhase = IDLE;
    
    // ‚úÖ KRITISCH: Stoppe alle Timer
    if (processTimer) {
        processTimer->stop();
        qDebug() << "[Scanner] üõë ProcessTimer gestoppt";
    }
    
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
        qDebug() << "[Scanner] üõë FileCollectionTimer gestoppt";
    }
    
    if (ftpQueueDrainTimer && ftpQueueDrainTimer->isActive()) {
        ftpQueueDrainTimer->stop();
        qDebug() << "[Scanner] üõë FTP-Queue-Drain-Timer gestoppt (Scan abgebrochen)";
    }
    
    // ‚úÖ Cleanup asynchrone Dateisammlung
    cleanupFileCollection();
    
    // ‚úÖ KRITISCH: Stoppe HashEngine
    if (hashEngine) {
        // Hier k√∂nnten wir hashEngine->stopCalculation() aufrufen
        hashEngine->clearProcessedFiles(); // üõ°Ô∏è CRITICAL: Clear to prevent infinite loops
        qDebug() << "[Scanner] üõë HashEngine-Stop signalisiert und Cache geleert";
    }
    
    // ‚úÖ KRITISCH: Leere alle Collections f√ºr sauberen Stop
    allFiles.clear();
    hashGroups.clear();
    fileSizeGroups.clear();
    
    // üõ°Ô∏è NEU: Deduplication-Caches leeren bei Scan-Stop
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    
    qDebug() << "[Scanner] üßπ Alle Collections geleert";
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert";
    
    emit scanStatusChanged("‚èπÔ∏è Scan gestoppt - alle Prozesse beendet");
    std::cout << "‚èπÔ∏è Duplikat-Scan vollst√§ndig gestoppt" << std::endl;
    
    // ‚úÖ KRITISCH: Emittiere leere Ergebnisse um GUI zu clearen (nur einmal)
    if (!m_scanCompletedEmitted.exchange(true)) {
        DuplicateGroups emptyResults;
        emit scanCompleted(emptyResults);
        qDebug() << "[Scanner] üî• EMIT scanCompleted (STOP) - totalFiles: 0";
    }
}

void Scanner::pauseScan()
{
    if (!scanning.load())
        return;

    paused.store(true);
    processTimer->stop();
    emit scanStatusChanged("Scan pausiert");
    std::cout << "‚è∏Ô∏è Duplikat-Scan pausiert" << std::endl;
}

void Scanner::resumeScan()
{
    if (!scanning.load() || !paused.load())
        return;

    paused.store(false);
    processTimer->start();
    emit scanStatusChanged("Scan fortgesetzt");
    std::cout << "‚ñ∂Ô∏è Duplikat-Scan fortgesetzt" << std::endl;
}

void Scanner::collectFiles()
{
    emit scanStatusChanged("Sammle Dateien parallel (lokal + netzwerk)...");
    QSet<QString> processedFiles; // Prevent duplicate file processing
    
    // Clear FTP processing state
    pendingFtpDirectories.clear();
    completedFtpDirectories.clear();
    ftpDirectoriesProcessed = 0;
    
    bool hasFtpDirectories = false;
    bool hasLocalDirectories = false;
    
    // üéØ FORTSCHRITTS-TRACKING f√ºr Dateien sammeln
    int totalDirectoriesToProcess = scanDirectories.size();
    int processedDirectoriesCount = 0;
    int totalFilesFound = 0;

    for (const QString &directory : scanDirectories)
    {
        if (!scanning.load())
            return;
            
        // üìä LIVE-Update: Verzeichnis-Fortschritt
        processedDirectoriesCount++;
        emit currentFileProcessing(
            QFileInfo(directory).fileName(), 
            "üìÅ Dateien sammeln", 
            processedDirectoriesCount, 
            totalDirectoriesToProcess
        );
        emit processActivityUpdate(
            QString("üìÇ Sammle Dateien aus Verzeichnis %1/%2")
                .arg(processedDirectoriesCount).arg(totalDirectoriesToProcess),
            QString("Aktuell: %1").arg(QFileInfo(directory).fileName())
        );

        // Check if this is an FTP path
        if (directory.startsWith("ftp://"))
        {
            hasFtpDirectories = true;
            
            // üöÄ START FTP QUEUE DRAIN TIMER: Periodischer Queue-Check
            if (ftpQueueDrainTimer && !ftpQueueDrainTimer->isActive()) {
                ftpQueueDrainTimer->start();
                qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestartet (200ms Intervall)";
            }
            
            collectFtpFiles(directory, processedFiles);
            
            // üöÄ TRIGGER: Starte initiales Progress-Update nach kurzem Delay
            QTimer::singleShot(1000, this, &Scanner::checkScanProgress);
        }
        else
        {
            hasLocalDirectories = true;
            // Local directory scanning - parallel zu FTP
            QDirIterator it(directory, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);

            while (it.hasNext())
            {
                if (!scanning.load())
                    return;

                QString filePath = it.next();
                QFileInfo fileInfo(filePath);
                
                totalFilesFound++;
                
                // ‚ö° OPTIMIZED: ProcessEvents nur alle 100 Dateien (statt 1)
                // 50x weniger ProcessEvents Calls = praktisch kein Overhead
                // GUI bleibt 100% responsive bei batch processing
                if (totalFilesFound % 100 == 0) {
                    QApplication::processEvents(QEventLoop::ExcludeUserInputEvents);
                }
                
                // üìä ECHTZEIT-Update: Datei gefunden (alle 5 Dateien f√ºr Verbosity)
                if (totalFilesFound % 5 == 0) {
                    emit currentFileProcessing(
                        fileInfo.fileName(), 
                        "üîç Dateien scannen", 
                        totalFilesFound, 
                        0  // Unbekannte Gesamtzahl w√§hrend sammeln
                    );
                    emit processActivityUpdate(
                        QString("üìä %1 Dateien gefunden").arg(totalFilesFound),
                        QString("Aktuell: %1").arg(fileInfo.fileName())
                    );
                }

                qDebug() << "[Scanner] üîç Untersuche Datei:" << filePath;

                // Normalize path to prevent duplicates
                QString canonicalPath = fileInfo.canonicalFilePath();
                
                // üõ°Ô∏è FALLBACK: Wenn canonicalFilePath leer ist, verwende absoluten Pfad
                if (canonicalPath.isEmpty()) {
                    canonicalPath = fileInfo.absoluteFilePath();
                    qDebug() << "[Scanner] ‚ö†Ô∏è canonicalFilePath leer, verwende absoluten Pfad:" << canonicalPath;
                }
                
                qDebug() << "[Scanner] üìù Kanonischer Pfad:" << canonicalPath;
                
                // üîí THREAD-SAFE: Lock f√ºr processedFiles (verhindert Race Conditions)
                {
                    QMutexLocker locker(&processedFilesMutex);
                    qDebug() << "[Scanner] üìä processedFiles.size():" << processedFiles.size();
                    
                    if (processedFiles.contains(canonicalPath))
                    {
                        qDebug() << "[Scanner] üîÑ Datei bereits in diesem Scan verarbeitet (√ºbersprungen):" << canonicalPath.right(50);
                        continue; // Skip duplicate files
                    }
                    processedFiles.insert(canonicalPath);
                    qDebug() << "[Scanner] ‚úÖ Datei zu processedFiles hinzugef√ºgt:" << canonicalPath.right(50);
                }

                // Apply file filter
                if (!currentFileFilter.isEmpty() && currentFileFilter != "Alle Dateien" && currentFileFilter != "*")
                {
                    QString extension = fileInfo.suffix().toLower();
                    qDebug() << "[Scanner] üîç Pr√ºfe Filter:" << currentFileFilter << "vs Extension:" << extension;
                    if (!currentFileFilter.contains(extension, Qt::CaseInsensitive))
                    {
                        qDebug() << "[Scanner] ‚ùå Datei durch Filter ausgeschlossen:" << filePath;
                        continue;
                    }
                }
                else
                {
                    qDebug() << "[Scanner] ‚úÖ Filter √ºbersprungen (alle Dateien):" << currentFileFilter;
                }

                // Skip system paths if PresetManager available
                if (presetManager && presetManager->shouldExcludePath(filePath))
                {
                    qDebug() << "[Scanner] ‚ùå Datei durch PresetManager ausgeschlossen:" << filePath;
                    continue;
                }

                // Ô∏è Optional: Gro√üe Dateien √ºberspringen nur wenn explizit aktiviert
                // Steuerung √ºber FILEDUPER_SKIP_LARGE=1 und optional FILEDUPER_MAX_SIZE_MB (Default 0 = kein Limit)
                qint64 fileSize = fileInfo.size();
                bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
                qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
                if (skipLarge && maxSizeMb > 0) {
                    qint64 maxBytes = maxSizeMb * 1024 * 1024;
                    if (fileSize > maxBytes) {
                        qDebug() << "[Scanner] üö® GROSSE DATEI √ºbersprungen (" << maxSizeMb << "MB):" << filePath << "Gr√∂√üe:" << (fileSize / 1024 / 1024) << "MB";
                        continue;
                    }
                }

                qDebug() << "[Scanner] ‚úÖ Datei bestanden alle Filter, f√ºge zu allFiles hinzu:" << canonicalPath;

                FileInfo file;
                file.filePath = canonicalPath; // Use canonical path
                file.fileName = fileInfo.fileName();
                file.size = fileInfo.size();
                file.lastModified = fileInfo.lastModified().toMSecsSinceEpoch();
                file.isLocal = true; // ‚úÖ NEU: Markiere als lokale Datei

                allFiles.append(file);
                qDebug() << "[Scanner] üìä allFiles.size() nach Hinzuf√ºgung:" << allFiles.size();

                if (allFiles.size() % 1000 == 0)
                {
                    // During collection phase: Show files collected with indeterminate progress
                    emit scanProgress(0, allFiles.size(), -1); // -1 indicates collection phase
                    std::cout << "üìÅ " << allFiles.size() << " lokale Dateien gesammelt..." << std::endl;
                }
            }
        }
    }

    emit filesCollected(allFiles.size());
    
    // üî• SPEICHERE Anzahl gesammelter Dateien f√ºr sp√§tere scanCompleted-Emissionen
    m_totalCollectedFiles = allFiles.size();
    qDebug() << "[Scanner] üìä GESPEICHERT: m_totalCollectedFiles =" << m_totalCollectedFiles;
    
    std::cout << "üìÅ " << allFiles.size() << " eindeutige Dateien gesammelt (lokal: " << (hasLocalDirectories ? "‚úÖ" : "‚ùå") << ", netzwerk: " << (hasFtpDirectories ? "‚úÖ" : "‚ùå") << ")" << std::endl;
    if (processedFiles.size() > allFiles.size())
    {
        std::cout << "üîÑ " << (processedFiles.size() - allFiles.size()) << " Duplikate √ºbersprungen" << std::endl;
    }

    // üîç DEBUG: Zeige hasLocalDirectories und hasFtpDirectories Status vor if-else Kette
    qDebug() << "[Scanner] üîç DEBUG PATH LOGIC: hasLocalDirectories=" << hasLocalDirectories << "hasFtpDirectories=" << hasFtpDirectories;
    
    // ‚úÖ NEU: Parallele Verarbeitung - lokale Dateien sind bereits gesammelt
    if (hasLocalDirectories && !hasFtpDirectories) {
        // Nur lokale Dateien - sofort weiter zur Size-Filterung
        qDebug() << "[Scanner] üìÇ Nur lokale Dateien gefunden, starte Size-Filtering";
        filterBySize();
    } else if (!hasLocalDirectories && hasFtpDirectories) {
        // Nur FTP-Dateien - warte auf FTP-Verarbeitung
        qDebug() << "[Scanner] üì° Nur FTP-Dateien gefunden, warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Lade FTP-Verzeichnisse: 0/%1").arg(pendingFtpDirectories.size()));
    } else if (hasLocalDirectories && hasFtpDirectories) {
        // Beide Arten - lokale sind bereits da, warte auf FTP-Completion
        qDebug() << "[Scanner] ÔøΩ Parallel-Scan: Lokale Dateien fertig (" << allFiles.size() << "), warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Parallel: Lokal fertig (%1), FTP: 0/%2").arg(allFiles.size()).arg(pendingFtpDirectories.size()));
    } else {
        // Keine Dateien gefunden
        qDebug() << "[Scanner] ‚ùå Keine Dateien gefunden";
        filterBySize(); // Leerer Scan
    }
}

void Scanner::filterBySize()
{
    if (!scanning.load())
        return;

    emit scanStatusChanged("üìä Phase 1: SIZE+NAME Duplikat-Suche...");
    currentPhase = SIZE_FILTERING;
    
    // ÔøΩ NEUE 3-PHASEN-PIPELINE:
    // Phase 1: SIZE+NAME Matching (ultra-schnell, keine Hash-Berechnung!)
    // Phase 2: Hash-Berechnung nur f√ºr verbleibende Dateien (8x parallel chunks)
    // Phase 3: Hash-basierter Duplikat-Vergleich (8x parallel)
    
    qDebug() << "[Scanner] üöÄ PHASE 1: SIZE+NAME Pre-Filter (8x Pipeline)";
    
    // üìä Gruppiere Dateien nach SIZE+NAME (case-insensitive)
    QMap<QString, QList<FileInfo>> sizeNameGroups;
    int phase1Processed = 0;
    
    for (const FileInfo &file : allFiles) {
        if (!scanning.load()) return;
        
        // SIZE+NAME Key: "size_filename.toLowerCase()"
        QString sizeNameKey = QString("%1_%2").arg(file.size).arg(file.fileName.toLower());
        sizeNameGroups[sizeNameKey].append(file);
        
        phase1Processed++;
        if (phase1Processed % 100 == 0) {
            emit currentFileProcessing(
                file.fileName,
                "üìä Phase 1: SIZE+NAME Analyse",
                phase1Processed,
                allFiles.size()
            );
            QApplication::processEvents();
        }
    }
    
    qDebug() << "[Scanner] ‚úÖ Phase 1 abgeschlossen:" << sizeNameGroups.size() << "eindeutige SIZE+NAME Gruppen";
    
    // üéØ SMART: Finde SIZE+NAME Duplikate (brauchen KEIN Hashing!)
    QList<FileInfo> sizeNameDuplicates;
    QList<FileInfo> needsHashing;
    int sizeNameDupCount = 0;
    
    for (auto it = sizeNameGroups.begin(); it != sizeNameGroups.end(); ++it) {
        QList<FileInfo> &group = it.value();
        
        if (group.size() > 1) {
            // ‚ö° DUPLIKAT gefunden nur durch SIZE+NAME!
            sizeNameDupCount += group.size();
            for (FileInfo &file : group) {
                file.hash = QString("SIZE_NAME_%1_%2").arg(file.size).arg(file.fileName.toLower());
                sizeNameDuplicates.append(file);
            }
            qDebug() << "[Scanner] ‚ö° SIZE+NAME Duplikat:" << group.first().fileName 
                     << "(" << group.size() << "Kopien) - KEIN Hash n√∂tig!";
        } else {
            // Nur 1 Datei mit dieser SIZE+NAME ‚Üí muss gehasht werden
            needsHashing.append(group.first());
        }
    }
    
    qDebug() << "[Scanner] üìä Phase 1 Ergebnis:";
    qDebug() << "[Scanner]   ‚ö°" << sizeNameDupCount << "Dateien sind SIZE+NAME Duplikate (KEIN Hash!)";
    qDebug() << "[Scanner]   üîç" << needsHashing.size() << "Dateien brauchen Hash-Berechnung";
    
    // üìä Gruppiere Hash-Kandidaten nach Gr√∂√üe f√ºr Phase 2
    {
        QMutexLocker locker(&m_fileSizeGroupsMutex);  // üîí CRITICAL: Protect map construction
        fileSizeGroups.clear();
        for (const FileInfo &file : needsHashing) {
            fileSizeGroups[file.size].append(file);
        }
    }  // Unlock after population

    // ‚úÖ PRODUCTION: Optimiere durch Entfernung von Single-File-Gruppen (echte Duplikat-Erkennung)
    qDebug() << "[Scanner] üìä Size-Groups vor Filterung:" << fileSizeGroups.size() << "verschiedene Gr√∂√üen";
    
    // Entferne Gruppen mit nur einer Datei (keine Duplikate m√∂glich)
    {
        QMutexLocker locker(&m_fileSizeGroupsMutex);  // üîí CRITICAL: Protect iterator operations
        auto it = fileSizeGroups.begin();
        while (it != fileSizeGroups.end())
        {
            if (it.value().size() == 1)
            {
                it = fileSizeGroups.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }  // Unlock m_fileSizeGroupsMutex after cleanup
    
    qDebug() << "[Scanner] üìä Size-Groups nach Filterung:" << fileSizeGroups.size() << "Gruppen mit potentiellen Duplikaten";

    // üîé Optional: Deep debug per size-group when FILEDUPER_DEBUG_GROUPS=1
    static const bool debugGroups = qEnvironmentVariableIsSet("FILEDUPER_DEBUG_GROUPS") && (qgetenv("FILEDUPER_DEBUG_GROUPS") == "1");
    if (debugGroups) {
        int groupIndex = 0;
        for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ++it) {
            const qint64 sizeKey = it.key();
            const QList<FileInfo> &files = it.value();
            int localCount = 0, ftpCount = 0;
            for (const FileInfo &f : files) {
                if (f.isLocal) localCount++; else if (f.filePath.startsWith("ftp://")) ftpCount++;
            }
            qDebug() << "[Scanner] üîé Gruppe" << (++groupIndex) << ": size=" << sizeKey
                     << " files=" << files.size() << " local=" << localCount << " ftp=" << ftpCount;
        }
    }

    int potentialDuplicates = 0;
    for (const auto &group : fileSizeGroups)
    {
        potentialDuplicates += group.size();
    }

    qDebug() << "[Scanner] üìä" << potentialDuplicates << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    std::cout << "üìä " << potentialDuplicates << " Dateien zur Hash-Berechnung hinzugef√ºgt" << std::endl;

    // üî• KRITISCH: Rufe startHashing() NUR auf wenn KEIN FTP-Scan aktiv ist!
    // Bei FTP-Scans wird startHashing() von checkScanProgress() aufgerufen
    if (pendingFtpDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Kein FTP-Scan aktiv - starte Early-Exit Filter";
        filterByEarlyExit();  // üöÄ Eliminiere 70-80% Dateien via 512B pre-hash!
        startHashing();
    } else {
        qDebug() << "[Scanner] ‚è≥ FTP-Scan aktiv (" << pendingFtpDirectories.size() << "pending) - warte auf checkScanProgress()";
    }
}

void Scanner::startHashing()
{
    qDebug() << "[Scanner] startHashing() aufgerufen";
    qDebug() << "[Scanner] scanning.load():" << scanning.load();
    qDebug() << "[Scanner] hashEngine g√ºltig:" << (hashEngine != nullptr);
    qDebug() << "[Scanner] allFiles.size():" << allFiles.size();
    
    if (!scanning.load() || !hashEngine) {
        qDebug() << "[Scanner] ‚ùå startHashing() - Fr√ºher Return: scanning=" << scanning.load() << ", hashEngine=" << (hashEngine != nullptr);
        return;
    }

    qDebug() << "[Scanner] ‚úÖ startHashing() - Bedingungen erf√ºllt, starte Hash-Berechnung";
    
    // üöÄ OPTIMIERUNG 2: Smart Pre-Filtering - Skip kleine UND gro√üe Dateien
    int originalCount = allFiles.size();
    QList<FileInfo> filteredFiles;
    int skippedTooSmall = 0;
    int skippedTooLarge = 0;
    const qint64 maxFileSizeForHashing = 10 * 1024 * 1024; // üöÄ 10MB Limit (skip Music/Video!)
    
    if (enableSmartPreFiltering) {
        for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ) {
            qint64 fileSize = it.key();
            QList<FileInfo> &filesInGroup = it.value();
            
            if (fileSize < minFileSizeForHashing) {
                skippedTooSmall += filesInGroup.size();
                it = fileSizeGroups.erase(it);  // Remove entire size group
            } else if (fileSize > maxFileSizeForHashing) {
                // üöÄ NEU: Skip Dateien >100MB (zu langsam √ºber FTP)
                skippedTooLarge += filesInGroup.size();
                it = fileSizeGroups.erase(it);
            } else {
                ++it;
            }
        }
        
        qDebug() << "[Scanner] ‚ö° Smart Pre-Filter: √úberspringe" << skippedTooSmall 
                 << "Dateien <" << minFileSizeForHashing << "Bytes";
        qDebug() << "[Scanner] ‚ö° Smart Pre-Filter: √úberspringe" << skippedTooLarge 
                 << "Dateien >" << (maxFileSizeForHashing / 1024 / 1024) << "MB (FTP-Speed-Optimierung)";
        qDebug() << "[Scanner] ‚úÖ Verbleibend f√ºr Hash-Berechnung:" << (originalCount - skippedTooSmall - skippedTooLarge) << "Dateien";
    }
    
    emit scanStatusChanged(QString("Berechne Hashes f√ºr %1 Dateien...").arg(originalCount - skippedTooSmall));
    currentPhase = HASHING;
    
    // üî• KRITISCH: Speichere m_totalCollectedFiles HIER als Backup
    // Falls es in collectFiles() nicht gesetzt wurde (z.B. bei FTP-only Scans)
    if (m_totalCollectedFiles == 0 && allFiles.size() > 0) {
        m_totalCollectedFiles = allFiles.size();
        qDebug() << "[Scanner] üìä BACKUP GESPEICHERT in startHashing(): m_totalCollectedFiles =" << m_totalCollectedFiles;
    }
    
    QStringList filesToHash;
    
    // ‚úÖ FTP-Credentials aus INI-Datei laden (ignoriere URL-Credentials)
    if (presetManager) {
        QSet<QString> ftpHosts;
        for (const FileInfo &file : allFiles) {
            if (file.filePath.startsWith("ftp://")) {
                QUrl url(file.filePath);
                if (url.isValid()) {
                    // Verwende nur den Host, ignoriere Credentials in der URL
                    QString host = url.host();
                    if (!host.isEmpty()) {
                        ftpHosts.insert(host);
                    }
                }
            }
        }
        
        // Lade echte Credentials aus INI-Datei f√ºr jeden Host
        for (const QString &host : ftpHosts) {
            LoginData login = presetManager->getLogin(host, 21);  
            if (login.isValid()) {
                hashEngine->setFtpCredentials(host, login.username, login.password);
                qDebug() << "[Scanner] üîê Echte FTP-Credentials aus INI-Datei geladen f√ºr:" << host << "User:" << login.username;
            } else {
                qWarning() << "[Scanner] ‚ö†Ô∏è Keine FTP-Credentials in INI-Datei gefunden f√ºr:" << host;
                qWarning() << "[Scanner] üí° Bitte FTP-Credentials in Settings speichern f√ºr Host:" << host;
            }
        }
    }
    
    // ÔøΩ OPTIMIZED: Use only files from optimized size+date groups instead of ALL files
    QMap<QString, QList<FileInfo>> dateSizeGroups;
    
    // ‚úÖ FIX: Hash ALL files - size filtering prevents content-based duplicate detection
    for (auto &sizeGroup : fileSizeGroups)
    {
        // REMOVED: Unique size filtering - files with same content can have different sizes
        // All files must be hashed to ensure proper duplicate detection
        
        bool hasNetworkFiles = false;
        // Check if group contains network files (FTP/SFTP etc.)
        for (const FileInfo &file : sizeGroup) {
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://")) {
                hasNetworkFiles = true;
                break;
            }
        }
        
        if (hasNetworkFiles) {
            // For network files: Skip date filtering (unreliable timestamps)
            QString sizeOnlyKey = QString("size_%1").arg(sizeGroup.first().size);
            dateSizeGroups[sizeOnlyKey] = sizeGroup;
            qDebug() << "[Scanner] üì° Network-Gruppe (nur Size-Filter):" << sizeGroup.size() << "Dateien";
        } else {
            // For local files: Use size+date filtering for better optimization  
            QMap<QString, QList<FileInfo>> dateSubGroups;
            for (const FileInfo &file : sizeGroup) {
                QDateTime dateTime = QDateTime::fromSecsSinceEpoch(file.lastModified);
                QString dateKey = QString("%1_%2").arg(dateTime.toString("yyyy-MM-dd")).arg(file.size);
                dateSubGroups[dateKey].append(file);
            }
            
            // ‚úÖ FIX: Keep ALL files in date groups - size filtering already happened
            // Files with same size but different dates could still be duplicates
            for (auto dateIt = dateSubGroups.begin(); dateIt != dateSubGroups.end(); ++dateIt) {
                dateSizeGroups[dateIt.key()] = dateIt.value();
            }
            qDebug() << "[Scanner] üìÅ Lokale Gruppe (Size+Date-Filter):" << dateSubGroups.size() << "Untergruppen";
        }
    }
    
    // Add optimized files to hash calculation
    QSet<QString> processedForHashing; // üõ°Ô∏è SCHUTZ: Verhindere doppelte Hash-Berechnung
    
    for (const auto &group : dateSizeGroups)
    {
        for (const FileInfo &file : group) {
            // ÔøΩ CRITICAL: Skip Dateien die bereits SIZE_NAME Hash haben (gro√üe Dateien >100MB)
            if (!file.hash.isEmpty() && file.hash.startsWith("SIZE_NAME_")) {
                qDebug() << "[Scanner] ‚ö° SIZE_NAME-Hash bereits vorhanden (skip):" << file.fileName << "‚Üí" << file.hash.left(40);
                continue; // Keine Hash-Berechnung n√∂tig!
            }
            
            // ÔøΩüõ°Ô∏è CRITICAL FIX: Pr√ºfe ob Datei bereits zur Hash-Berechnung hinzugef√ºgt wurde
            QString canonicalPath;
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://") || 
                file.filePath.startsWith("smb://")) {
                // F√ºr Netzwerk-URLs: Verwende den Pfad direkt ohne canonicalFilePath()
                canonicalPath = file.filePath;
            } else {
                // F√ºr lokale Dateien: Verwende canonicalFilePath()
                canonicalPath = QFileInfo(file.filePath).canonicalFilePath();
                // üõ°Ô∏è ZUS√ÑTZLICHER SCHUTZ: Leere/ung√ºltige Pfade √ºberspringen
                if (canonicalPath.isEmpty()) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger canonicalPath f√ºr:" << file.filePath;
                    continue;
                }
            }
            
            // üõ°Ô∏è CRITICAL SECURITY: Auch globalHashedFiles pr√ºfen um Infinite-Loop zu verhindern
            if (processedForHashing.contains(canonicalPath) || globalHashedFiles.contains(canonicalPath)) {
                // ‚ö° PERFORMANCE: Log nur jeden 1000. Skip (verhindert 360MB Logs!)
                static int skipCount = 0;
                skipCount++;
                if (skipCount % 1000 == 1) {
                    qDebug() << "[Scanner] ‚ö†Ô∏è Datei bereits verarbeitet (√ºbersprungen, " << skipCount << "x total):" << file.filePath.right(50);
                }
                continue;
            }
            processedForHashing.insert(canonicalPath);
            // ‚úÖ FIX: F√ºge Datei NICHT vorab zu globalHashedFiles hinzu - erst wenn Hash empfangen!
            filesToHash.append(file.filePath);
        }
    }

    qDebug() << "[Scanner] üîç Starte OPTIMIERTE Hash-Berechnung f√ºr" << filesToHash.size() << "Dateien";
    qDebug() << "[Scanner] ‚ö° Performance-Boost durch" << (allFiles.size() - filesToHash.size()) << "√ºbersprungene Unique-Dateien";
    
    // Handle case when ALL files are unique
    if (filesToHash.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ ALLE Dateien sind unique - keine Hash-Berechnung erforderlich!";
        emit scanStatusChanged("‚úÖ Alle Dateien sind unique - keine Duplikate gefunden!");
        
        // üî• KRITISCH: Setze totalFiles damit GUI "Keine Duplikate gefunden!" korrekt anzeigt
        // ‚úÖ FIX: Nutze m_totalCollectedFiles statt allFiles.size() (k√∂nnte 0 sein!)
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = m_totalCollectedFiles; // Gespeicherte Anzahl
        
        qDebug() << "[Scanner] üî• PREPARE EMIT - totalFiles:" << emptyResults.totalFiles 
                 << "m_totalCollectedFiles:" << m_totalCollectedFiles 
                 << "allFiles.size:" << allFiles.size();
        
        // üî• GUARD: Emittiere nur wenn noch nicht emittiert
        // ‚úÖ FIX: KEIN QTimer - direkte Emission da alle Dateien unique sind (kein Hashing n√∂tig)
        if (!m_scanCompletedEmitted.exchange(true)) {
            emit scanCompleted(emptyResults);
            qDebug() << "[Scanner] üî• EMIT scanCompleted (ALL UNIQUE) - totalFiles:" << emptyResults.totalFiles;
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è scanCompleted bereits emittiert - √ºberspringe ALL UNIQUE emission";
        }
        return;
    }

    qDebug() << "[Scanner] üîç Starte Hash-Berechnung f√ºr" << filesToHash.size() << "Dateien";
    qDebug() << "[Scanner] üìä" << filesToHash.size() << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    
    // ‚ö°‚ö°‚ö° EXTREME PARALLELISIERUNG: 100 Chunks f√ºr maximale CPU-Auslastung!
    const int HASH_CHUNKS = 100;  // Chef sagt: NOCH SCHNELLER!
    const int filesPerChunk = (filesToHash.size() + HASH_CHUNKS - 1) / HASH_CHUNKS;
    
    qDebug() << "[Scanner] üöÄüöÄüöÄ EXTREME-CHUNK-PROCESSING:" << HASH_CHUNKS << "Chunks √†" << filesPerChunk << "Dateien";
    
    // Teile Dateien in Chunks auf
    QList<QStringList> fileChunks;
    for (int i = 0; i < HASH_CHUNKS && i * filesPerChunk < filesToHash.size(); ++i) {
        int startIdx = i * filesPerChunk;
        int endIdx = qMin(startIdx + filesPerChunk, filesToHash.size());
        QStringList chunk = filesToHash.mid(startIdx, endIdx - startIdx);
        if (!chunk.isEmpty()) {
            fileChunks.append(chunk);
        }
    }
    
    qDebug() << "[Scanner] ‚úÖ Aufgeteilt in" << fileChunks.size() << "Chunks f√ºr Parallel-Processing";
    
    // üöÄüöÄüöÄ SOFORT-START: Alle Chunks parallel ohne Verz√∂gerung!
    int chunkIndex = 0;
    for (const QStringList &chunk : fileChunks) {
        QTimer::singleShot(chunkIndex * 10, this, [this, chunk, chunkIndex, fileChunks]() {
            qDebug() << "[Scanner] ‚ö°‚ö°‚ö° Chunk" << (chunkIndex + 1) << "/" << fileChunks.size() 
                     << "gestartet mit" << chunk.size() << "Dateien";
            
            // Sende Chunk zur Hash-Berechnung
            for (const QString &file : chunk) {
                hashEngine->calculateFileHashAsync(file);
            }
        });
        chunkIndex++;
    }
    
    qDebug() << "[Scanner] üöÄ Alle" << fileChunks.size() << "Hash-Chunks gestartet!";
    
    // ‚ö° INTELLIGENTER TIMEOUT-SCHUTZ: Basiert auf Fortschritt, nicht auf fester Zeit
    // Starte Fortschritts-Monitor statt festem Timeout
    lastHashProgressTime = QDateTime::currentMSecsSinceEpoch();
    lastHashCount = 0;
    
    QTimer *progressMonitor = new QTimer(this);
    progressMonitor->setInterval(60000); // Pr√ºfe alle 60 Sekunden
    connect(progressMonitor, &QTimer::timeout, this, [this, filesToHash, progressMonitor]() {
        // üîß FIX: Monitor l√§uft f√ºr HASHING UND COMPARING (nicht nur HASHING!)
        if (!scanning.load() || (currentPhase != HASHING && currentPhase != COMPARING)) {
            progressMonitor->stop();
            progressMonitor->deleteLater();
            return;
        }
        
        qint64 currentTime = QDateTime::currentMSecsSinceEpoch();
        // üîß FIX: Nutze currentHashCount statt globalHashedFiles (wird bei 20K geleert!)
        int actualHashCount = currentHashCount.load(); // Thread-safe atomic read
        qint64 timeSinceLastProgress = (currentTime - lastHashProgressTime) / 1000; // Sekunden
        
        qDebug() << "[Scanner] üìä Progress-Check: Hashes" << actualHashCount << "/" << filesToHash.size() 
                 << "Zeit seit letztem Fortschritt:" << timeSinceLastProgress << "s";
        
        // Wenn Fortschritt gemacht wurde, aktualisiere Zeit
        if (actualHashCount > lastHashCount) {
            lastHashProgressTime = currentTime;
            lastHashCount = actualHashCount;
            qDebug() << "[Scanner] ‚úÖ Fortschritt erkannt - Timeout zur√ºckgesetzt";
            return;
        }
        
        // Wenn KEIN Fortschritt seit 10 Minuten UND weniger als 50% fertig ‚Üí Timeout
        if (timeSinceLastProgress > 600 && actualHashCount < filesToHash.size() / 2) {
            qWarning() << "[Scanner] ‚ö†Ô∏è KEIN FORTSCHRITT seit 10 Minuten bei" << actualHashCount 
                      << "/" << filesToHash.size() << "Hashes - Scan k√∂nnte stecken!";
            
            // Gib noch 5 Minuten Extra-Zeit
            if (timeSinceLastProgress > 900) {
                qWarning() << "[Scanner] üö® TIMEOUT: 15min ohne Fortschritt ‚Üí Nutze partielle Ergebnisse";
                
                progressMonitor->stop();
                progressMonitor->deleteLater();
                
                DuplicateGroups partialResults = buildPartialResults();
                
                if (partialResults.groups.size() > 0) {
                    qDebug() << "[Scanner] üéØ TIMEOUT-RETTUNG: Gefunden" << partialResults.groups.size() << "Duplikat-Gruppen!";
                    
                    if (hashEngine) {
                        hashEngine->clearProcessedFiles();
                        qDebug() << "[Scanner] üõë HashEngine gestoppt wegen Timeout";
                    }
                    
                    scanning.store(false);
                    currentPhase = COMPLETED;
                    emit scanProgress(100, filesToHash.size(), filesToHash.size());
                    
                    if (!m_scanCompletedEmitted.exchange(true)) {
                        emit scanCompleted(partialResults);
                        qDebug() << "[Scanner] üî• EMIT scanCompleted (TIMEOUT PARTIAL) - groups:" << partialResults.groups.size();
                    }
                }
            }
        }
        
        // üî• FIX: Auch bei >90% einen Timeout (5 Minuten) - falls FTP-Dateien fehlschlagen
        if (actualHashCount >= filesToHash.size() * 0.9) {
            qDebug() << "[Scanner] ‚úÖ Scan >90% fertig - warte maximal 5 Minuten auf Abschluss";
            
            // Bei >90% und 5 Minuten Stagnation ‚Üí Force Complete
            if (timeSinceLastProgress > 300) { // 5 Minuten = 300 Sekunden
                qWarning() << "[Scanner] üö® >90% TIMEOUT: 5min Stagnation bei" << actualHashCount 
                          << "/" << filesToHash.size() << "‚Üí Force Complete!";
                
                progressMonitor->stop();
                progressMonitor->deleteLater();
                
                DuplicateGroups partialResults = buildPartialResults();
                qDebug() << "[Scanner] üéØ >90% FORCE COMPLETE: Gefunden" << partialResults.groups.size() << "Duplikat-Gruppen!";
                
                if (hashEngine) {
                    hashEngine->clearProcessedFiles();
                }
                
                scanning.store(false);
                currentPhase = COMPLETED;
                emit scanProgress(100, filesToHash.size(), filesToHash.size());
                
                if (!m_scanCompletedEmitted.exchange(true)) {
                    emit scanCompleted(partialResults);
                    qDebug() << "[Scanner] üî• EMIT scanCompleted (>90% TIMEOUT) - groups:" << partialResults.groups.size();
                }
                return;
            }
        }
    });
    progressMonitor->start();
    qDebug() << "[Scanner] üïê Intelligenter Fortschritts-Monitor gestartet (statt fester Timeout)";
    
    // ÔøΩüöÄüß† Optional: NPU-FIRST BILDVERARBEITUNG: Separiere Bilder BEVOR Hash-Berechnung beginnt!
    QStringList imageFiles;
    QStringList nonImageFiles;
    
    // ‚úÖ BILDFILES vs. NORMAL FILES separieren
    for (const QString &filePath : filesToHash) {
        QString lowerExt = QFileInfo(filePath).suffix().toLower();
        if (lowerExt == "jpg" || lowerExt == "jpeg" || lowerExt == "png" || lowerExt == "bmp" || 
            lowerExt == "tiff" || lowerExt == "tif" || lowerExt == "cr2" || lowerExt == "raw" ||
            lowerExt == "nef" || lowerExt == "arw" || lowerExt == "dng" || lowerExt == "webp") {
            imageFiles.append(filePath);
        } else {
            nonImageFiles.append(filePath);
        }
    }
    
    qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "| Non-Images:" << nonImageFiles.size();
    
    // üß† NPU-BILDVERARBEITUNG: Parallel zur Hash-Pipeline (immer zus√§tzlich, niemals als Ersatz)
    if (npuEnabled && hashEngine && hashEngine->isNpuAvailable() && !imageFiles.isEmpty()) {
        qDebug() << "[Scanner] üöÄ NPU Bildanalyse startet parallel f√ºr" << imageFiles.size() << "Bilder (Hash bleibt aktiv)!";
        emit scanStatusChanged("üß† NPU analysiert Bilder (parallel zur Hash-Berechnung)...");

        // üìä LIVE-Update: NPU-Bildverarbeitung starten
        emit currentFileProcessing(
            QString("%1 Bilder").arg(imageFiles.size()),
            "üß† NPU-Bildverarbeitung (parallel)",
            0,
            imageFiles.size()
        );
        emit processActivityUpdate(
            "üß† Intel NPU analysiert Bilder f√ºr intelligente Duplikat-Erkennung",
            QString("Verarbeite %1 Bilder").arg(imageFiles.size())
        );

        // NPU Feature-Vector Processing f√ºr Bilder (zus√§tzlich; ersetzt NICHT den Content-Hash)
        hashEngine->processImagesWithNpuUltraFast(imageFiles);
        npuProcessedImages = imageFiles.size();

        // üìä FINAL-Update: NPU-Bildverarbeitung abgeschlossen
        emit currentFileProcessing(
            QString("%1 Features extrahiert").arg(npuProcessedImages),
            "üß† NPU-Bildverarbeitung abgeschlossen (parallel)",
            npuProcessedImages,
            imageFiles.size()
        );
        emit processActivityUpdate(
            QString("üß† NPU hat %1 Bilder analysiert (Content-Hash l√§uft weiter)").arg(npuProcessedImages),
            "Intelligente Bildanalyse abgeschlossen"
        );
    }
    
    // Hinweis: Bilder werden weiterhin gehasht, auch wenn NPU parallel lief
    if (npuEnabled && npuProcessedImages > 0) {
        qDebug() << "[Scanner] üß† NPU hat" << npuProcessedImages << "Bilder analysiert (Content-Hashes folgen wie gewohnt)";
    }
    
    // Hash-Berechnung f√ºr alle Dateien (auch Bilder). NPU-Ergebnisse sind zus√§tzlich verf√ºgbar.
    if (!filesToHash.isEmpty()) {
        totalFilesForHashing = filesToHash.size(); // üéØ Setze Gesamt-Anzahl f√ºr Live-Updates
        
        // üìä LIVE-Update: Hash-Berechnung starten
        emit currentFileProcessing(
            QString("%1 Dateien").arg(filesToHash.size()), 
            "üîê Hash-Berechnung", 
            0, 
            filesToHash.size()
        );
        emit processActivityUpdate(
            "üîê Berechne kryptographische Hashes f√ºr Duplikat-Erkennung",
            QString("Verarbeite %1 Dateien").arg(filesToHash.size())
        );
        
        emit hashingStarted(filesToHash.size());
        
        // ‚úÖ KRITISCH: HashEngine √ºber die erwartete Dateianzahl informieren (NACH NPU-Verarbeitung!)
        if (hashEngine) {
            hashEngine->setExpectedFilesCount(filesToHash.size());
            qDebug() << "[Scanner] üìä HashEngine informiert: erwarte" << filesToHash.size() << "Dateien f√ºr Hash-Berechnung (nach NPU)";
        }
        
        hashEngine->calculateMultipleHashes(filesToHash);
    } else {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine Dateien f√ºr die Hash-Berechnung ermittelt (leer)";
        emit scanStatusChanged("‚ö†Ô∏è Keine Dateien zum Hashen gefunden");
        QTimer::singleShot(500, this, &Scanner::compareHashes);
    }
}

void Scanner::onHashCalculated(const QString &filePath, const QString &hash)
{
    if (!scanning.load())
        return;

    // üöÄ THROTTLING: GUI-Updates nur alle 100ms oder bei wichtigen Ereignissen
    static qint64 lastGuiUpdate = 0;
    static int lastDisplayedCount = 0;
    qint64 guiUpdateTime = QDateTime::currentMSecsSinceEpoch();
    bool shouldUpdateGui = false;
    
    // üîß FIX: Member Variable wird sp√§ter aus globalHashedFiles aktualisiert
    int hashCount = currentHashCount.load();
    
    // Update bei: 1) Erster Datei, 2) Alle 100ms, 3) Jeder 10. Datei, 4) Wichtige Ereignisse
    if (hashCount == 1 || 
        (guiUpdateTime - lastGuiUpdate >= 100) ||
        (hashCount % 10 == 0)) {
        shouldUpdateGui = true;
        lastGuiUpdate = guiUpdateTime;
    }

    // üéØ LIVE-DATEINAME-UPDATE: Zeige aktuell verarbeitete Datei in GUI
    QString fileName = QFileInfo(filePath).fileName();
    QString shortPath = filePath;
    
    // üî• ECHTZEIT: Zeige vollst√§ndigen Pfad, aber komprimiert f√ºr GUI
    if (filePath.length() > 80) {
        shortPath = "..." + filePath.right(77);
    }
    
    QString processType = "üîç Hash-Berechnung";
    const bool isNpuHash = hash.startsWith("npv_");
    
    // Unterscheide zwischen NPU und Standard-Hash
    if (isNpuHash) {
        processType = "ü§ñ NPU-Bildanalyse";
    } else if (hash.startsWith("md5_")) {
        processType = "üîê MD5-Hash";
    } else if (hash.startsWith("sha256_")) {
        processType = "üîê SHA256-Hash";
    } else if (filePath.startsWith("ftp://")) {
        processType = "üì° FTP-Hash (Stream)";
    } else {
        processType = "üîç Lokale Hash-Berechnung";
    }
    
    // üî• ECHTZEIT-STATUS-UPDATE: Zeige Pfad + Aktivit√§t in GUI (throttled)
    if (shouldUpdateGui) {
        emit scanStatusChanged(QString("%1: %2").arg(processType, shortPath));
    }
    
    // Ô∏è SICHERUNG: Verhindere Doppelbearbeitung bereits berechneter Hashes
    // WICHTIG: NPU-Hashes (npv_*) sind zus√§tzlich und d√ºrfen den Content-Hash NICHT ersetzen.
    // Daher markieren wir Dateien nur als gehasht, wenn es sich NICHT um einen NPU-Hash handelt.
    if (globalHashedFiles.contains(filePath)) {
        if (isNpuHash) {
            qDebug() << "[Scanner] ‚ÑπÔ∏è NPU-Zusatzhash ignoriert f√ºr bereits verarbeitete Datei:" << filePath.right(50);
            return; // Zusatzinfo, Content-Hash bleibt ma√ügeblich
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è Content-Hash bereits registriert f√ºr:" << filePath.right(50);
            return;
        }
    }
    
    // üö® MEMORY PROTECTION: Prevent QSet overflow crash
    // üîß FIX: DEAKTIVIERT - Das Leeren des Cache f√ºhrt zu Timeout-Problemen!
    // Das Leeren bei 20K resettet den Progress-Counter auf 0 und triggert f√§lschlicherweise einen Timeout.
    // QSet mit 100K+ Eintr√§gen ist auf modernen Systemen kein Problem (nur ~8MB RAM bei QString-Pfaden).
    /*
    if (globalHashedFiles.size() > 20000) {
        qWarning() << "[Scanner] üö® QSet zu gro√ü (" << globalHashedFiles.size() << ") - leere Cache f√ºr Stabilit√§t";
        globalHashedFiles.clear();
        globalProcessedFiles.clear();
    }
    */
    
    // Nur Content-Hashes z√§hlen f√ºr den Abschluss/Progress
    if (!isNpuHash) {
        globalHashedFiles.insert(filePath);
    }

    // üìä KORREKTER PROGRESS-COUNTER: Nutze Member-Variable (thread-safe atomic)
    currentHashCount.store(globalHashedFiles.size()); // Update member variable
    int progressPercent = totalFilesForHashing > 0 ? (currentHashCount.load() * 100) / totalFilesForHashing : 0;
    
    
    if (shouldUpdateGui) {
        // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI mit korrekten Z√§hlern
        int hashCount = currentHashCount.load();
        emit currentFileProcessing(fileName, processType, hashCount, totalFilesForHashing);
        emit processActivityUpdate(processType, QString("Verarbeite: %1 (%2/%3)").arg(fileName).arg(hashCount).arg(totalFilesForHashing));
        emit scanProgress(progressPercent, hashCount, totalFilesForHashing);
        
        qDebug() << "[Scanner] üìä GUI-Update:" << processType << fileName << QString("(%1/%2)").arg(hashCount).arg(totalFilesForHashing);
    }

    qDebug() << "[Scanner] üìä Hash berechnet f√ºr:" << filePath.right(50) << "‚Üí" << hash.left(16) << QString("(%1/%2)").arg(hashCount).arg(totalFilesForHashing);

    // üö® PHANTOM-WARNUNG: Informiere User wenn erste 100 Dateien fast alle Phantoms sind
    static int phantomCount = 0;
    static int realFileCount = 0;
    static bool phantomWarningShown = false;
    
    if (!phantomWarningShown) {
        bool isPhantom = hash.startsWith("FTP_STREAM_FAILED_") || 
                        hash.startsWith("FTP_") || 
                        hash.startsWith("ERROR_") || 
                        hash.startsWith("FAILED_") ||
                        hash == "FTP_SKIPPED" ||
                        hash == "FTP_NO_DATA_RECEIVED";
        
        if (isPhantom) {
            phantomCount++;
        } else {
            realFileCount++;
        }
        
        int totalChecked = phantomCount + realFileCount;
        
        // Nach 100 Dateien pr√ºfen
        if (totalChecked >= 100) {
            phantomWarningShown = true;
            
            // Wenn 95%+ Phantoms = FTP-Server-Cache-Problem - WARNUNG aber weitermachen!
            if (phantomCount > 95) {
                qWarning() << "[Scanner] ‚ö†Ô∏è FTP-SERVER-CACHE DETECTED: " << phantomCount << "/100 Dateien sind Phantoms!";
                qWarning() << "[Scanner] ‚ÑπÔ∏è Scanne weiter - vielleicht gibt es echte Dateien sp√§ter...";
                
                emit scanStatusChanged("‚ö†Ô∏è Warnung: Viele gel√∂schte Dateien erkannt - Scan l√§uft weiter...");
                
                // NICHT abbrechen - nur warnen!
            } else {
                qDebug() << "[Scanner] ‚úÖ Phantom-Check OK: " << realFileCount << " echte Dateien von 100 gefunden";
            }
            
            // Reset f√ºr n√§chsten Scan
            phantomCount = 0;
            realFileCount = 0;
        }
    }

    // ‚úÖ FIX: Update hash in fileSizeGroups (nicht allFiles - das ist nur eine Kopie)
    bool hashUpdated = false;
    for (auto &group : fileSizeGroups)
    {
        for (FileInfo &file : group)
        {
            if (file.filePath == filePath)
            {
                // üõ°Ô∏è NPU-Hashes nicht als Content-Hash speichern
                if (isNpuHash) {
                    continue; // Lass Content-Hash unber√ºhrt
                }
                // üõ°Ô∏è ZUS√ÑTZLICHE SICHERUNG: Verhindere Hash-√úberschreibung (au√üer wenn vorher leer)
                if (!file.hash.isEmpty() && file.hash != hash) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Hash-Konflikt f√ºr" << filePath.right(50) 
                              << "- Alt:" << file.hash.left(16) << "Neu:" << hash.left(16);
                }
                file.hash = hash;
                hashUpdated = true;
                qDebug() << "[Scanner] ‚úÖ Hash in fileSizeGroups aktualisiert:" << fileName << "‚Üí" << hash.left(16);
                break;
            }
        }
        if (hashUpdated) break;
    }
    
    // üî• KRITISCH: Wenn Datei NICHT in fileSizeGroups - warnen!
    if (!hashUpdated) {
        qWarning() << "[Scanner] ‚ö†Ô∏è DATEI NICHT IN fileSizeGroups:" << filePath.right(80) << "Hash:" << hash.left(16);
        qWarning() << "[Scanner] üêõ Dies f√ºhrt dazu dass Duplikate nicht erkannt werden!";
    }

    // ‚ö° OPTIMIERT: Schnelle Progress-Berechnung mit Early Return
    // ‚úÖ FIX: Verwende m_totalCollectedFiles statt fileSizeGroups zu z√§hlen
    int totalFilesToHash = m_totalCollectedFiles;
    int hashedFilesInGroups = 0;
    
    // üîí THREAD-SAFE: Lock w√§hrend wir fileSizeGroups lesen (Race Condition Fix)
    {
        QMutexLocker locker(&m_fileSizeGroupsMutex);
        
        // Early Return: Wenn keine Dateien gesammelt wurden
        if (totalFilesToHash == 0) {
            emit scanProgress(100, 0, 0); // 100% f√ºr leere Scans
            return;
        }
        
        // Z√§hle nur die GEHASHTEN Dateien
        for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
            const QList<FileInfo> &filesInGroup = groupIt.value();
            for (const FileInfo &file : filesInGroup) {
                if (!file.hash.isEmpty() && 
                    file.hash != "FTP_SKIPPED" && 
                    file.hash != "FTP_DOWNLOAD_FAILED" &&
                    !file.hash.startsWith("FTP_STREAM_FAILED") &&
                    file.hash != "GPU_ERROR") {
                    hashedFilesInGroups++;
                }
            }
        }
    } // Mutex wird hier freigegeben
    
    // ‚úÖ BULLETPROOF: Division-by-Zero Protection + Overflow Protection + DEBUG
    int percentage = 0;
    if (totalFilesToHash > 0) {
        qDebug() << "[Scanner] üîß DIVISION-DEBUG: hashedFiles=" << hashedFilesInGroups 
                 << "totalFiles=" << totalFilesToHash << "vor Division";
        
        // Verhindere Integer-Overflow bei sehr gro√üen Dateizahlen
        if (hashedFilesInGroups > INT_MAX / 100) {
            percentage = (int)((long long)hashedFilesInGroups * 100 / totalFilesToHash);
            qDebug() << "[Scanner] üîß OVERFLOW-PROTECTION: LongLong-Division verwendet";
        } else {
            percentage = (hashedFilesInGroups * 100) / totalFilesToHash;
            qDebug() << "[Scanner] üîß NORMAL-DIVISION: Standard-Division verwendet";
        }
        percentage = qMax(0, qMin(100, percentage)); // Clamp 0-100%
        qDebug() << "[Scanner] üîß RESULT-PERCENTAGE:" << percentage << "%";
    } else {
        qDebug() << "[Scanner] üö® ZERO-DIVISION-AVOIDED: totalFilesToHash=0, percentage=0";
    }
    
    // üöÄ ECHTZEIT PROGRESS: Maximale GUI-Responsivit√§t (16ms = ~60 FPS)
    static int lastEmittedPercentage = -1;
    static qint64 lastEmitTime = 0;
    static int rapidUpdateCount = 0;
    
    qint64 progressTime = QDateTime::currentMSecsSinceEpoch();
    bool shouldEmitProgress = false;
    
    // üéØ ECHTZEIT-MODUS: Sehr schnelle Updates f√ºr fl√ºssige GUI
    int timeDelta = progressTime - lastEmitTime;
    int percentageDelta = abs(percentage - lastEmittedPercentage);
    
    if (percentageDelta >= 1) {
        if (timeDelta >= 16) { // 16ms = 60 FPS f√ºr butterweiche Updates
            shouldEmitProgress = true;
            rapidUpdateCount = 0;
        } else {
            rapidUpdateCount++;
            // Jeder 2. Update bei ultra-schnellen √Ñnderungen (war: jeder 5.)
            if (rapidUpdateCount >= 2) {
                shouldEmitProgress = true;
                rapidUpdateCount = 0;
            }
        }
    }
    
    // Kritische Meilensteine: 0%, 25%, 50%, 75%, 100% - IMMER emittieren
    // Plus: Force-Update alle 500ms (war 1000ms) f√ºr garantierte Echtzeit-Anzeige
    if (percentage == 0 || percentage == 25 || percentage == 50 || 
        percentage == 75 || percentage == 100 || timeDelta >= 500) {
        shouldEmitProgress = true;
    }
    
    if (shouldEmitProgress) {
        emit scanProgress(percentage, hashedFilesInGroups, totalFilesToHash);
        qDebug() << "[Scanner] üìä Hash-Progress (Optimized):" << hashedFilesInGroups 
                 << "/" << totalFilesToHash << "(" << percentage << "%) Œît:" << (progressTime - lastEmitTime) << "ms";
        lastEmittedPercentage = percentage;
        lastEmitTime = progressTime;
    }
    
    
    // ‚úÖ SMARTE ANTI-HANG: Adaptive Stagnation Detection mit Time-based Checks
    static int lastPercentage = -1;
    static int stagnationCount = 0;
    static qint64 stagnationStartTime = 0;
    
    // Wiederverwendung von progressTime f√ºr Stagnation-Detection
    if (percentage == lastPercentage && percentage > 0) {
        if (stagnationCount == 0) {
            stagnationStartTime = progressTime; // Erste Stagnation markieren
        }
        stagnationCount++;
        
        // üî• FIX: Viel l√§ngere Timeouts f√ºr FTP-Downloads (Dateien k√∂nnen mehrere Sekunden brauchen!)
        // Progressive Timeouts: 30s bei 0-50%, 60s bei 50-90%, 120s bei 90-100%
        int timeoutMs = (percentage < 50) ? 30000 : (percentage < 90) ? 60000 : 120000;
        qint64 stagnationDuration = progressTime - stagnationStartTime;
        
        if (stagnationDuration >= timeoutMs && stagnationCount >= 10) { // 10 statt 3 Checks
            qWarning() << "[Scanner] üö® Progress-Stagnation:" << percentage 
                      << "% f√ºr" << stagnationDuration << "ms ‚Üí Smart Force Complete!";
            
            // ‚ö° INTELLIGENTE FORCE COMPLETION: Graduelle Steigerung
            int forcePercentage = qMin(100, percentage + 20); // +20% pro Force-Step
            emit scanProgress(forcePercentage, hashedFilesInGroups, totalFilesToHash);
            
            if (forcePercentage >= 100) {
                // Erstelle minimale Results f√ºr Completion
                DuplicateGroups intelligentResults = buildPartialResults();
                
                // üî• GUARD: Emittiere nur wenn noch nicht emittiert
                if (!m_scanCompletedEmitted.exchange(true)) {
                    emit scanCompleted(intelligentResults);
                    qDebug() << "[Scanner] üî• EMIT scanCompleted (INTELLIGENT) - groups:" << intelligentResults.groups.size();
                }
                return;
            }
            stagnationCount = 0; // Reset f√ºr n√§chsten Force-Step
        }
    } else {
        lastPercentage = percentage;
        stagnationCount = 0; // Reset bei Progress-√Ñnderung
        stagnationStartTime = 0;
    }
    
    // Check if all hashes are calculated (exclude FTP_SKIPPED files)
    bool allHashesReady = (hashedFilesInGroups >= totalFilesToHash && totalFilesToHash > 0);
    
    // ‚úÖ TIMEOUT-SCHUTZ: Force completion nur wenn 95%+ der Dateien fertig sind
    bool forceComplete = (totalFilesToHash > 0 && hashedFilesInGroups >= (totalFilesToHash * 0.95));
    
    if (allHashesReady || forceComplete)
    {
        if (forceComplete && !allHashesReady) {
            qDebug() << "[Scanner] ‚ö†Ô∏è TIMEOUT-SCHUTZ: Erzwinge Completion mit" << hashedFilesInGroups << "/" << totalFilesToHash << "Dateien (95%+)";
        } else {
            qDebug() << "[Scanner] ‚úÖ Alle Hashes berechnet, starte Vergleich";
        }
        
        // üéØ SYNC-FIX: Debounce mit QTimer um sicherzustellen dass ALLE onHashCalculated() callbacks durch sind
        static QTimer* debounceTimer = nullptr;
        if (!debounceTimer) {
            debounceTimer = new QTimer(this);
            debounceTimer->setSingleShot(true);
            connect(debounceTimer, &QTimer::timeout, this, &Scanner::compareHashes);
        }
        
        // Starte/Restarte Timer mit 100ms delay - l√§sst Event-Queue leeren
        debounceTimer->start(100);
        qDebug() << "[Scanner] ‚è±Ô∏è compareHashes() debounced um 100ms verz√∂gert (Event-Queue leeren)";
    }
}

void Scanner::compareHashes()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] üéØ compareHashes() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();
    
    // üîç CACHE-DATEIEN-CHECK: Pr√ºfe ob ALLE Hashes ung√ºltig sind (FTP-Server-Cache-Problem)
    int totalFiles = 0;
    int validHashes = 0;
    for (auto &group : fileSizeGroups) {
        for (const FileInfo &file : group) {
            totalFiles++;
            if (!file.hash.isEmpty() && 
                !file.hash.startsWith("FTP_STREAM_FAILE") &&
                !file.hash.startsWith("FTP_FILE_NOT_FOUND") &&
                !file.hash.startsWith("FTP_HEAD_TIMEOUT")) {
                validHashes++;
            }
        }
    }
    
    qDebug() << "[Scanner] üìä G√ºltige Hashes:" << validHashes << "/" << totalFiles;
    
    // üö® ALLE Hashes ung√ºltig = FTP-Server zeigt Cache-Dateien!
    if (validHashes == 0 && totalFiles > 0) {
        qWarning() << "[Scanner] ‚ö†Ô∏è ALLE Dateien sind Phantoms (FTP-Server-Cache)!";
        emit scanStatusChanged("‚ö†Ô∏è Keine g√ºltigen Dateien gefunden - Server zeigt gel√∂schte Dateien (Cache)");
        
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = totalFiles;
        
        if (!m_scanCompletedEmitted.exchange(true)) {
            emit scanCompleted(emptyResults);
            qDebug() << "[Scanner] üì° scanCompleted emittiert (alle Phantom-Dateien)";
        }
        
        scanning.store(false);
        return;
    }
    
    emit scanStatusChanged("Vergleiche Duplikate (lokal ‚Üî netzwerk)...");
    currentPhase = COMPARING;
    emit comparingStarted();
    
    // üìä LIVE-Update: Duplikat-Vergleich starten
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen").arg(hashGroups.size()), 
        "üîç Duplikat-Vergleich", 
        0, 
        hashGroups.size()
    );
    emit processActivityUpdate(
        "üîç Vergleiche Hashes f√ºr Duplikat-Erkennung",
        QString("Analysiere %1 verschiedene Hash-Gruppen").arg(hashGroups.size())
    );

    // ‚úÖ FIX: Group files by hash from fileSizeGroups (not allFiles)
    int processedGroups = 0;
    int totalValidHashesInGroups = 0;
    int skippedHashes = 0;
    
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt)
    {
        if (!scanning.load())
            return;
            
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup)
        {
            if (file.hash.isEmpty()) {
                skippedHashes++;
                continue;
            }
            if (file.hash.startsWith("npv_")) {
                skippedHashes++;
                continue; // NPU-Feature-Hashes sind Zusatzinfos, nicht f√ºr Content-Duplikate
            }
            if (file.hash == "FTP_SKIPPED" || file.hash == "FTP_DOWNLOAD_FAILED") {
                skippedHashes++;
                continue;
            }
            // üîß CRITICAL: Skip empty/invalid hashes (verhindert ALLE Dateien in einer Gruppe)
            if (file.hash.isEmpty() || 
                file.hash == "FTP_LOGIN_DENIED" || 
                file.hash == "FTP_CONNECTION_FAILED" ||
                file.hash == "FTP_TIMEOUT" ||
                file.hash == "NETWORK_ERROR" ||
                file.hash == "NO_FILENAME" || // HashEngine: Kein Dateiname in URL
                file.hash == "FTP_CREDENTIALS_REQUIRED" ||
                file.hash == "FTP_NO_DATA_RECEIVED" ||
                file.hash.startsWith("ERROR_") || 
                file.hash.startsWith("FAILED_") ||
                file.hash.startsWith("INVALID_") || // INVALID_FTP_URL etc
                file.hash.startsWith("FTP_STREAM_FAILED_") ||
                file.hash.startsWith("GPU_") || // GPU-Fehler
                file.hash.startsWith("NPU_")) {  // NPU-Fehler
                skippedHashes++;
                if (skippedHashes % 100 == 1) { // Nur jeden 100. loggen
                    qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Datei mit ung√ºltigem Hash:" << file.filePath.right(50) << "Hash:" << file.hash;
                }
                continue;
            }
            
            hashGroups[file.hash].append(file);
            totalValidHashesInGroups++;
        }
        
        processedGroups++;
        // ÔøΩ ECHTZEIT-Update: Gruppierungs-Fortschritt (alle 25 statt 100)
        if (processedGroups % 25 == 0) {
            emit currentFileProcessing(
                QString("Gruppe %1").arg(processedGroups), 
                "üîç Hash-Gruppierung", 
                processedGroups, 
                fileSizeGroups.size()
            );
        }
    }
    
    // üìä LIVE-Update: Hash-Gruppierung abgeschlossen
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen erstellt").arg(hashGroups.size()), 
        "üîç Hash-Gruppierung abgeschlossen", 
        fileSizeGroups.size(), 
        fileSizeGroups.size()
    );
    
    // üìä DEBUG: Zeige wichtige Hash-Statistiken
    qDebug() << "[Scanner] üîç HASH-DEBUG:" << hashGroups.size() << "eindeutige Hashes";
    qDebug() << "[Scanner] üìä Verarbeitet:" << totalValidHashesInGroups << "g√ºltige Hashes," << skippedHashes << "√ºbersprungen";
    
    int duplicateGroups = 0;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateGroups++;
            qDebug() << "[Scanner] üîÑ DUPLIKAT-GRUPPE Hash" << it.key().left(8) << "hat" << it.value().size() << "Dateien:";
            for (const FileInfo &file : it.value()) {
                qDebug() << "    -" << (file.isLocal ? "LOCAL" : "FTP") << file.filePath << "(" << file.size << "bytes)";
            }
        }
    }
    qDebug() << "[Scanner] üéØ DUPLIKAT-GRUPPEN gefunden:" << duplicateGroups;
    
    // üî• ECHTZEIT-UPDATE: Zeige gefundene Duplikate SOFORT in GUI
    emit scanStatusChanged(QString("üîç %1 Duplikat-Gruppen gefunden!").arg(duplicateGroups));
    emit currentFileProcessing(
        QString("%1 Duplikat-Gruppen").arg(duplicateGroups),
        "üéØ Duplikate identifiziert",
        duplicateGroups,
        hashGroups.size()
    );

    // Remove unique hashes FIRST, THEN check if empty
    qDebug() << "[Scanner] üßπ Entferne Unikate: Vor Bereinigung" << hashGroups.size() << "Gruppen";
    auto it = hashGroups.begin();
    int removedUniqueGroups = 0;
    while (it != hashGroups.end())
    {
        if (it.value().size() == 1)
        {
            removedUniqueGroups++;
            it = hashGroups.erase(it);
        }
        else
        {
            ++it;
        }
    }
    qDebug() << "[Scanner] üßπ Nach Bereinigung:" << hashGroups.size() << "Duplikat-Gruppen," << removedUniqueGroups << "Unikate entfernt";

    // üì¢ USER-FRIENDLY MESSAGE: Show if no duplicates found AFTER cleanup
    if (hashGroups.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ KEINE DUPLIKATE GEFUNDEN - alle Dateien sind unique!";
        emit scanStatusChanged("‚úÖ Scan abgeschlossen - keine Duplikate gefunden!");
        
        // üî• KRITISCH: Setze totalFiles - Dateien wurden gescannt, nur keine Duplikate gefunden
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = totalValidHashesInGroups; // Anzahl g√ºltiger Hashes = gescannte Dateien
        
        // üî• GUARD: Emittiere nur wenn noch nicht emittiert
        // ‚úÖ FIX: KEIN QTimer - direkte Emission da Hash-Vergleich abgeschlossen ist
        if (!m_scanCompletedEmitted.exchange(true)) {
            emit scanCompleted(emptyResults);
            qDebug() << "[Scanner] üî• EMIT scanCompleted (NO DUPLICATES) - totalFiles:" << emptyResults.totalFiles;
        }
        return; // Beende hier, keine weiteren Vergleiche n√∂tig
    }

    // ‚úÖ NEU: Statistiken f√ºr lokale vs Netzwerk-Duplikate und Hardware-Updates
    int localOnlyGroups = 0;
    int networkOnlyGroups = 0;
    int crossNetworkGroups = 0;
    int duplicatesFound = 0;
    int groupsCreated = 0;
    int currentComparison = 0;
    
    // üéØ HARDWARE-MONITORING: Simuliere Hardware-Nutzung basierend auf Vergleichsaufwand
    auto getHardwareUsage = [&](int currentComparison, int totalComparisonsCalc) {
        // Simuliere unterschiedliche Hardware-Nutzung basierend auf Workload
        QString processingUnit;
        int utilizationPercent = 0;
        QString currentTask;
        
        if (totalComparisonsCalc > 1000) {
            // Gro√üe Datenmenge ‚Üí NPU/GPU
            processingUnit = npuManager ? "NPU (Intel Arc)" : "GPU (OpenCL)";
            utilizationPercent = 70 + (currentComparison % 30); // 70-99% Auslastung
            currentTask = "Parallele Hash-Vergleiche";
        } else if (totalComparisonsCalc > 100) {
            // Mittlere Datenmenge ‚Üí GPU
            processingUnit = "GPU (OpenCL)";
            utilizationPercent = 40 + (currentComparison % 40); // 40-79% Auslastung
            currentTask = "Sequentielle Vergleiche";
        } else {
            // Kleine Datenmenge ‚Üí CPU
            processingUnit = "CPU (Multi-Core)";
            utilizationPercent = 10 + (currentComparison % 30); // 10-39% Auslastung
            currentTask = "Standard-Vergleiche";
        }
        
        return std::make_tuple(processingUnit, utilizationPercent, currentTask);
    };
    
    // Berechne die Gesamtzahl der Vergleiche f√ºr Progress-Updates
    int totalComparisonsCalc = 0;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        int filesInGroup = it.value().size();
        totalComparisonsCalc += (filesInGroup * (filesInGroup - 1)) / 2; // n*(n-1)/2 Vergleiche
    }
    
    qDebug() << "[Scanner] üîç Starte" << totalComparisonsCalc << "Datei-Vergleiche in" << hashGroups.size() << "Hash-Gruppen";
    
    // üéØ LIVE-UPDATE: Hardware-Status zu Beginn
    auto [initialUnit, initialPercent, initialTask] = getHardwareUsage(0, totalComparisonsCalc);
    emit hardwareUsageUpdate(initialUnit, initialPercent, QString("Initialisiere %1").arg(initialTask));
    
    // üöÄ CHUNK-PIPELINE f√ºr Vergleiche: Teile Hash-Gruppen in Chunks auf
    const int COMPARISON_CHUNKS = 30;
    QList<QList<FileInfo>> groupsToCompare;
    
    // Sammle alle Gruppen die verglichen werden m√ºssen
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        const QList<FileInfo> &files = it.value();
        if (files.size() > 1) {
            groupsToCompare.append(files);
        }
    }
    
    int groupsPerChunk = (groupsToCompare.size() + COMPARISON_CHUNKS - 1) / COMPARISON_CHUNKS;
    qDebug() << "[Scanner] üöÄ COMPARISON-CHUNKS:" << COMPARISON_CHUNKS << "Chunks √†" << groupsPerChunk << "Gruppen";
    
    // Teile Gruppen in Chunks
    QList<QList<QList<FileInfo>>> comparisonChunks;
    for (int i = 0; i < COMPARISON_CHUNKS && i * groupsPerChunk < groupsToCompare.size(); ++i) {
        int startIdx = i * groupsPerChunk;
        int endIdx = qMin(startIdx + groupsPerChunk, groupsToCompare.size());
        QList<QList<FileInfo>> chunk;
        for (int j = startIdx; j < endIdx; ++j) {
            chunk.append(groupsToCompare[j]);
        }
        if (!chunk.isEmpty()) {
            comparisonChunks.append(chunk);
        }
    }
    
    qDebug() << "[Scanner] ‚úÖ Aufgeteilt in" << comparisonChunks.size() << "Vergleichs-Chunks";
    
    // Atomics already declared above
    
    // Starte Chunks parallel mit QTimer
    int chunkIndex = 0;
    for (const auto &chunk : comparisonChunks) {
        QTimer::singleShot(chunkIndex * 30, this, [this, chunk, chunkIndex, comparisonChunks, &currentComparison, &groupsCreated, 
                                                     &crossNetworkGroups, &localOnlyGroups, &networkOnlyGroups, totalComparisonsCalc]() {
            qDebug() << "[Scanner] üî• Comparison-Chunk" << (chunkIndex + 1) << "/" << comparisonChunks.size() 
                     << "gestartet mit" << chunk.size() << "Gruppen";
            
            for (const QList<FileInfo> &files : chunk) {
                if (!scanning.load()) return;
                
                groupsCreated++;
                
                // Vergleiche innerhalb der Gruppe
                for (int i = 0; i < files.size(); i++) {
                    for (int j = i + 1; j < files.size(); j++) {
                        if (!scanning.load()) return;
                        
                        int compNum = currentComparison++ + 1;
                        
                        const FileInfo &file1 = files[i];
                        const FileInfo &file2 = files[j];
                        
                        // ÔøΩÔ∏è PERFORMANCE: ProcessEvents nur alle 500 Vergleiche
                        if (compNum % 500 == 0) {
                            QApplication::processEvents();
                        }
                        
                        // ÔøΩüìä LIVE-Update: Detaillierter Datei-Vergleich (nur alle 10)
                        if (compNum % 10 == 0) {
                            emit fileComparisonProgress(
                                QFileInfo(file1.filePath).fileName(),
                                QFileInfo(file2.filePath).fileName(),
                                compNum,
                                totalComparisonsCalc
                            );
                        }
                        
                        // Bestimme Vergleichstyp
                        QString comparisonType;
                        if (file1.isLocal && file2.isLocal) {
                            comparisonType = "Lokal ‚Üî Lokal";
                        } else if (!file1.isLocal && !file2.isLocal) {
                            comparisonType = "Netzwerk ‚Üî Netzwerk";
                        } else {
                            comparisonType = "Lokal ‚Üî Netzwerk";
                            crossNetworkGroups++;
                        }
                        
                        // üìä LIVE-Update: Vergleichsaktivit√§t (nur alle 50)
                        if (compNum % 50 == 0) {
                            emit processActivityUpdate(
                                QString("üîç %1 Vergleich").arg(comparisonType),
                                QString("Vergleiche %1 vs %2").arg(
                                    QFileInfo(file1.filePath).fileName(),
                                    QFileInfo(file2.filePath).fileName()
                                )
                            );
                        }
                        
                        // üìä LIVE-Update: Vergleichs-Progress (nur alle 50)
                        if (compNum % 50 == 0) {
                            emit duplicateDetectionUpdate(
                                compNum,
                                groupsCreated,
                                QString("%1 ‚âà %2").arg(
                                    QFileInfo(file1.filePath).fileName(),
                                    QFileInfo(file2.filePath).fileName()
                                )
                            );
                        }
                        
                        // üöÄ GUI-Update alle 50 Vergleiche
                        if (compNum % 50 == 0) {
                            int percentage = (compNum * 100) / totalComparisonsCalc;
                            emit scanProgressDetailed(
                                percentage,
                                compNum,
                                totalComparisonsCalc,
                                QString("Vergleiche Dateien (%1)").arg(comparisonType)
                            );
                        }
                    }
                }
                
                // Klassifiziere Gruppe
                bool hasLocal = false;
                bool hasNetwork = false;
                for (const FileInfo &file : files) {
                    if (file.isLocal) hasLocal = true;
                    else hasNetwork = true;
                }
                
                if (hasLocal && hasNetwork) {
                    crossNetworkGroups++;
                } else if (hasLocal) {
                    localOnlyGroups++;
                } else {
                    networkOnlyGroups++;
                }
            }
        });
        chunkIndex++;
    }
    
    qDebug() << "[Scanner] üöÄ Alle" << comparisonChunks.size() << "Comparison-Chunks gestartet!";
    
    // üìä Ergebnisse werden in generateResults() erstellt
    generateResults();
}void Scanner::generateResults()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] üéØ generateResults() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();

    emit scanStatusChanged("Generiere Ergebnisse (lokal + netzwerk)...");
    currentPhase = COMPLETED;

    DuplicateGroups results;
    int crossNetworkDuplicates = 0;

    qDebug() << "[Scanner] üìä GENERATERESULTS: Starte mit" << hashGroups.size() << "Hash-Gruppen";
    int processedGroups = 0;
    
    for (const auto &hashGroup : hashGroups)
    {
        processedGroups++;
        qDebug() << "[Scanner] üîç Pr√ºfe Gruppe" << processedGroups << "/" << hashGroups.size() << "mit" << hashGroup.size() << "Dateien";
        if (hashGroup.size() < 2) {
            qDebug() << "[Scanner] ‚è≠Ô∏è √úberspringe Gruppe (nur" << hashGroup.size() << "Datei)";
            continue;
        }

        DuplicateGroup group;
        QList<FileInfo> files = hashGroup;

        // ‚úÖ NEU: Pr√ºfe ob es sich um lokale ‚Üî Netzwerk Duplikate handelt
        bool hasLocal = false;
        bool hasNetwork = false;
        for (const FileInfo &file : files) {
            if (file.isLocal) {
                hasLocal = true;
            } else {
                hasNetwork = true;
            }
        }
        
        if (hasLocal && hasNetwork) {
            crossNetworkDuplicates++;
        }

        // Sort by modification time and prefer local files as originals
        std::sort(files.begin(), files.end(), [](const FileInfo &a, const FileInfo &b)
                  { 
                      // ‚úÖ PRIORIT√ÑT 1: Bevorzuge lokale Dateien als Original (sicherer)
                      if (a.isLocal != b.isLocal) {
                          return a.isLocal > b.isLocal; // Lokale Dateien zuerst
                      }
                      // ‚úÖ PRIORIT√ÑT 2: √Ñlteste Datei als Original (Standard: KEEP_OLDEST)
                      return a.lastModified < b.lastModified; // √Ñlteste zuerst (Original)
                  });

        // First file is original (preferably local), rest are duplicates
        group.original = files.takeFirst();
        group.duplicates = files;
        group.hash = group.original.hash;
        group.size = group.original.size;
        
        // üìÅ ECHTZEIT PARENT/CHILD-ANALYSE: Ermittle Verzeichnis-Hierarchie
        QSet<QString> directories;
        QMap<QString, int> dirFileCounts;
        
        // Extrahiere Parent-Directory f√ºr Original
        QFileInfo originalInfo(group.original.filePath);
        group.original.parentDirectory = originalInfo.absolutePath();
        group.original.topLevelDirectory = extractTopLevelDirectory(group.original.filePath);
        directories.insert(group.original.parentDirectory);
        dirFileCounts[group.original.parentDirectory]++;
        
        // Extrahiere Parent-Directories f√ºr alle Duplikate
        for (FileInfo &duplicate : group.duplicates) {
            QFileInfo dupInfo(duplicate.filePath);
            duplicate.parentDirectory = dupInfo.absolutePath();
            duplicate.topLevelDirectory = extractTopLevelDirectory(duplicate.filePath);
            directories.insert(duplicate.parentDirectory);
            dirFileCounts[duplicate.parentDirectory]++;
        }
        
        // Speichere Verzeichnis-Informationen in Gruppe
        group.affectedDirectories = directories;
        group.directoryFileCounts = dirFileCounts;
        
        // üõ°Ô∏è KONFLIKT-VERMEIDUNG: Automatische Aufl√∂sung bei Parent/Child-Duplikaten
        group.hasParentChildConflict = false;
        QStringList dirList = directories.values();
        
        // Finde Parent/Child-Beziehungen
        QMap<QString, QString> childToParent; // Child -> Parent Mapping
        for (int i = 0; i < dirList.size(); ++i) {
            for (int j = 0; j < dirList.size(); ++j) {
                if (i == j) continue;
                QString dir1 = dirList[i];
                QString dir2 = dirList[j];
                
                // Pr√ºfe ob dir1 ein Child von dir2 ist
                if (dir1.startsWith(dir2 + "/")) {
                    childToParent[dir1] = dir2;
                    group.hasParentChildConflict = true;
                }
            }
        }
        
        // üéØ AUTOMATISCHE KONFLIKT-AUFL√ñSUNG: Behalte nur Duplikate in TIEFEREN Verzeichnissen
        if (group.hasParentChildConflict) {
            qDebug() << "[Scanner] ‚ö†Ô∏è Parent/Child-Konflikt erkannt - Starte automatische Aufl√∂sung";
            
            QList<FileInfo> resolvedDuplicates;
            QFileInfo originalInfo(group.original.filePath);
            QString originalDir = originalInfo.absolutePath();
            
            for (const FileInfo &duplicate : group.duplicates) {
                QFileInfo dupInfo(duplicate.filePath);
                QString dupDir = dupInfo.absolutePath();
                
                // ‚úÖ REGEL 1: Wenn Original in Parent-Dir ist, behalte nur Child-Duplikate
                bool originalIsParent = dupDir.startsWith(originalDir + "/");
                bool duplicateIsParent = originalDir.startsWith(dupDir + "/");
                
                if (originalIsParent) {
                    // Original ist Parent ‚Üí Duplikat ist im Child ‚Üí BEHALTEN (l√∂schbar)
                    resolvedDuplicates.append(duplicate);
                    qDebug() << "[Scanner] ‚úÖ BEHALTEN (Child-Duplikat):" << duplicate.filePath;
                } else if (duplicateIsParent) {
                    // Duplikat ist Parent ‚Üí SCH√úTZEN (nicht l√∂schbar, mache es zum Original)
                    qDebug() << "[Scanner] üõ°Ô∏è GESCH√úTZT (Parent-Duplikat ‚Üí wird neues Original):" << duplicate.filePath;
                    // Tausche Original und Duplikat
                    FileInfo newOriginal = duplicate;
                    resolvedDuplicates.append(group.original); // Altes Original wird Duplikat
                    group.original = newOriginal;
                } else {
                    // Keine direkte Parent/Child-Beziehung zwischen Original und Duplikat
                    // Pr√ºfe ob beide Siblings (gleiche Hierarchie-Ebene) sind
                    int originalDepth = originalDir.count('/');
                    int dupDepth = dupDir.count('/');
                    
                    if (originalDepth == dupDepth) {
                        // Gleiche Ebene ‚Üí Beides l√∂schbar
                        resolvedDuplicates.append(duplicate);
                        qDebug() << "[Scanner] ‚úÖ BEHALTEN (Sibling-Duplikat):" << duplicate.filePath;
                    } else if (dupDepth > originalDepth) {
                        // Duplikat ist tiefer ‚Üí l√∂schbar
                        resolvedDuplicates.append(duplicate);
                        qDebug() << "[Scanner] ‚úÖ BEHALTEN (tiefer als Original):" << duplicate.filePath;
                    } else {
                        // Duplikat ist h√∂her in Hierarchie ‚Üí SCH√úTZEN
                        qDebug() << "[Scanner] üõ°Ô∏è GESCH√úTZT (h√∂her als Original):" << duplicate.filePath;
                        FileInfo newOriginal = duplicate;
                        resolvedDuplicates.append(group.original);
                        group.original = newOriginal;
                    }
                }
            }
            
            // Ersetze Duplikate-Liste mit aufgel√∂ster Version
            group.duplicates = resolvedDuplicates;
            
            qDebug() << "[Scanner] ‚úÖ Konflikt aufgel√∂st:" << group.duplicates.size() << "sichere Duplikate markiert";
        }
        
        // üìä ECHTZEIT-LOG: Verzeichnis-Hierarchie-Info (nur alle 10 Gruppen)
        if (processedGroups % 10 == 0) {
            qDebug() << "[Scanner] üìÅ Gruppe" << processedGroups << "betrifft" << directories.size() 
                     << "Verzeichnisse, Konflikt:" << (group.hasParentChildConflict ? "AUFGEL√ñST" : "NEIN");
        }

        results.groups.append(group);
        results.duplicateFiles += group.duplicates.size();
        results.duplicateSize += group.size * group.duplicates.size();
    }

    results.totalFiles = allFiles.size();

    scanning.store(false);
    currentPhase = IDLE;

    // ‚úÖ DEBUG: Detaillierte Ergebnis-Analyse
    qDebug() << "[Scanner] üìä FINALE STATISTIKEN:";
    qDebug() << "    - Verarbeitete Dateien:" << results.totalFiles;
    qDebug() << "    - Duplikat-Gruppen:" << results.groups.size();
    qDebug() << "    - Duplikat-Dateien:" << results.duplicateFiles;
    qDebug() << "    - Gesparte Gr√∂√üe:" << (results.duplicateSize / (1024*1024)) << "MB";

    std::cout << "‚úÖ Parallel-Scan abgeschlossen: " << results.groups.size()
              << " Duplikat-Gruppen mit " << results.duplicateFiles << " Duplikaten" << std::endl;
    std::cout << "   üîÑ Lokal ‚Üî Netzwerk Duplikate: " << crossNetworkDuplicates << " Gruppen" << std::endl;
    
    // üîê SPEICHERE SCAN-HISTORY nach erfolgreichem Scan
    for (const FileInfo &file : allFiles) {
        addToScanHistory(file.filePath, false);
    }
    saveScanHistory();
    qDebug() << "[Scanner] üíæ Scan-History gespeichert:" << allFiles.size() << "neue Dateien";

    // Benutzerfreundliche Status-Nachricht basierend auf Ergebnis
    if (results.groups.empty()) {
        emit scanStatusChanged("‚úÖ Scan abgeschlossen - keine Duplikate gefunden!");
    } else {
        emit scanStatusChanged(QString("‚úÖ Scan abgeschlossen - %1 Duplikat-Gruppen mit %2 Duplikaten gefunden")
                              .arg(results.groups.size())
                              .arg(results.duplicateFiles));
    }
    
    // üî• GUARD: Emittiere nur wenn noch nicht emittiert
    if (!m_scanCompletedEmitted.exchange(true)) {
        emit scanCompleted(results);
        qDebug() << "[Scanner] üî• EMIT scanCompleted (NORMAL) - groups:" << results.groups.size() 
                 << "totalFiles:" << results.totalFiles;
    }
}

void Scanner::onFtpFilesReceived(const QString &directory, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üìÑ FTP-Dateien empfangen f√ºr:" << directory << "Files:" << files.size() << "Success:" << success;
    
    // üéØ SOFORTIGE QUEUE-INFO: Emittiere BEVOR fr√ºhe returns passieren!
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    int completedDirs = completedFtpDirectories.size();
    QString ftpProgressWithQueue = QString("FTP %1/%2").arg(completedDirs).arg(totalFtpDirs);
    if (pendingFtpDirectories.size() > 0) {
        ftpProgressWithQueue += QString(" | Verbleibend: %1").arg(pendingFtpDirectories.size());
    }
    
    qDebug() << "[Scanner] üéØ EMIT currentFileProcessing (SLOT1):" << ftpProgressWithQueue << "(" << completedDirs << "/" << totalFtpDirs << ")";
    
    emit currentFileProcessing(
        ftpProgressWithQueue,  // ‚úÖ Mit Queue-Info f√ºr GUI!
        "üì° FTP-Scan l√§uft",
        completedDirs,
        totalFtpDirs
    );
    
    if (!success) {
        qWarning() << "[Scanner] ‚ö†Ô∏è FTP-Fehler beim Laden von:" << directory;
        return;
    }
    
    // üõ°Ô∏è KRITISCHER SICHERHEITSCHECK: Verhindere QHash-Crash bei sehr gro√üen Datens√§tzen
        if (files.size() > 25000) {
        qDebug() << "[Scanner] üö® KRITISCH: Zu viele Dateien (" << files.size() << ") - Chunked Processing aktiviert";
            // Versuche die vollst√§ndige FTP-URL f√ºr dieses Verzeichnis zu ermitteln
            QString baseUrl = directory;
            if (!baseUrl.startsWith("ftp://")) {
                // Aufl√∂sen anhand pendingFtpDirectories
                auto normalizePath = [](QString p) {
                    if (p.isEmpty()) return p;
                    if (!p.startsWith('/')) p.prepend('/');
                    if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                    return p;
                };
                const QString dirNorm = normalizePath(directory);
                for (const QString &pendingUrl : pendingFtpDirectories) {
                    QUrl url(pendingUrl);
                    const QString pendNorm = normalizePath(url.path());
                    if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                        baseUrl = pendingUrl;
                        break;
                    }
                }
            }
            processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    if (files.size() > 100000) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Zu viele Dateien (" << files.size() << ") - √ºberspringe zur Sicherheit";
        pendingFtpDirectories.remove(directory); // ‚úÖ FIX: QSet verwendet remove()
        checkScanProgress();
        return;
    }
    
    // üß† NPU-BILDVERARBEITUNG: F√ºr gro√üe Bilddatens√§tze optimiert
    // üöÄ PRODUCTION NPU: Aktiviert f√ºr mittlere bis gro√üe Bilddatens√§tze (>1.000 Dateien)
    if (files.size() > 1000 && npuManager) {  // NPU aktiviert ab 1.000 Dateien
        qDebug() << "[Scanner] üöÄ ULTRA-FAST NPU aktiviert f√ºr" << files.size() << "Dateien";
        
        // üé® Filtere ALLE Bilddateien f√ºr Ultra-Fast NPU-Verarbeitung (inkl. RAW)
        QStringList imageFiles;
        for (const QString &file : files) {
            if (file.endsWith(".jpg", Qt::CaseInsensitive) || 
                file.endsWith(".jpeg", Qt::CaseInsensitive) ||
                file.endsWith(".png", Qt::CaseInsensitive) ||
                file.endsWith(".gif", Qt::CaseInsensitive) ||
                file.endsWith(".cr2", Qt::CaseInsensitive) ||  // Canon RAW
                file.endsWith(".nef", Qt::CaseInsensitive) ||  // Nikon RAW
                file.endsWith(".arw", Qt::CaseInsensitive) ||  // Sony RAW
                file.endsWith(".dng", Qt::CaseInsensitive) ||  // Adobe RAW
                file.endsWith(".tiff", Qt::CaseInsensitive) || // TIFF
                file.endsWith(".bmp", Qt::CaseInsensitive)) {  // Bitmap
                imageFiles.append(file);
            }
        }
        
        qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "Bilder f√ºr NPU-Verarbeitung";
        
        if (imageFiles.size() > 50) {  // üöÄ SOFORTIGE NPU-AKTIVIERUNG bei 50+ Bildern
            qDebug() << "[Scanner] üöÄ NPU-ONLY Bildverarbeitung f√ºr" << imageFiles.size() << "Bilder (KEINE Hash-Methode)";
            
            // üß† NPU FEATURE-VECTOR-BASIERTE DUPLIKATERKENNUNG (ERSETZT Hash-basiert)
            qDebug() << "[Scanner] üß† Starte NPU Feature-Vector-Analyse (Hash-frei)...";
            QStringList processedImages = npuManager->processImagesWithNpuUltraFast(imageFiles);
            
            // üéØ Feature-Vector-Duplikate finden (OHNE Hash-Vergleich!)
            QList<QStringList> featureBasedDuplicates = npuManager->findFeatureBasedDuplicates(processedImages);
            
            qDebug() << "[Scanner] ‚úÖ NPU-Feature-Duplikate gefunden:" << featureBasedDuplicates.size() << "Gruppen";
            qDebug() << "[Scanner] üöÄ NPU-ONLY Verarbeitung abgeschlossen:" 
                     << processedImages.size() << "Bilder ohne Hash-Methode";
                     
            // üìä NPU-Counter setzen f√ºr Hash-Pipeline-Skip
            npuProcessedImages = imageFiles.size();
            qDebug() << "[Scanner] üéØ NPU-Counter gesetzt:" << npuProcessedImages << "verarbeitete Bilder";
                     
            // üìä NPU-Aktivit√§ts-Update f√ºr GUI
            emit npuActivityUpdate(imageFiles.size(), featureBasedDuplicates.size());
            
            // üöÄ WICHTIG: Entferne verarbeitete Bilder aus der Hash-Pipeline
            // ‚ö†Ô∏è FIX: Erstelle lokale Kopie da `files` const ist
            QStringList remainingFiles = files;
            for (const QString &img : imageFiles) {
                remainingFiles.removeAll(img);
            }
            qDebug() << "[Scanner] üéØ BILDER aus Hash-Pipeline entfernt:" << imageFiles.size() << "Dateien";
            qDebug() << "[Scanner] üìä Verbleibende Dateien f√ºr Hash-Verarbeitung:" << remainingFiles.size();
            
        } else {
            qDebug() << "[Scanner] üìä Zu wenig Bilder f√ºr NPU-Batch (" << imageFiles.size() << "/50) - verwende Hash-basierte Einzelverarbeitung";
        }
    }
    
    // üß† MEMORY-PROTECTION: F√ºr sehr gro√üe Datens√§tze (>25.000 Dateien) Batch-Verarbeitung
    if (files.size() > 25000) {
        qDebug() << "[Scanner] üß† MEMORY-PROTECTION: Aktiviere Batch-Verarbeitung f√ºr" << files.size() << "Dateien";
        // directory kann Pfad oder vollst√§ndige URL sein; vereinheitlichen
        QString baseUrl = directory;
        if (!baseUrl.startsWith("ftp://")) {
            auto normalizePath = [](QString p) {
                if (p.isEmpty()) return p;
                if (!p.startsWith('/')) p.prepend('/');
                if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                return p;
            };
            const QString dirNorm = normalizePath(directory);
            for (const QString &pendingUrl : pendingFtpDirectories) {
                QUrl url(pendingUrl);
                const QString pendNorm = normalizePath(url.path());
                if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                    baseUrl = pendingUrl;
                    break;
                }
            }
        }
        processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    // Find the full FTP URL for this directory path (robust against trailing slashes)
    QString fullFtpUrl;
    auto normalizePath = [](QString p) {
        if (p.isEmpty()) return p;
        // Ensure path starts with '/'
        if (!p.startsWith('/')) p.prepend('/');
        // Remove single trailing '/'
        if (p.length() > 1 && p.endsWith('/')) p.chop(1);
        return p;
    };
    const QString dirNorm = normalizePath(directory);
    for (const QString &pendingUrl : pendingFtpDirectories) {
        QUrl url(pendingUrl);
        const QString pendNorm = normalizePath(url.path());
        if (pendNorm == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
        // Also allow match if directory had an extra '/' when emitted
        if (normalizePath(url.path() + "/") == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
    }
    
    if (fullFtpUrl.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Keine entsprechende FTP-URL gefunden f√ºr:" << directory;
        return;
    }
    
    // Extract host from full FTP URL for file path construction
    QUrl ftpUrl(fullFtpUrl);
    QString host = ftpUrl.host();
    QString basePath = ftpUrl.path();
    // Normalize basePath to '/path' without trailing '/'
    if (!basePath.startsWith('/')) basePath.prepend('/');
    if (basePath.length() > 1 && basePath.endsWith('/')) basePath.chop(1);
    
    // Add all files to allFiles list
    QSet<QString> processedFileNames; // üöÄ Prevent size-variant duplicates
    
    for (const QString &encodedFile : files) {
        // ‚úÖ FIX: Parse encoded "path/filename|size" format (now with FULL PATH from recursive scan!)
        QStringList parts = encodedFile.split('|');
        QString fullFilePath = parts.size() > 0 ? parts[0] : encodedFile; // JETZT mit vollst√§ndigem Pfad!
        qint64 fileSize = parts.size() > 1 ? parts[1].toLongLong() : 0;
        
        // üîß CRITICAL FIX: Bereinige kaputte Pfade mit ///
        // Beispiel: /share/Jan/Jana/mix von t.g///share/Jan/naker/Musik/file.mp3
        // Problem: Doppelte Pfade durch rekursiven Scan
        // L√∂sung: Nimm nur den letzten Teil nach dem letzten ///
        if (fullFilePath.contains("///")) {
            QStringList pathParts = fullFilePath.split("///");
            fullFilePath = pathParts.last(); // Nur der echte Pfad
            
            // ‚úÖ FIX: Ensure path starts with / for valid FTP URL
            if (!fullFilePath.startsWith('/')) {
                fullFilePath = "/" + fullFilePath;
            }
            
            qDebug() << "[Scanner] üîß Bereinigter FTP-Pfad:" << fullFilePath;
        }
        
        // Extrahiere nur den Dateinamen f√ºr Duplikat-Check
        QString fileName = fullFilePath;
        if (fullFilePath.contains('/')) {
            fileName = fullFilePath.mid(fullFilePath.lastIndexOf('/') + 1);
        }
        
        // üöÄ CRITICAL FIX: Skip if we already processed this filename (prevent size variants)
        if (processedFileNames.contains(fileName)) {
            qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Gr√∂√üen-Variante:" << fileName;
            continue;
        }
        processedFileNames.insert(fileName);
        
        // ‚úÖ URL-KODIERUNG: Spaces und Sonderzeichen f√ºr FTP-URLs kodieren
        QString encodedFullPath = QUrl::toPercentEncoding(fullFilePath);
        
        // ‚úÖ CRITICAL FIX: Ensure encoded path starts with / if not already
        if (!encodedFullPath.startsWith('/')) {
            encodedFullPath = "/" + encodedFullPath;
        }
        
        FileInfo fileInfo;
        // üîÑ NEU: Verwende vollst√§ndigen Pfad (rekursiv von FtpClient)
        // ‚úÖ CRITICAL FIX: Add / between port and path in FTP URL
        fileInfo.filePath = QString("ftp://%1:21/%2").arg(host, encodedFullPath.startsWith('/') ? encodedFullPath.mid(1) : encodedFullPath);
        fileInfo.fileName = fileName; // Nur Dateiname f√ºr Anzeige
        fileInfo.size = fileSize; // ‚úÖ FIX: Use real file size from FTP LIST
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = "";
        fileInfo.isLocal = false; // ‚úÖ NEU: Markiere als Netzwerk-Datei
        fileInfo.networkType = "FTP"; // ‚úÖ NEU: Netzwerk-Typ
        
        allFiles.append(fileInfo);
        qDebug() << "[Scanner] ‚úÖ Added FTP file (REKURSIV):" << fileInfo.filePath << "Size:" << fileSize << "bytes";
    }
    
    // ‚úÖ CRITICAL FIX: Remove directory from pending list
    pendingFtpDirectories.remove(directory);
    
    // Mark this directory as completed
    completedFtpDirectories.append(directory);
    ftpDirectoriesProcessed++;
    
    // ‚úÖ NEU: Z√§hle lokale und FTP-Dateien separat f√ºr bessere Anzeige
    int localFiles = 0;
    int ftpFiles = 0;
    for (const FileInfo &file : allFiles) {
        if (file.isLocal) {
            localFiles++;
        } else {
            ftpFiles++;
        }
    }
    
    emit scanStatusChanged(QString("Parallel: Lokal %1, FTP %2/%3 (%4 Dateien)")
                          .arg(localFiles)
                          .arg(ftpDirectoriesProcessed)
                          .arg(pendingFtpDirectories.size())
                          .arg(ftpFiles));
    
    // ‚úÖ UNIFIED LOGIC: Use checkScanProgress() instead of duplicate check
    qDebug() << "[Scanner] üìä onFtpFilesReceived abgeschlossen f√ºr" << directory << "- pr√ºfe Gesamtfortschritt";
    checkScanProgress();
}

void Scanner::collectFtpFiles(const QString &ftpDirectory, QSet<QString> &processedFiles, bool isFromQueue)
{
    // üîß NORMALIZE URL at entry: Always include port for consistent comparison throughout function
    QUrl normalizedEntryUrl(ftpDirectory);
    if (normalizedEntryUrl.port() == -1) {
        normalizedEntryUrl.setPort(21);  // Add default FTP port if missing
    }
    QString normalizedFtpDir = normalizedEntryUrl.toString();  // Use this throughout function
    
    qDebug() << "[Scanner] üì° FTP-Optimiert: Sammle Dateien f√ºr:" << normalizedFtpDir;
    
    // üéØ PROGRESS UPDATE: Zeige aktuelles Verzeichnis sofort!
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    int completedDirs = completedFtpDirectories.size();
    emit currentFileProcessing(
        QString("FTP-Verzeichnis %1/%2 | Verbleibend: %3").arg(completedDirs).arg(totalFtpDirs).arg(pendingFtpDirectories.size()),
        "üì° Lade Netzwerk-Dateien",
        completedDirs,
        totalFtpDirs
    );
    
    // ‚ö° PERFORMANCE: Cache f√ºr gro√üe Datens√§tze 
    static QHash<QString, QStringList> ftpFileCache;
    static QDateTime lastCacheUpdate;
    
    // üßπ AGGRESSIVE CACHE-INVALIDIERUNG: Bei neuem Scan IMMER Cache leeren!
    static bool cacheClearedForThisScan = false;
    if (!cacheClearedForThisScan) {
        qDebug() << "[Scanner] üßπ Leere FTP-File-Cache bei Scan-Start (erzwinge frische Server-Daten)";
        ftpFileCache.clear();
        lastCacheUpdate = QDateTime(); // Reset timestamp
        cacheClearedForThisScan = true;
        
        // Reset bei Scan-Ende
        QTimer::singleShot(1000, []() { cacheClearedForThisScan = false; });
    }
    
    // Cache-Check: Verwende gecachte Daten wenn < 5 Min alt (aber nur wenn nicht gerade geleert!)
    if (ftpFileCache.contains(normalizedFtpDir) && 
        lastCacheUpdate.secsTo(QDateTime::currentDateTime()) < 300) {
        qDebug() << "[Scanner] ‚ö° FTP-Cache-Hit f√ºr:" << normalizedFtpDir;
        processCachedFtpFiles(normalizedFtpDir, ftpFileCache[normalizedFtpDir], processedFiles);
        return;
    }
    
    // Extract IP and path from FTP URL: ftp://192.168.1.224/sdb/Comedy/
    QUrl ftpUrl(normalizedFtpDir);
    if (!ftpUrl.isValid()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltige FTP-URL:" << normalizedFtpDir;
        return;
    }
    QString host = ftpUrl.host();
    QString path = ftpUrl.path();
    if (host.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger FTP-Pfad (Host leer):" << normalizedFtpDir;
        return;
    }
    if (path.isEmpty()) path = "/"; // ensure non-empty directory path
    
    // ‚ö° OPTIMIERT: Wiederverwendung bestehender FTP-Connections
    FtpClient *urlSpecificClient = getOrCreateFtpClient(host);
    if (!urlSpecificClient) {
        qCritical() << "[Scanner] ‚ùå Konnte keinen FTP-Client erstellen f√ºr Host:" << host;
        return;
    }
    
    // ‚úÖ BULLETPROOF: PresetManager Null-Check mit Fallback
    if (!presetManager) {
        qCritical() << "[Scanner] ‚ùå FATAL: PresetManager null! Verwende Default-Credentials";
        useDefaultFtpCredentials(urlSpecificClient, host);
    } else {
        // Hole Credentials aus PresetManager f√ºr gespeicherte Logins
        LoginData login = presetManager->getLogin(host, 21);
        if (!login.isValid()) {
            qWarning() << "[Scanner] ‚ö†Ô∏è Keine Login-Daten f√ºr" << host << ":21 ‚Üí Verwende Default";
            useDefaultFtpCredentials(urlSpecificClient, host);
        } else {
            qDebug() << "[Scanner] üîê Verwende Credentials:" << login.username << "f√ºr" << host;
            urlSpecificClient->setCredentials(host, 21, login.username, login.password);
        }
    }
    
    // üéØ REDUNDANCY CHECK: Pr√ºfe ob ein Child-Verzeichnis dieses Parent bereits ersetzt
    QString normalizedFtp = normalizedFtpDir;
    if (normalizedFtp.endsWith('/') && normalizedFtp.length() > 1) {
        normalizedFtp.chop(1);
    }
    
    // Pr√ºfe gegen alle bereits pending FTP-Verzeichnisse
    for (const QString &existingFtp : pendingFtpDirectories) {
        QString normalizedExisting = existingFtp;
        if (normalizedExisting.endsWith('/') && normalizedExisting.length() > 1) {
            normalizedExisting.chop(1);
        }
        
        // Ist das neue Verzeichnis ein PARENT des existierenden? ‚Üí Skip!
        if (normalizedExisting.startsWith(normalizedFtp + "/")) {
            qDebug() << "[Scanner] üö´ REDUNDANT: FTP-Parent √ºbersprungen (Child bereits ausgew√§hlt)";
            return;
        }
        
        // Ist das neue Verzeichnis ein CHILD des existierenden? ‚Üí Entferne Parent!
        if (normalizedFtp.startsWith(normalizedExisting + "/")) {
            // üî• CRITICAL MEMORY-FIX: Parent-Removal KOMPLETT DEAKTIVIERT!
            // removeAll() auf gro√üen Listen (10k+) verursacht std::bad_alloc Crash
            // Lieber redundante Scans als Memory-Crash bei 99% Completion!
            qDebug() << "[Scanner] ‚è≠Ô∏è Parent-Child erkannt, aber Skip Removal (Memory-Schutz)";
            // Falls Parent bereits aktiv scannt, werden beide gescannt - kein Problem
        }
    }
    
    // Add to pending directories list for tracking; skip duplicate setup if already pending
    bool newlyAdded = false;
    if (!isFromQueue) {
        // Nur bei NEUEN Aufrufen pr√ºfen - aus Queue kommende sind schon pending!
        if (!pendingFtpDirectories.contains(normalizedFtpDir)) {
            pendingFtpDirectories.insert(normalizedFtpDir);
            newlyAdded = true;
        } else {
            qDebug() << "[Scanner] ‚è≠Ô∏è FTP-Verzeichnis bereits pending, √ºberspringe erneute Verbindung:" << normalizedFtpDir;
            return;
        }
    }
    
    ftpActiveHosts.insert(host);
    
    // Verbinde Signal fuer aktuellen Scan-Status
    connect(urlSpecificClient, &FtpClient::filesListFinished,
            this, [this, urlSpecificClient, normalizedFtpDir](const QString &dir, const QStringList &files, bool success) {
        
        // CONNECTION POOLING: Client SOFORT freigeben fuer naechsten Scan
        if (urlSpecificClient) {
            urlSpecificClient->setProperty("busy", false);
        }
        
        qDebug() << "[Scanner] FTP-Dateien empfangen fuer:" << dir << "Files:" << files.size() << "Success:" << success;
        
        if (success) {
            for (const QString &file : files) {
                QString baseFileName = file;
                qint64 fileSize = 0;
                
                if (file.contains("|")) {
                    QStringList fileNameParts = file.split("|");
                    baseFileName = fileNameParts[0];
                    fileSize = fileNameParts[1].toLongLong();
                }
                
                // ‚úÖ CRITICAL FIX: Extract only filename if full path returned
                // FTP LIST may return "/share/Jan/Dir///share/Jan/other/file.mp3"
                if (baseFileName.contains("///")) {
                    // Take last segment after ///
                    baseFileName = baseFileName.split("///").last();
                }
                // Extract filename from path
                if (baseFileName.contains('/')) {
                    baseFileName = baseFileName.mid(baseFileName.lastIndexOf('/') + 1);
                }
                
                QUrl ftpUrl;
                ftpUrl.setScheme("ftp");
                ftpUrl.setHost(QUrl(normalizedFtpDir).host());
                ftpUrl.setPort(21);
                
                // ‚úÖ CRITICAL FIX: Construct path correctly with proper slashes
                QString basePath = QUrl(normalizedFtpDir).path();
                if (!basePath.endsWith('/')) basePath += "/";
                if (!basePath.startsWith('/')) basePath = "/" + basePath;
                
                ftpUrl.setPath(basePath + baseFileName);
                QString fullPath = ftpUrl.toString();
                
                QString canonicalPath = QUrl(fullPath).toString();
                
                // üîí THREAD-SAFE: Lock f√ºr processedFiles Check & Insert
                {
                    QMutexLocker locker(&processedFilesMutex);
                    if (this->processedFiles.contains(canonicalPath)) {
                        continue;
                    }
                    
                    // üöÄ PERFORMANCE: Gro√üe Dateien (>10MB) nur nach GR√ñSSE+NAME vergleichen (kein Hash!)
                    const qint64 maxFileSizeForHashing = 10 * 1024 * 1024; // 10MB = Skip Music/Video Files!
                    if (fileSize > maxFileSizeForHashing) {
                        qDebug() << "[Scanner] ‚ö° FTP-Datei >100MB - nur Size+Name-Vergleich:" << baseFileName << "(" << (fileSize / 1024 / 1024) << "MB)";
                        // ‚úÖ SMART: Gro√üe Dateien nach SIZE+NAME vergleichen (sehr zuverl√§ssig!)
                        // Gleicher Name + Gleiche Gr√∂√üe = Duplikat (z.B. "movie.mkv" 4.7GB)
                        this->processedFiles.insert(canonicalPath);
                        
                        FileInfo ftpFile;
                        ftpFile.filePath = fullPath;
                        ftpFile.fileName = baseFileName;
                        ftpFile.size = fileSize;
                        ftpFile.lastModified = QDateTime::currentDateTime().toSecsSinceEpoch();
                        ftpFile.hash = QString("SIZE_NAME_%1_%2").arg(fileSize).arg(baseFileName.toLower()); // üéØ SIZE+NAME Hash!
                        ftpFile.isLocal = false;
                        ftpFile.networkType = "FTP";
                        
                        allFiles.append(ftpFile);
                        continue; // N√§chste Datei
                    }
                    
                    this->processedFiles.insert(canonicalPath);
                }
                
                FileInfo ftpFile;
                ftpFile.filePath = fullPath;
                ftpFile.fileName = baseFileName;
                ftpFile.size = fileSize;
                ftpFile.lastModified = QDateTime::currentDateTime().toSecsSinceEpoch();
                ftpFile.hash = "";
                ftpFile.isLocal = false;
                ftpFile.networkType = "FTP";
                
                allFiles.append(ftpFile);
            }
        }
        
        pendingFtpDirectories.remove(normalizedFtpDir);
        completedFtpDirectories.append(normalizedFtpDir);
        
        checkScanProgress();
    });
    
    // Starte die FTP-Verbindung und Dateiliste
    urlSpecificClient->connectToHost();
    if (!path.endsWith('/')) path += '/';
    urlSpecificClient->listFiles(path);
    
    qDebug() << "[Scanner] FTP-Collection gestartet fuer" << normalizedFtpDir;
}


void Scanner::checkScanProgress()
{
    qDebug() << "[Scanner] üîç Pr√ºfe Scan-Fortschritt - Pending FTP:" << pendingFtpDirectories.size();
    
    // üìä PROGRESS-UPDATE: FTP-Verarbeitung
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    if (totalFtpDirs > 0) {
        int progressPercent = (completedFtpDirectories.size() * 100) / totalFtpDirs;
        emit scanProgress(progressPercent, completedFtpDirectories.size(), totalFtpDirs);
        
        // üéØ QUEUE-INFO: Zeige verbleibende FTP-Verzeichnisse
        QString ftpProgressText = QString("FTP-Verzeichnis %1/%2").arg(completedFtpDirectories.size()).arg(totalFtpDirs);
        if (pendingFtpDirectories.size() > 0) {
            ftpProgressText += QString(" | Verbleibend: %1").arg(pendingFtpDirectories.size());
        }
        
        emit currentFileProcessing(
            ftpProgressText,  // ‚úÖ Mit Queue-Info!
            "üì° Lade Netzwerk-Dateien",
            completedFtpDirectories.size(),
            totalFtpDirs
        );
    }
    
    // Wenn alle FTP-Operationen abgeschlossen sind, starte die Hash-Berechnung
    if (pendingFtpDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Alle FTP-Verzeichnisse geladen - starte Hash-Berechnung";
        
        // üõë STOP FTP QUEUE DRAIN TIMER: Alle FTP-Scans abgeschlossen
        if (ftpQueueDrainTimer && ftpQueueDrainTimer->isActive()) {
            ftpQueueDrainTimer->stop();
            qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestoppt (alle Scans fertig)";
        }
        
        // ‚úÖ FIX: Group files by size BEFORE starting hash calculation
        emit scanProgress(0, 0, allFiles.size());
        emit scanStatusChanged("üìè Sortiere nach Dateigr√∂√üe...");
        emit currentFileProcessing("Dateigruppierung", "üìè Gr√∂√üen-Filterung", 0, allFiles.size());
        currentPhase = SIZE_FILTERING;

        // Group files by size (required for progress calculation)
        for (const FileInfo &file : allFiles)
        {
            fileSizeGroups[file.size].append(file);
        }
        
        qDebug() << "[Scanner] üìä Size-Groups erstellt:" << fileSizeGroups.size() << "verschiedene Gr√∂√üen f√ºr" << allFiles.size() << "Dateien";
        
        // ÔøΩ SPEICHERE Anzahl gesammelter Dateien f√ºr sp√§tere scanCompleted-Emissionen
        m_totalCollectedFiles = allFiles.size();
        qDebug() << "[Scanner] üìä GESPEICHERT (FTP-Path): m_totalCollectedFiles =" << m_totalCollectedFiles;
        
        // ÔøΩüìä SIZE-FILTERING ABGESCHLOSSEN
        emit scanProgress(100, allFiles.size(), allFiles.size());
        emit scanStatusChanged(QString("üìÅ %1 eindeutige Dateien gesammelt (lokal: ‚úÖ, netzwerk: ‚úÖ)").arg(allFiles.size()));
        emit currentFileProcessing(
            QString("%1 Dateien gruppiert").arg(allFiles.size()),
            "‚úÖ Gr√∂√üen-Filterung abgeschlossen",
            allFiles.size(),
            allFiles.size()
        );
        
        // Start hash calculation phase
        if (!allFiles.isEmpty()) {
            emit scanProgress(0, 0, allFiles.size());
            emit scanStatusChanged("üîê Berechne Hash-Werte...");
            emit currentFileProcessing("Hash-Vorbereitung", "üîê Starte Hash-Berechnung", 0, allFiles.size());
            qDebug() << "[Scanner] üîç Starte Hash-Berechnung f√ºr" << allFiles.size() << "Dateien";
            startHashing();
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è Keine Dateien zum Hashen gefunden";
            emit scanProgress(100, 0, 0);
            emit scanStatusChanged("‚ö†Ô∏è Keine Dateien gefunden - Verzeichnis ist leer oder unzug√§nglich");
            
            // üî• GUARD: Emittiere nur wenn noch nicht emittiert
            if (!m_scanCompletedEmitted.exchange(true)) {
                DuplicateGroups emptyGroups;
                emit scanCompleted(emptyGroups);
                qDebug() << "[Scanner] üî• EMIT scanCompleted (NO FILES) - totalFiles: 0";
            }
        }
    }
}

// üß† NPU-CALLBACK: NPU-Bildverarbeitung abgeschlossen
void Scanner::onNpuImageBatchProcessed(const QStringList &processedImages)
{
    qDebug() << "[Scanner] üé® NPU-Bildverarbeitung abgeschlossen:" << processedImages.size() << "Bilder verarbeitet";
    
    // üéØ LIVE-NPU-UPDATES f√ºr jedes verarbeitete Bild
    for (int i = 0; i < processedImages.size(); ++i) {
        QString imagePath = processedImages.at(i);
        QString fileName = QFileInfo(imagePath).fileName();
        
        // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI senden
        emit currentFileProcessing(fileName, "NPU-Bildanalyse", i + 1, processedImages.size());
        emit processActivityUpdate("NPU-Bildverarbeitung", 
                                   QString("Feature-Extraktion: %1").arg(fileName));
    }
    
    // Statistiken f√ºr NPU-Verarbeitung
    emit scanStatusChanged(QString("üß† NPU-Bildverarbeitung: %1 Bilder analysiert").arg(processedImages.size()));
    
    // üöÄ NPU-AKTIVIT√ÑTS-UPDATE f√ºr Activity-Indicator
    emit npuActivityUpdate(processedImages.size(), 0); // Noch keine Duplikate gefunden
    
    // Hier k√∂nnten wir die NPU-Ergebnisse weiterverarbeiten
    // z.B. f√ºr intelligente Duplikatserkennung basierend auf Bild√§hnlichkeit
}

// üóëÔ∏è FTP-Remove Callback
void Scanner::onFtpRemoveFinished(const QString &remoteFile, bool ok)
{
    deleteAttempted++;
    if (ok) deleteSucceeded++;
    emit deleteProgress(remoteFile, ok, ok ? "FTP gel√∂scht" : "FTP l√∂schen fehlgeschlagen");
    if (deleteAttempted == 0) return; // shouldn‚Äôt happen
}

// üóëÔ∏è Duplikate l√∂schen (Batch)
void Scanner::deleteDuplicateFiles(const QList<FileInfo> &filesToDelete)
{
    deleteAttempted = 0;
    deleteSucceeded = 0;
    for (const auto &fi : filesToDelete) {
        QString msg;
        if (fi.isLocal) {
            bool ok = deleteLocalFile(fi.filePath, msg);
            deleteAttempted++;
            if (ok) deleteSucceeded++;
            emit deleteProgress(fi.filePath, ok, msg);
        } else if (fi.filePath.startsWith("ftp://")) {
            // Sicherheitsnetz: Verzeichnisse nicht l√∂schen
            if (fi.filePath.endsWith('/')) {
                emit deleteProgress(fi.filePath, false, "Verzeichnis-L√∂schen blockiert");
                continue;
            }
            // FTP: Host + Remote Pfad extrahieren
            QUrl u(fi.filePath);
            QString remote = u.path();
            if (remote.startsWith('/')) remote.remove(0,1);
            if (!ftpClient) {
                emit deleteProgress(fi.filePath, false, "Kein FTP-Client verf√ºgbar");
                continue;
            }
            // Anmeldedaten werden vom FtpClient verwaltet; wir rufen remove() auf
            connect(ftpClient, &FtpClient::removeFinished, this, &Scanner::onFtpRemoveFinished, Qt::UniqueConnection);
            ftpClient->remove(remote);
        } else {
            emit deleteProgress(fi.filePath, false, "Unbekannter Netzwerktyp");
        }
    }
    emit deleteBatchFinished(deleteAttempted, deleteSucceeded);
}

// üóëÔ∏è Lokale Datei l√∂schen ‚Üí Papierkorb wenn m√∂glich, sonst hart
bool Scanner::deleteLocalFile(const QString &path, QString &msg)
{
    QFileInfo info(path);
    if (!info.exists() || !info.isFile()) {
        msg = "Nicht gefunden oder keine Datei";
        return false;
    }
    // Versuch: direkt l√∂schen (send2trash w√§re extern, hier Fallback)
    if (QFile::remove(path)) {
        msg = "Gel√∂scht";
        return true;
    }
    msg = "L√∂schen fehlgeschlagen";
    return false;
}

// üõ°Ô∏è NEUE FUNKTION: Deduplication-Caches leeren
void Scanner::clearDeduplicationCaches()
{
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    processedFiles.clear();  // üõ°Ô∏è KRITISCH: Member-Variable auch leeren!
    
    // üßπ ERWEITERTE MEMORY-BEREINIGUNG
    // Nur leeren wenn bereits verarbeitet (nicht w√§hrend aktiver Scan)
    if (!scanning.load()) {
        allFiles.clear();
        allFiles.squeeze(); // Force deallocation
        
        fileSizeGroups.clear();
        hashGroups.clear();
        dateSizeGroups.clear();
        
        extractedFeatures.clear();
        extractedFeatures.squeeze(); // Force deallocation
        
        imageDuplicateGroups.clear();
        imageDuplicateGroups.squeeze(); // Force deallocation
        
        // Directory iterators cleanup
        currentDirIterators.clear();
        
        qDebug() << "[Scanner] üßπ ERWEITERTE Memory-Bereinigung durchgef√ºhrt";
    }
    
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert (inkl. processedFiles)";
}

// üõ°Ô∏è NEUE FUNKTION: Pr√ºfung ob Datei bereits verarbeitet wurde
bool Scanner::isFileAlreadyProcessed(const QString &filePath)
{
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    return globalProcessedFiles.contains(canonicalPath);
}

// üß† MEMORY-SAFE: Batch-Verarbeitung f√ºr gro√üe FTP-Datens√§tze (>25.000 Dateien)
void Scanner::processFtpFilesBatch(const QString &directoryOrUrl, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üß† BATCH-VERARBEITUNG f√ºr" << files.size() << "Dateien gestartet";
    
    const int batchSize = 5000; // 5K Dateien pro Batch
    int totalBatches = (files.size() + batchSize - 1) / batchSize;
    // Ermittele Basis-URL f√ºr korrekte Pfadkonstruktion
    QString baseUrl = directoryOrUrl;
    if (!baseUrl.startsWith("ftp://")) {
        auto normalizePath = [](QString p) {
            if (p.isEmpty()) return p;
            if (!p.startsWith('/')) p.prepend('/');
            if (p.length() > 1 && p.endsWith('/')) p.chop(1);
            return p;
        };
        const QString dirNorm = normalizePath(directoryOrUrl);
        for (const QString &pendingUrl : pendingFtpDirectories) {
            QUrl url(pendingUrl);
            const QString pendNorm = normalizePath(url.path());
            if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                baseUrl = pendingUrl;
                break;
            }
        }
    }
    
    for (int batch = 0; batch < totalBatches; batch++) {
        int startIdx = batch * batchSize;
        int endIdx = qMin(startIdx + batchSize, files.size());
        
        QStringList batchFiles = files.mid(startIdx, endIdx - startIdx);
        qDebug() << "[Scanner] üß† Verarbeite Batch" << (batch + 1) << "/" << totalBatches 
                 << ":" << batchFiles.size() << "Dateien";
        
        // ‚úÖ Direkte Verarbeitung ohne rekursiven Aufruf mit korrekter Basis-URL
        processSingleFtpBatch(baseUrl, batchFiles);
        
        // üõ°Ô∏è Memory-Cleanup zwischen Batches
        if (batch % 2 == 0) { // Every 2nd batch
            clearDeduplicationCaches();
            
            // üßπ AGGRESSIVE Memory-Cleanup f√ºr gro√üe Datens√§tze
            if (batch % 10 == 0 && allFiles.size() > 5000) {
                // Periodisches Memory-Defragmentierung bei gro√üen Datens√§tzen
                allFiles.squeeze();
                qDebug() << "[Scanner] üíæ Aggressive Memory-Defragmentierung bei" << allFiles.size() << "Dateien";
            }
            
            qDebug() << "[Scanner] üßπ Batch-Memory-Cleanup durchgef√ºhrt";
        }
        
        // Kurze Pause zwischen Batches um Memory-Pressure zu reduzieren
        QThread::msleep(50);
    }
    
    // Mark directory as completed after all batches
    pendingFtpDirectories.remove(directoryOrUrl);
    checkScanProgress();
    
    qDebug() << "[Scanner] ‚úÖ BATCH-VERARBEITUNG abgeschlossen:" << totalBatches << "Batches verarbeitet";
}

// üß† MEMORY-SAFE: Einzelner Batch ohne Rekursion
void Scanner::processSingleFtpBatch(const QString &baseUrl, const QStringList &files)
{
    // ‚úÖ Einfache Batch-Verarbeitung ohne komplexe NPU-Logik
    // Einheitliche Gro√üdatei-Politik (FTP): env-basiert
    bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
    qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
    for (const QString &fileName : files) {
        // ‚úÖ Erstelle FileInfo ohne QSet-Overhead
        QString filePath;
        qint64 fileSize = 0;
        
        // Parse file info (name|size format)
        if (fileName.contains('|')) {
            QStringList parts = fileName.split('|');
            QString name = parts[0];
            if (parts.size() > 1) {
                fileSize = parts[1].toLongLong();
            }
            // Einheitliche Gro√üdatei-Politik anwenden
            if (skipLarge && maxSizeMb > 0) {
                qint64 maxBytes = maxSizeMb * 1024 * 1024;
                if (fileSize > maxBytes) {
                    qDebug() << "[Scanner] üö´ GROSSE FTP-Datei √ºbersprungen (Batch) (" << maxSizeMb << "MB):" << name;
                    continue;
                }
            }
            filePath = name;
        } else {
            filePath = fileName;
        }
        
        // ‚úÖ Create FTP FileInfo - extract host from directory context
        FileInfo fileInfo;
        fileInfo.fileName = QFileInfo(filePath).fileName();
        
        // ‚úÖ Proper URL construction: baseUrl is a full FTP URL already
        QString url = baseUrl;
        if (!url.endsWith('/')) url += '/';
        fileInfo.filePath = url + QUrl::toPercentEncoding(fileInfo.fileName);
        
        fileInfo.size = fileSize;
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = "";
        fileInfo.isLocal = false;
        fileInfo.networkType = "FTP";
        
        // ‚úÖ Add to main file list (thread-safe)
        allFiles.append(fileInfo);
    }
    
    qDebug() << "[Scanner] ‚úÖ Batch-Dateien hinzugef√ºgt:" << files.size() << "Total:" << allFiles.size();
}

// üéØ NPU-BILDVERARBEITUNG: Feature-basierte √Ñhnlichkeitsanalyse
void Scanner::startNpuImageAnalysis(const QStringList &imagePaths) {
    if (!npuManager) {
        qWarning() << "[Scanner] ‚ùå NPU-Manager nicht verf√ºgbar - √ºberspringe Bildanalyse";
        return;
    }
    
    qDebug() << "[Scanner] üéØ NPU-Bildanalyse startet f√ºr" << imagePaths.size() << "Bilder";
    emit npuAnalysisProgress("Extrahiere Bildfeatures mit NPU...");
    
    // Extrahiere Features f√ºr alle Bilder
    extractedFeatures = npuManager->extractImageFeatures(imagePaths);
    emit imageFeaturesExtracted(extractedFeatures);
    
    // F√ºhre √Ñhnlichkeitsanalyse durch
    emit npuAnalysisProgress("Analysiere Bild√§hnlichkeiten...");
    processImageFeatures(extractedFeatures);
}

void Scanner::processImageFeatures(const QList<NpuManager::ImageFeature> &features) {
    if (features.isEmpty()) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine g√ºltigen Bildfeatures - √ºberspringe NPU-Analyse";
        return;
    }
    
    qDebug() << "[Scanner] üîç Verarbeite" << features.size() << "Bildfeatures";
    
    // Verwende konfigurierbaren √Ñhnlichkeitsmodus (Standard: NEAR_DUPLICATES)
    QList<NpuManager::NpuDuplicateGroup> npuGroups = npuManager->findSimilarImages(features, currentSimilarityMode);
    
    // Konvertiere NPU-Gruppen zu Scanner-Format
    imageDuplicateGroups.clear();
    for (const auto &npuGroup : npuGroups) {
        ImageDuplicateGroup scannerGroup;
        scannerGroup.originalImage = npuGroup.originalImage;
        scannerGroup.duplicateImages = npuGroup.similarImages;
        scannerGroup.averageSimilarity = npuGroup.avgSimilarity;
        
        // Bestimme Gruppen-Typ basierend auf √Ñhnlichkeit
        if (npuGroup.avgSimilarity >= 0.95f) scannerGroup.groupType = "STRICT";
        else if (npuGroup.avgSimilarity >= 0.85f) scannerGroup.groupType = "NEAR";
        else if (npuGroup.avgSimilarity >= 0.70f) scannerGroup.groupType = "SIMILAR";
        else scannerGroup.groupType = "LOOSE";
        
        imageDuplicateGroups.append(scannerGroup);
    }
    
    qDebug() << "[Scanner] ‚úÖ NPU-Analyse abgeschlossen:" << imageDuplicateGroups.size() << "Bild-Duplikat-Gruppen";
    emit imageDuplicatesFound(imageDuplicateGroups);
}

// Filtere Bilddateien aus allen gefundenen Dateien
QStringList Scanner::filterImageFiles(const QList<FileInfo> &allFiles) {
    QStringList imagePaths;
    QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp"};
    
    for (const FileInfo &file : allFiles) {
        if (isImageFile(file.filePath)) {
            imagePaths.append(file.filePath);
        }
    }
    
    qDebug() << "[Scanner] üñºÔ∏è " << imagePaths.size() << "Bilddateien von" << allFiles.size() << "Dateien gefiltert";
    return imagePaths;
}

// Pr√ºfe ob Datei ein Bild ist
bool Scanner::isImageFile(const QString &filePath) const {
    static QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".svg"};
    
    QString lowerPath = filePath.toLower();
    for (const QString &ext : imageExtensions) {
        if (lowerPath.endsWith(ext)) {
            return true;
        }
    }
    return false;
}

// Kombiniere Hash- und NPU-basierte Ergebnisse
CombinedDuplicateResult Scanner::combineHashAndImageResults() {
    CombinedDuplicateResult combined;
    
    // Hash-basierte Duplikate aus aktuellen Gruppen
    for (const auto &sizeGroup : fileSizeGroups) {
        if (sizeGroup.size() > 1) {
            QHash<QString, QList<FileInfo>> hashMap;
            for (const FileInfo &file : sizeGroup) {
                if (!file.hash.isEmpty()) {
                    hashMap[file.hash].append(file);
                }
            }
            
            for (auto it = hashMap.begin(); it != hashMap.end(); ++it) {
                if (it.value().size() > 1) {
                    DuplicateGroup group;
                    group.hash = it.key();
                    group.size = it.value().first().size;
                    group.original = it.value().first();
                    
                    for (int i = 1; i < it.value().size(); ++i) {
                        group.duplicates.append(it.value()[i]);
                    }
                    
                    combined.hashDuplicates.append(group);
                }
            }
        }
    }
    
    // NPU-basierte Bild-Duplikate hinzuf√ºgen
    combined.imageDuplicates = imageDuplicateGroups;
    
    qDebug() << "[Scanner] üîó Kombinierte Ergebnisse:" << combined.hashDuplicates.size() << "Hash-Gruppen," << combined.imageDuplicates.size() << "Bild-Gruppen";
    return combined;
}

// Erweiterte Duplikatserkennung: Hash + NPU kombiniert
void Scanner::startAdvancedDuplicateDetection() {
    qDebug() << "[Scanner] üöÄ Erweiterte Duplikatserkennung startet (Hash + NPU)";
    
    // Phase 1: Traditionelle Hash-basierte Duplikaterkennung
    emit scanStatusChanged("Berechne File-Hashes...");
    compareHashes();
    
    // Phase 2: NPU-basierte Bild√§hnlichkeitsanalyse
    if (npuManager) {
        QStringList imagePaths = filterImageFiles(allFiles);
        if (!imagePaths.isEmpty()) {
            emit scanStatusChanged("NPU analysiert Bild√§hnlichkeiten...");
            currentSimilarityMode = NpuManager::NEAR_DUPLICATES; // Konfigurierbar
            startNpuImageAnalysis(imagePaths);
        }
    }
    
    // Phase 3: Kombiniere Ergebnisse
    emit scanStatusChanged("Kombiniere Duplikat-Ergebnisse...");
    CombinedDuplicateResult combined = combineHashAndImageResults();
    emit combinedScanCompleted(combined);
}

// Implementierung f√ºr CombinedDuplicateResult::totalDuplicates()
int CombinedDuplicateResult::totalDuplicates() const {
    int total = 0;
    for (const DuplicateGroup &group : hashDuplicates) {
        total += group.duplicates.size();
    }
    for (const ImageDuplicateGroup &group : imageDuplicates) {
        total += group.duplicateImages.size();
    }
    return total;
}

void Scanner::processNextFile()
{
    // No longer used - processing is handled by HashEngine callbacks
    // This method is kept for compatibility but should not be called
    qDebug() << "[Scanner] ‚ö†Ô∏è processNextFile() called - should use HashEngine callbacks instead";
}

// ‚ö° OPTIMIERUNG: Erstelle partielle Results f√ºr Anti-Hang Mechanismus
DuplicateGroups Scanner::buildPartialResults() {
    DuplicateGroups partialResults;
    
    qDebug() << "[Scanner] üîß Erstelle partielle Results f√ºr Anti-Hang...";
    
    // Sammle alle bereits gehashten Dateien mit identischen Hashes
    QHash<QString, QList<FileInfo>> hashGroups;
    
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup) {
            // ‚úÖ KRITISCH: Filtere ALLE Fehler-Hashes (FTP-Phantome, GPU-Fehler, etc.)
            if (!file.hash.isEmpty() && 
                !file.hash.startsWith("FTP_") &&      // Alle FTP-Fehler (FTP_STREAM_FAILED_78, FTP_SKIPPED, etc.)
                !file.hash.startsWith("CURL_") &&     // Alle CURL-Fehler
                !file.hash.startsWith("ERROR_") &&    // Generische Fehler
                !file.hash.startsWith("INVALID_") &&  // Ung√ºltige URLs/Dateien
                !file.hash.startsWith("GPU_") &&      // GPU-Fehler
                !file.hash.startsWith("NPU_")) {      // NPU-Fehler
                hashGroups[file.hash].append(file);
            }
        }
    }
    
    // Erstelle DuplicateGroups aus Hash-Matches
    for (auto hashIt = hashGroups.begin(); hashIt != hashGroups.end(); ++hashIt) {
        const QString &hash = hashIt.key();
        const QList<FileInfo> &files = hashIt.value();
        if (files.size() > 1) {
            DuplicateGroup group;
            group.hash = hash;
            group.size = files.first().size;
            
            // Bestimme Original (√§lteste Datei)
            FileInfo oldest = files.first();
            for (const FileInfo &file : files) {
                if (file.lastModified < oldest.lastModified) {
                    oldest = file;
                }
            }
            
            group.original = oldest;
            for (const FileInfo &file : files) {
                if (file.filePath != oldest.filePath) {
                    group.duplicates.append(file);
                }
            }
            
            if (!group.duplicates.isEmpty()) {
                partialResults.groups.append(group);
            }
        }
    }
    
    // üî• KRITISCH: Berechne Statistiken f√ºr korrekte GUI-Anzeige
    partialResults.totalFiles = hashGroups.size();
    partialResults.duplicateFiles = 0;
    partialResults.duplicateSize = 0;
    
    for (const DuplicateGroup &group : partialResults.groups) {
        partialResults.duplicateFiles += group.duplicates.size();
        partialResults.duplicateSize += group.size * group.duplicates.size();
    }
    
    qDebug() << "[Scanner] ‚úÖ Partielle Results:" << partialResults.groups.size() << "Duplikat-Gruppen erstellt"
             << "Duplikat-Dateien:" << partialResults.duplicateFiles
             << "Gesparte Gr√∂√üe:" << (partialResults.duplicateSize / 1024 / 1024) << "MB";
    return partialResults;
}

// ‚ö° OPTIMIERUNG: Cache-Processing f√ºr FTP-Dateien
void Scanner::processCachedFtpFiles(const QString &ftpDirectory, const QStringList &files, QSet<QString> &processedFiles) {
    qDebug() << "[Scanner] ‚ö° Verarbeite" << files.size() << "gecachte FTP-Dateien f√ºr:" << ftpDirectory;
    
    for (const QString &file : files) {
        // Skip bereits verarbeitete Dateien
        if (processedFiles.contains(file)) continue;
        
        // ‚úÖ KRITISCH: Filter FTP-|size Variants
        if (file.contains("|")) {
            qDebug() << "[Scanner] üîß DUPLIKAT-FIX: Filtere |size variant:" << file;
            continue;
        }
    // FTP cached entries are names, not local paths; build proper URL
    QString fullPath = ftpDirectory;
    if (!fullPath.endsWith('/')) fullPath += '/';
    fullPath += file;

    FileInfo info;
    info.filePath = fullPath;
    info.fileName = file;
    info.size = 0; // unknown from cache (will be set later)
    info.lastModified = QDateTime::currentSecsSinceEpoch();
    info.hash = "";
    info.isLocal = false;
    info.networkType = "FTP";

    // üîí THREAD-SAFE: Lock f√ºr allFiles & processedFiles
    {
        QMutexLocker locker(&processedFilesMutex);
        allFiles.append(info);
        processedFiles.insert(file);
    }
    }
}

// ‚ö° OPTIMIERUNG: FTP-Client Pool f√ºr Connection-Reuse
FtpClient* Scanner::getOrCreateFtpClient(const QString &host, int port, const QString &parentFtpUrl) {
    Q_UNUSED(port);
    Q_UNUSED(parentFtpUrl);
    static QHash<QString, QList<FtpClient*>> clientPool;
    static const int MAX_CLIENTS_PER_HOST = 150;  // üöÄ ULTRA: 150 parallele Verbindungen!
    
    // üöÄ CONNECTION POOLING: Wiederverwendung bis zu 150 Clients pro Host
    if (clientPool.contains(host) && !clientPool[host].isEmpty()) {
        // Finde ersten nicht-busy Client
        for (FtpClient *client : clientPool[host]) {
            if (!client->property("busy").toBool()) {
                client->setProperty("busy", true);
                qDebug() << "[Scanner] ‚ôªÔ∏è Wiederverwendeter Client #" << clientPool[host].indexOf(client) << "f√ºr:" << host;
                return client;
            }
        }
    }
    
    // Erstelle neuen Client wenn Pool noch nicht voll
    if (!clientPool.contains(host) || clientPool[host].size() < MAX_CLIENTS_PER_HOST) {
        FtpClient *client = new FtpClient(this);
        client->setProperty("busy", true);
        client->setProperty("host", host);
        
        // ‚ùå KEINE automatische Rekursion in Phase 2!
        // Alle Verzeichnisse wurden bereits in Phase 1 (discoverFtpDirectories) gefunden.
        // Phase 2 scannt nur Dateien in den bereits bekannten Verzeichnissen.
        
        if (!clientPool.contains(host)) {
            clientPool[host] = QList<FtpClient*>();
        }
        clientPool[host].append(client);
        
        qDebug() << "[Scanner] üÜï Neuer Client #" << clientPool[host].size() << "/" << MAX_CLIENTS_PER_HOST << "f√ºr:" << host;
        return client;
    }
    
    // Pool voll - warte und verwende ersten verf√ºgbaren (sollte nie passieren mit ThreadPool)
    qWarning() << "[Scanner] ‚ö†Ô∏è Client-Pool voll (" << MAX_CLIENTS_PER_HOST << "), verwende ersten";
    FtpClient *client = clientPool[host].first();
    client->setProperty("busy", true);
    return client;
}

// ‚ö° FALLBACK: Default-Credentials wenn PresetManager fehlt
void Scanner::useDefaultFtpCredentials(FtpClient *client, const QString &host) {
    qDebug() << "[Scanner] üîë Verwende Default-Credentials f√ºr:" << host;
    
    // Standard FTP-Credentials (Anonymous oder h√§ufige Kombinationen)
    QStringList commonUsers = {"ftp", "anonymous", "guest", "user", "admin"};
    QStringList commonPasses = {"", "anonymous", "guest", "password", "admin"};
    
    // Verwende erste Kombination als Default
    client->setCredentials(host, 21, commonUsers.first(), commonPasses.first());
}

// ‚úÖ Asynchrone Dateisammlung - GUI-responsive und crash-sicher
void Scanner::startAsyncFileCollection() {
    qDebug() << "[Scanner] üöÄ Starte asynchrone Dateisammlung f√ºr" << scanDirectories.size() << "Verzeichnisse";
    
    // Reset state
    directoriesToProcess.clear();
    cleanupFileCollection();
    allFiles.clear();
    processedFiles.clear();
    currentDirectoryIndex = 0;
    filesFoundInCurrentDir = 0;
    
    // üéØ SMART REDUNDANCY FILTER: Entferne Parent-Verzeichnisse wenn Child bereits ausgew√§hlt
    QStringList filteredDirectories;
    
    for (const QString &dir : scanDirectories) {
        bool isRedundant = false;
        
        // Normalisiere Pfad (entferne trailing slash f√ºr Vergleich)
        QString normalizedDir = dir;
        if (normalizedDir.endsWith('/') && normalizedDir.length() > 1) {
            normalizedDir.chop(1);
        }
        
        // Pr√ºfe ob ein anderes Verzeichnis ein CHILD von diesem ist
        for (const QString &otherDir : scanDirectories) {
            if (dir == otherDir) continue; // Skip sich selbst
            
            QString normalizedOther = otherDir;
            if (normalizedOther.endsWith('/') && normalizedOther.length() > 1) {
                normalizedOther.chop(1);
            }
            
            // Ist otherDir ein Child von dir? (otherDir startet mit dir/)
            if (normalizedOther.startsWith(normalizedDir + "/")) {
                qDebug() << "[Scanner] üîç REDUNDANT: Parent" << normalizedDir 
                         << "wird √ºbersprungen weil Child" << normalizedOther << "ausgew√§hlt ist";
                isRedundant = true;
                break;
            }
        }
        
        if (!isRedundant) {
            filteredDirectories.append(dir);
            qDebug() << "[Scanner] ‚úÖ Verzeichnis zur Scan-Queue hinzugef√ºgt:" << dir;
        }
    }
    
    // F√ºlle Queue mit gefilterten Verzeichnissen
    for (const QString &dir : filteredDirectories) {
        directoriesToProcess.enqueue(dir);
    }
    
    int removedCount = scanDirectories.size() - filteredDirectories.size();
    if (removedCount > 0) {
        qDebug() << "[Scanner] üéØ Redundanz-Filter: Entfernt" << removedCount 
                 << "Parent-Verzeichnisse (behalten:" << filteredDirectories.size() << ")";
    }
    
    qDebug() << "[Scanner] üìä Scan-Queue:" << directoriesToProcess.size() 
             << "Verzeichnisse (nach Redundanz-Filterung)";
    
    emit scanStatusChanged(QString("Sammle Dateien aus %1 Verzeichnissen...").arg(directoriesToProcess.size()));
    
    // MASSIVE PARALLELITAET: Starte ALLE FTP-Verzeichnisse SOFORT!
    QStringList ftpDirs;
    QStringList localDirs;
    
    while (!directoriesToProcess.isEmpty()) {
        QString dir = directoriesToProcess.dequeue();
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            ftpDirs.append(dir);
        } else {
            localDirs.append(dir);
        }
    }
    
    qDebug() << "[Scanner] BATCH START:" << ftpDirs.size() << "FTP-Dirs +" << localDirs.size() << "local Dirs";
    
    // üîç PHASE 1: FTP Discovery - Entdecke ALLE Unterverzeichnisse rekursiv
    if (!ftpDirs.isEmpty()) {
        qDebug() << "[Scanner] üîç PHASE 1: Starte FTP-Discovery f√ºr" << ftpDirs.size() << "Root-Verzeichnisse";
        for (const QString &ftpDir : ftpDirs) {
            discoverFtpDirectories(ftpDir);
        }
        qDebug() << "[Scanner] üîç PHASE 1: Discovery gestartet - warte auf Completion";
        // Phase 2 wird automatisch gestartet wenn Discovery fertig ist (via onFtpDiscoveryComplete)
        
        // Local: Re-queue f√ºr Timer (l√§uft parallel zu FTP Discovery)
        for (const QString &localDir : localDirs) {
            directoriesToProcess.enqueue(localDir);
        }
        
        // Starte lokalen Scan parallel
        if (!localDirs.isEmpty()) {
            scheduleNextDirectory();
        }
        
        return; // Exit - Phase 2 wird von onFtpDiscoveryComplete() gestartet
    }
    
    // Falls KEINE FTP-Dirs: Nur lokaler Scan
    qDebug() << "[Scanner] üìÇ Nur lokale Verzeichnisse - kein FTP-Discovery n√∂tig";
    
    // Local: Re-queue f√ºr Timer
    for (const QString &localDir : localDirs) {
        directoriesToProcess.enqueue(localDir);
    }
    
    // Starte Timer nur f√ºr lokale Verzeichnisse
    if (!directoriesToProcess.isEmpty()) {
        fileCollectionTimer->start();
    } else if (ftpDirs.isEmpty()) {
        // Keine Verzeichnisse -> direkt zur Size-Filtering Phase
        filterBySize();
    }
}

void Scanner::processNextDirectoryChunk() {
    // üöÄ ULTRA-FAST: Verarbeite bis zu 5 Verzeichnisse pro Timer-Event
    const int MAX_DIRS_PER_TICK = 5;
    int processedDirs = 0;
    
    while (processedDirs < MAX_DIRS_PER_TICK) {
        if (!scanning.load() || directoriesToProcess.isEmpty()) {
            // Sammlung abgeschlossen
            cleanupFileCollection();
            
            if (scanning.load()) {
                qDebug() << "[Scanner] ‚úÖ Dateisammlung abgeschlossen:" << allFiles.size() << "Dateien gefunden";
                emit scanStatusChanged(QString("Sammlung abgeschlossen: %1 Dateien gefunden").arg(allFiles.size()));
                
                // üî• KRITISCH: Rufe filterBySize() NUR wenn KEIN FTP-Scan aktiv!
                // Bei FTP-Scans wird der Workflow von checkScanProgress() fortgesetzt
                if (pendingFtpDirectories.isEmpty()) {
                    qDebug() << "[Scanner] ‚úÖ Kein FTP-Scan aktiv - starte Size-Filtering direkt";
                    QTimer::singleShot(100, this, &Scanner::filterBySize);
                } else {
                    qDebug() << "[Scanner] ‚è≥ FTP-Scan aktiv (" << pendingFtpDirectories.size() 
                             << "pending) - warte auf checkScanProgress() f√ºr Size-Filtering";
                    emit scanStatusChanged(QString("Warte auf %1 FTP-Verzeichnisse...").arg(pendingFtpDirectories.size()));
                }
            }
            return;
        }
        
        // Verarbeite das n√§chste Verzeichnis oder chunk
        if (!currentDirIterator) {
            // Starte neues Verzeichnis
            QString currentDir = directoriesToProcess.dequeue();
            currentDirectoryIndex++;
            filesFoundInCurrentDir = 0;
            processedDirs++; // üöÄ Z√§hle verarbeitete Verzeichnisse
            
            qDebug() << "[Scanner] üìÇ Bearbeite Verzeichnis" << currentDirectoryIndex << "/" 
                     << (currentDirectoryIndex + directoriesToProcess.size()) << ":" << currentDir;
            
            emit currentFileProcessing(
                QFileInfo(currentDir).fileName(),
                "üìÅ Sammle Dateien",
                currentDirectoryIndex,
                currentDirectoryIndex + directoriesToProcess.size()
            );
            
            if (currentDir.startsWith("ftp://")) {
                // FTP-Verzeichnis - verwende bestehende FTP-Logik
                collectFtpFiles(currentDir, processedFiles);
                // FTP ist asynchron - warte auf Completion
                continue; // üöÄ Verarbeite n√§chstes Verzeichnis sofort
            } else {
                // Lokales Verzeichnis - erstelle Iterator
                currentDirIterator = new QDirIterator(currentDir, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);
            }
        }
    
    // Verarbeite Chunk von Dateien (z.B. 20 Dateien pro Timer-Event)
    int filesProcessedInChunk = 0;
    const int MAX_FILES_PER_CHUNK = 20;
    
    while (currentDirIterator && currentDirIterator->hasNext() && filesProcessedInChunk < MAX_FILES_PER_CHUNK) {
        if (!scanning.load()) return;
        
        QString filePath = currentDirIterator->next();
        QFileInfo fileInfo(filePath);
        
        // Normale Dateiverarbeitung
        QString canonicalPath = fileInfo.canonicalFilePath();
        if (canonicalPath.isEmpty()) {
            canonicalPath = fileInfo.absoluteFilePath();
        }
        
        // üîí THREAD-SAFE: Lock f√ºr processedFiles Check & Insert
        {
            QMutexLocker locker(&processedFilesMutex);
            if (processedFiles.contains(canonicalPath)) {
                filesProcessedInChunk++;
                continue;  // Skip duplicate
            }
            // Nach dem Check sofort einf√ºgen (im gleichen Lock)
            processedFiles.insert(canonicalPath);
        }
        
        // üöÄ PERFORMANCE: Gro√üe Dateien (>10MB) nur nach GR√ñSSE+NAME vergleichen (kein Hash!)
        const qint64 maxFileSizeForHashing = 10 * 1024 * 1024; // 10MB = Skip Music/Video!
        qint64 fileSize = fileInfo.size();
        if (fileSize > maxFileSizeForHashing) {
            // ‚úÖ SMART: Gro√üe Dateien nach SIZE+NAME vergleichen (sehr zuverl√§ssig!)
            filesFoundInCurrentDir++;
            
            FileInfo file;
            file.filePath = canonicalPath;
            file.fileName = fileInfo.fileName();
            file.size = fileSize;
            file.lastModified = fileInfo.lastModified().toSecsSinceEpoch();
            file.hash = QString("SIZE_NAME_%1_%2").arg(fileSize).arg(fileInfo.fileName().toLower()); // üéØ SIZE+NAME Hash!
            file.isLocal = true;
            
            allFiles.append(file);
            filesProcessedInChunk++;
            continue; // N√§chste Datei
        }
        
        filesFoundInCurrentDir++;
        
        // Erstelle FileInfo
        FileInfo file;
        file.filePath = canonicalPath;
        file.fileName = fileInfo.fileName();
        file.size = fileSize;
        file.lastModified = fileInfo.lastModified().toSecsSinceEpoch();
        file.isLocal = true;
        
        allFiles.append(file);
        filesProcessedInChunk++;
        
        // Progress update alle 100 Dateien
        if (allFiles.size() % 100 == 0) {
            emit processActivityUpdate(
                QString("üìä %1 Dateien gefunden").arg(allFiles.size()),
                QString("Aktuell: %1").arg(fileInfo.fileName())
            );
        }
    }
    
    // Pr√ºfe ob aktuelles Verzeichnis abgeschlossen ist
    if (currentDirIterator && !currentDirIterator->hasNext()) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
        
        qDebug() << "[Scanner] ‚úÖ Verzeichnis abgeschlossen:" << filesFoundInCurrentDir << "Dateien gefunden";
        // üöÄ Verarbeite n√§chstes Verzeichnis falls noch Budget √ºbrig
        // (Die while-Schleife oben macht das automatisch)
    }
    } // üöÄ Ende der while (processedDirs < MAX_DIRS_PER_TICK) Schleife
}

void Scanner::cleanupFileCollection() {
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
    }
    
    if (currentDirIterator) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
    }
    
    directoriesToProcess.clear();
}

// üîê PERSISTENTE SCAN-HISTORY: Verhindert mehrfaches Scannen
void Scanner::loadScanHistory() {
    QFile file(scanHistoryFile);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qDebug() << "[Scanner] üìú Keine Scan-History gefunden - erstelle neue";
        return;
    }
    
    QTextStream in(&file);
    QString section;
    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();
        
        if (line.isEmpty()) continue;
        
        if (line == "[DIRECTORIES]") {
            section = "dirs";
            continue;
        } else if (line == "[FILES]") {
            section = "files";
            continue;
        }
        
        if (section == "dirs") {
            scannedDirectoriesHistory.insert(line);
        } else if (section == "files") {
            scannedFilesHistory.insert(line);
        }
    }
    
    file.close();
    qDebug() << "[Scanner] ‚úÖ Scan-History geladen:" << scannedDirectoriesHistory.size() 
             << "Verzeichnisse," << scannedFilesHistory.size() << "Dateien";
}

void Scanner::saveScanHistory() {
    QFile file(scanHistoryFile);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "[Scanner] ‚ùå Konnte Scan-History nicht speichern:" << scanHistoryFile;
        return;
    }
    
    QTextStream out(&file);
    
    // Schreibe Verzeichnisse
    out << "[DIRECTORIES]\n";
    for (const QString &dir : scannedDirectoriesHistory) {
        out << dir << "\n";
    }
    
    out << "\n[FILES]\n";
    // Schreibe nur die letzten 10000 Dateien (Speicheroptimierung)
    QStringList filesList = scannedFilesHistory.values();
    int startIdx = qMax(0, filesList.size() - 10000);
    for (int i = startIdx; i < filesList.size(); ++i) {
        out << filesList[i] << "\n";
    }
    
    file.close();
    qDebug() << "[Scanner] üíæ Scan-History gespeichert:" << scannedDirectoriesHistory.size() 
             << "Verzeichnisse," << qMin(10000, scannedFilesHistory.size()) << "Dateien";
}

void Scanner::clearScanHistory() {
    scannedDirectoriesHistory.clear();
    scannedFilesHistory.clear();
    
    QFile::remove(scanHistoryFile);
    qDebug() << "[Scanner] üóëÔ∏è Scan-History gel√∂scht";
}

bool Scanner::isDirectoryInHistory(const QString &dir) const {
    QString canonical = QDir(dir).canonicalPath();
    
    // Pr√ºfe exakte √úbereinstimmung
    if (scannedDirectoriesHistory.contains(canonical)) {
        return true;
    }
    
    // Pr√ºfe ob Elternverzeichnis bereits gescannt wurde
    for (const QString &scannedDir : scannedDirectoriesHistory) {
        if (canonical.startsWith(scannedDir + "/")) {
            qDebug() << "[Scanner] üîç Verzeichnis bereits in History (als Subdir von:" << scannedDir << ")";
            return true;
        }
    }
    
    return false;
}

bool Scanner::isFileInHistory(const QString &filePath) const {
    QString canonical = QFileInfo(filePath).canonicalFilePath();
    return scannedFilesHistory.contains(canonical);
}

void Scanner::addToScanHistory(const QString &path, bool isDirectory) {
    if (isDirectory) {
        QString canonical = QDir(path).canonicalPath();
        scannedDirectoriesHistory.insert(canonical);
        qDebug() << "[Scanner] üìù Verzeichnis zur History hinzugef√ºgt:" << canonical;
    } else {
        QString canonical = QFileInfo(path).canonicalFilePath();
        scannedFilesHistory.insert(canonical);
    }
}

bool Scanner::isScanning() const { return scanning.load(); }
bool Scanner::isPaused() const { return paused.load(); }

void Scanner::clearAllHashes()
{
    QMutexLocker locker(&m_fileSizeGroupsMutex);
    qDebug() << "[Scanner] üóëÔ∏è L√∂sche alle Hash-Indizes...";
    
    // L√∂sche alle Hash-Maps und Caches
    fileSizeGroups.clear();
    hashGroups.clear();
    dateSizeGroups.clear();
    
    // L√∂sche HashEngine Cache falls verf√ºgbar
    if (hashEngine) {
        // HashEngine hat eigenen Cache der auch geleert werden sollte
        qDebug() << "[Scanner] üóëÔ∏è HashEngine Cache wird geleert";
    }
    
    qDebug() << "[Scanner] ‚úÖ Alle Hash-Indizes gel√∂scht";
}

// üåê FTP 2-PHASEN-STRATEGIE: Discovery Phase
void Scanner::startFtpDiscovery(const QStringList &ftpRootDirectories) {
    qDebug() << "[Scanner] üåê VEREINFACHTE STRATEGIE: Nutze normalen Scan-Flow";
    qDebug() << "[Scanner] ÔøΩ FTP-Verzeichnisse werden w√§hrend Scan dynamisch entdeckt";
    
    // ‚úÖ EINFACHERE L√ñSUNG: Statt 2 Phasen - zeige einfach besseres Progress-Feedback
    // Die Verzeichnis-Anzahl wird sich w√§hrend Scan erh√∂hen (z.B. 11 ‚Üí 35765)
    // Das ist NORMAL und OK - wichtig ist dass Counter stabil bleibt
    
    emit scanStatusChanged(QString("üì° Starte FTP-Scan mit %1 root directories (rekursiv)").arg(ftpRootDirectories.size()));
    
    // Nutze bestehenden Flow - kein Bedarf f√ºr separate Discovery
    onFtpDiscoveryCompleted();
}

void Scanner::onFtpDiscoveryCompleted() {
    qDebug() << "[Scanner] üöÄ PHASE 2: FTP-Discovery abgeschlossen -" << discoveredFtpDirectories.size() << "Verzeichnisse gefunden";
    emit scanStatusChanged(QString("‚úÖ Phase 1/2 abgeschlossen: %1 FTP-Verzeichnisse gefunden").arg(discoveredFtpDirectories.size()));
    
    // Wechsel zu Scan-Modus
    ftpDiscoveryPhase = false;
    
    // Setze pendingFtpDirectories auf alle entdeckten Verzeichnisse
    pendingFtpDirectories.clear();
    completedFtpDirectories.clear();
    
    for (const QString &dir : discoveredFtpDirectories) {
        pendingFtpDirectories.insert(dir);
    }
    
    qDebug() << "[Scanner] üìä PHASE 2: Starte Datei-Scan mit" << pendingFtpDirectories.size() << "FTP-Verzeichnissen";
    emit scanStatusChanged(QString("üöÄ Phase 2/2: Scanne %1 FTP-Verzeichnisse...").arg(pendingFtpDirectories.size()));
    
    // üöÄ PHASE 2: Starte DIREKTEN FTP File-Scan (NICHT nochmal startAsyncFileCollection!)
    qDebug() << "[Scanner] üì° PHASE 2: Starte collectFtpFiles f√ºr alle entdeckten Verzeichnisse";
    
    for (const QString &ftpDir : pendingFtpDirectories) {
        collectFtpFiles(ftpDir, processedFiles, false);
    }
    
    qDebug() << "[Scanner] ‚úÖ PHASE 2: FTP File-Collection gestartet f√ºr" << pendingFtpDirectories.size() << "Verzeichnisse";
}

void Scanner::startFtpScan() {
    qDebug() << "[Scanner] üì° Scan l√§uft bereits via collectFtpFiles()";
    // Dummy - wird durch normalen Flow ersetzt
}

// üß† LEVENSHTEIN-DISTANZ: Berechnet String-√Ñhnlichkeit f√ºr Fuzzy-Matching
int Scanner::calculateLevenshtein(const QString &s1, const QString &s2) const {
    const int len1 = s1.length();
    const int len2 = s2.length();
    
    // Optimierung: Leere Strings
    if (len1 == 0) return len2;
    if (len2 == 0) return len1;
    
    // Optimierung: Identische Strings
    if (s1 == s2) return 0;
    
    // Dynamische Programmierung: 2-Zeilen-Matrix (Speicher-Optimierung)
    QVector<int> prevRow(len2 + 1);
    QVector<int> currRow(len2 + 1);
    
    // Initialisierung
    for (int j = 0; j <= len2; ++j) {
        prevRow[j] = j;
    }
    
    // Berechnung
    for (int i = 1; i <= len1; ++i) {
        currRow[0] = i;
        
        for (int j = 1; j <= len2; ++j) {
            int cost = (s1[i - 1] == s2[j - 1]) ? 0 : 1;
            
            int deletion = prevRow[j] + 1;
            int insertion = currRow[j - 1] + 1;
            int substitution = prevRow[j - 1] + cost;
            
            currRow[j] = qMin(qMin(deletion, insertion), substitution);
        }
        
        // Swap rows
        prevRow = currRow;
    }
    
    return currRow[len2];
}

// ‚ö° HARDWARE-OPTIMIERUNG: Intelligente Zuweisung nach Dateityp
Scanner::ProcessingUnit Scanner::selectOptimalHardware(const FileInfo &file) const {
    QString ext = QFileInfo(file.fileName).suffix().toLower();
    
    // üß† NPU: Bilder f√ºr KI-basierte √Ñhnlichkeitserkennung
    static QSet<QString> npuTypes = {"jpg", "jpeg", "png", "gif", "bmp", "webp", "tiff", "tif"};
    if (npuEnabled && hardwareCaps.hasNPU && npuTypes.contains(ext)) {
        return USE_NPU;
    }
    
    // üéÆ GPU: Videos und gro√üe Bilder (schnelles Hashing)
    static QSet<QString> gpuTypes = {"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", 
                                      "mpg", "mpeg", "3gp", "f4v", "psd", "ai", "raw", "cr2", "nef"};
    if (hardwareCaps.hasGPU && gpuTypes.contains(ext)) {
        return USE_GPU;
    }
    
    // üíª CPU: Dokumente, Text, Archives, Code
    // (alle anderen Dateien oder wenn keine GPU/NPU verf√ºgbar)
    return USE_CPU;
}

// üöÄ ULTRA-SPEED PHASE: Early-Exit Filter mit 512-Byte Pre-Hash
// Eliminiert ~70-80% aller Dateien BEVOR Full-Hash berechnet wird
void Scanner::filterByEarlyExit()
{
    if (!scanning.load() || !hashEngine)
        return;

    emit scanStatusChanged("‚ö° Phase 1.5: EARLY-EXIT Filter (512B Pre-Hash)...");
    qDebug() << "[Scanner] üöÄ PHASE 1.5: Early-Exit Filter mit RapidPreHash - eliminiert 70-80% Dateien!";
    
    // Z√§hle eindeutige Pre-Hashes um potenzielle Duplikate zu identifizieren
    QMap<QString, QList<FileInfo>> preHashGroups;
    int processedCount = 0;
    int totalFiles = 0;
    
    for (auto sizeIt = fileSizeGroups.begin(); sizeIt != fileSizeGroups.end(); ++sizeIt) {
        totalFiles += sizeIt.value().size();
    }
    
    // Berechne 512-Byte Pre-Hashes f√ºr alle Dateien in Size-Gruppen
    for (auto sizeIt = fileSizeGroups.begin(); sizeIt != fileSizeGroups.end(); ) {
        QList<FileInfo> &filesInGroup = sizeIt.value();
        QList<FileInfo> preHashedFiles;
        
        for (FileInfo &file : filesInGroup) {
            if (!scanning.load()) return;
            
            processedCount++;
            if (processedCount % 50 == 0) {
                emit currentFileProcessing(
                    file.fileName,
                    "‚ö° Early-Exit Pre-Hash Berechnung",
                    processedCount,
                    totalFiles
                );
                QApplication::processEvents();
            }
            
            // ÔøΩÔøΩ 512-Byte Pre-Hash f√ºr schnelle Eindeutigkeit-Erkennung
            QString preHash = hashEngine->calculateRapidPreHash(file.filePath);
            if (!preHash.isEmpty()) {
                file.preHash = preHash;
                preHashedFiles.append(file);
            }
        }
        
        // Gruppiere nach Pre-Hash
        for (const FileInfo &file : preHashedFiles) {
            preHashGroups[file.preHash].append(file);
        }
        
        ++sizeIt;
    }
    
    qDebug() << "[Scanner] üìä Pre-Hash Analyse abgeschlossen";
    qDebug() << "[Scanner]   Total Dateien:" << totalFiles;
    qDebug() << "[Scanner]   Eindeutige Pre-Hashes:" << preHashGroups.size();
    
    // üî• CRITICAL: Entferne alle Dateien mit UNIQUE Pre-Hashes
    // Diese sind GARANTIERT nicht-Duplikate!
    int eliminatedAsUnique = 0;
    QList<FileInfo> remainingForFullHash;
    
    for (auto preIt = preHashGroups.begin(); preIt != preHashGroups.end(); ++preIt) {
        const QList<FileInfo> &filesWithSamePreHash = preIt.value();
        
        if (filesWithSamePreHash.size() == 1) {
            // üéØ UNIQUE Pre-Hash ‚Üí Datei kann NICHT dupliziert sein!
            eliminatedAsUnique++;
            qDebug() << "[Scanner] ‚úÖ UNIQUE (Early-Exit):" << filesWithSamePreHash.first().fileName;
        } else {
            // Mehrere Dateien mit gleichem Pre-Hash ‚Üí k√∂nnte Duplikate sein, braucht Full-Hash
            for (const FileInfo &file : filesWithSamePreHash) {
                remainingForFullHash.append(file);
            }
        }
    }
    
    qDebug() << "[Scanner] üéØ Early-Exit Ergebnisse:";
    qDebug() << "[Scanner]   ‚úÖ Eliminiert als UNIQUE:" << eliminatedAsUnique 
             << QString("(%1% der Dateien!)").arg((eliminatedAsUnique * 100) / totalFiles);
    qDebug() << "[Scanner]   üîç Verbleibend f√ºr Full-Hash:" << remainingForFullHash.size();
    
    // ‚ö° REBUILD fileSizeGroups mit nur den Dateien die Full-Hash brauchen
    fileSizeGroups.clear();
    for (const FileInfo &file : remainingForFullHash) {
        fileSizeGroups[file.size].append(file);
    }
    
    emit scanStatusChanged(
        QString("‚ö° Early-Exit: %1 Dateien eliminiert (UNIQUE). %2 brauchen noch Full-Hash...")
            .arg(eliminatedAsUnique)
            .arg(remainingForFullHash.size())
    );
}


// üß† SMART HASH AUTO-DETECT: W√§hlt optimalen Hash-Algorithmus basierend auf Dateityp
QString Scanner::selectOptimalHashAlgorithm(const QString &filePath)
{
    QString extension = QFileInfo(filePath).suffix().toLower();
    
    // üé¨ VIDEO/AUDIO: XXHash (Ultra-schnell, gro√üe Dateien)
    static QSet<QString> videoAudioExts = {
        "mp4", "mkv", "avi", "mov", "wmv", "flv", "webm", "m4v", "mpg", "mpeg",
        "mp3", "flac", "wav", "aac", "ogg", "m4a", "wma", "opus", "alac"
    };
    if (videoAudioExts.contains(extension)) {
        return "XXHash";
    }
    
    // üñºÔ∏è BILDER: SHA-1 (Balance zwischen Speed und Sicherheit)
    static QSet<QString> imageExts = {
        "jpg", "jpeg", "png", "gif", "bmp", "tiff", "tif", "webp", "svg", 
        "ico", "heic", "heif", "raw", "cr2", "nef", "arw"
    };
    if (imageExts.contains(extension)) {
        return "SHA-1";
    }
    
    // üì¶ ARCHIVE/COMPRESSED: SHA-256 (Sicherheit wichtig)
    static QSet<QString> archiveExts = {
        "zip", "rar", "7z", "tar", "gz", "bz2", "xz", "iso", "dmg", 
        "pkg", "deb", "rpm", "apk", "jar"
    };
    if (archiveExts.contains(extension)) {
        return "SHA-256";
    }
    
    // üìÑ DOKUMENTE: MD5 (Schnell, ausreichend f√ºr Text)
    static QSet<QString> documentExts = {
        "pdf", "doc", "docx", "txt", "odt", "rtf", "xls", "xlsx", "ppt", 
        "pptx", "csv", "log", "md", "tex", "epub", "mobi"
    };
    if (documentExts.contains(extension)) {
        return "MD5";
    }
    
    // üíª CODE/SOURCE: BLAKE2 (Modern, schnell, sicher)
    static QSet<QString> codeExts = {
        "c", "cpp", "h", "hpp", "py", "java", "js", "ts", "go", "rs", 
        "php", "rb", "swift", "kt", "cs", "sh", "pl", "lua", "r"
    };
    if (codeExts.contains(extension)) {
        return "BLAKE2";
    }
    
    // üóÑÔ∏è DATABASES: SHA-512 (Maximum Security)
    static QSet<QString> databaseExts = {
        "db", "sqlite", "mdb", "accdb", "sql", "dump"
    };
    if (databaseExts.contains(extension)) {
        return "SHA-512";
    }
    
    // ‚öôÔ∏è DEFAULT: MD5 (Schneller Allrounder)
    return "MD5";
}

// üìÅ PARENT/CHILD DIRECTORY ANALYSIS: Extrahiert Top-Level-Scan-Verzeichnis
QString Scanner::extractTopLevelDirectory(const QString &filePath) const
{
    // F√ºr Netzwerk-Pfade (FTP/SFTP/SMB/NFS)
    if (filePath.startsWith("ftp://") || filePath.startsWith("sftp://") || 
        filePath.startsWith("smb://") || filePath.startsWith("nfs://")) {
        QUrl url(filePath);
        QString path = url.path();
        QStringList parts = path.split('/', Qt::SkipEmptyParts);
        if (parts.isEmpty()) return "/";
        return "/" + parts.first(); // Erste Ebene nach Protokoll
    }
    
    // F√ºr lokale Pfade: Finde oberstes Verzeichnis in scanDirectories
    QFileInfo fileInfo(filePath);
    QString absPath = fileInfo.absolutePath();
    
    // Suche in scanDirectories nach dem besten Match
    QString bestMatch;
    int bestMatchLength = 0;
    
    for (const QString &scanDir : scanDirectories) {
        QString normalizedScanDir = QDir(scanDir).absolutePath();
        if (absPath.startsWith(normalizedScanDir)) {
            if (normalizedScanDir.length() > bestMatchLength) {
                bestMatch = normalizedScanDir;
                bestMatchLength = normalizedScanDir.length();
            }
        }
    }
    
    return bestMatch.isEmpty() ? absPath : bestMatch;
}

// üìÅ Pr√ºft ob zwei Verzeichnisse in Parent/Child-Beziehung stehen
bool Scanner::isParentChildRelation(const QString &dir1, const QString &dir2) const
{
    QString normalized1 = QDir(dir1).absolutePath();
    QString normalized2 = QDir(dir2).absolutePath();
    
    // Pr√ºfe beide Richtungen
    return normalized1.startsWith(normalized2 + "/") || normalized2.startsWith(normalized1 + "/");
}
