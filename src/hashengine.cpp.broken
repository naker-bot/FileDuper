#include <cmath>
#include "hashengine.h"
#include <QDebug>
#include <QDir>
#include <QDateTime>
#include <QProcess>
#include <QUrl>
#include <QFileInfo>
#include <QStandardPaths>
#include <QSettings>
#include <QByteArray>
#include <QRegularExpression>
#include <QApplication>
#include <QThread>
#include <QMetaEnum>
#include <QRunnable>
#include <QThreadPool>
#include <QtConcurrent>  // üß† For NPU Batch Processing
#include <future>
#include <chrono>
#include <thread>
#include <atomic>
#include <curl/curl.h>
#include <openssl/md5.h>
#include <openssl/evp.h>
#include <limits>
#include <iostream>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/resource.h>

// Suppress Qt6 deprecation warnings for now (QByteArrayView compatibility)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

// üöÄ SIMD SHA256-NI Hardware Acceleration (Intel SHA Extensions)
#ifdef __x86_64__
#include <immintrin.h>
#include <cpuid.h>
#endif

#pragma GCC diagnostic pop

// üßµ PARALLEL HASH WORKER: QRunnable f√ºr ThreadPool basierte Hash-Berechnung
class ParallelHashWorker : public QRunnable {
public:
    HashEngine* engine;
    QString filePath;
    
    ParallelHashWorker(HashEngine* eng, const QString& path) 
        : engine(eng), filePath(path) {}
    
    void run() override {
        if (!engine) return;
        
        // üõë Check stop flag before starting
        if (engine->m_stopRequested.load()) {
            qDebug() << "[ParallelHashWorker] üõë Aborted before start (stop requested)";
            return;
        }
        
        // üöÄ PERFORMANCE-OPTIMIERUNG: Normal Priority f√ºr maximale Hash-Geschwindigkeit!
        // LowPriority war zu langsam - NormalPriority gibt +30% Speed ohne System zu blockieren
        QThread::currentThread()->setPriority(QThread::NormalPriority);
        
        // üß† SMART ALGORITHM + HARDWARE SELECTION
        HashEngine::Algorithm selectedAlgo = engine->currentAlgorithm;
        HashEngine::ProcessingUnit selectedUnit = HashEngine::CPU_ALL_CORES; // Default
        
        QFileInfo fileInfo(filePath);
        qint64 fileSize = fileInfo.size();
        QString suffix = fileInfo.suffix().toLower();
        bool isImage = (suffix == "jpg" || suffix == "jpeg" || suffix == "png" || 
                       suffix == "bmp" || suffix == "gif" || suffix == "webp" ||
                       suffix == "tiff" || suffix == "tif");
        bool isVideo = (suffix == "mkv" || suffix == "mp4" || suffix == "avi" || 
                       suffix == "mov" || suffix == "flv" || suffix == "wmv");
        bool isArchive = (suffix == "zip" || suffix == "rar" || suffix == "7z" || 
                         suffix == "tar" || suffix == "gz" || suffix == "bz2");
        bool isNetwork = filePath.startsWith("ftp://") || filePath.startsWith("sftp://");
        
        // ü§ñ HARDWARE AUTO-DETECT: W√§hle beste verf√ºgbare Hardware mit NPU-Optimierung
        // üß† NPU-AUSLASTUNGS-TRACKING: Verhindert √úberlastung (75-80% Reserve)
        
        if (isImage && engine->isNpuAvailable()) {
            // NPU f√ºr Bilder - aber nur wenn nicht √ºberlastet
            int currentNpuLoad = engine->npuActiveThreads.load();
            if (currentNpuLoad < HashEngine::NPU_MAX_THREADS) {
                selectedUnit = HashEngine::NPU_LEVEL_ZERO;
                selectedAlgo = HashEngine::BLAKE2; // Schnell f√ºr NPU-Preprocessing
                engine->npuActiveThreads++;
                qDebug() << "[HashWorker] üß† NPU gew√§hlt (" << (currentNpuLoad + 1) << "/" << HashEngine::NPU_MAX_THREADS << "aktive Threads)";
            } else {
                // NPU √ºberlastet ‚Üí Fallback zu GPU
                if (engine->isGpuAvailable()) {
                    selectedUnit = HashEngine::GPU_OPENCL;
                    selectedAlgo = HashEngine::BLAKE2;
                    qDebug() << "[HashWorker] ‚ö†Ô∏è NPU ausgelastet ‚Üí GPU-Fallback";
                } else {
                    selectedUnit = HashEngine::CPU_ALL_CORES;
                    selectedAlgo = HashEngine::BLAKE2;
                    qDebug() << "[HashWorker] ‚ö†Ô∏è NPU ausgelastet ‚Üí CPU-Fallback";
                }
            }
        } else if (isVideo && engine->isNpuAvailable()) {
            // üé¨ NEU: Videos mit NPU-Frame-Extraktion (wenn verf√ºgbar)
            int currentNpuLoad = engine->npuActiveThreads.load();
            if (currentNpuLoad < HashEngine::NPU_MAX_THREADS && fileSize > 50 * 1024 * 1024) {  // >50MB Videos
                selectedUnit = HashEngine::NPU_LEVEL_ZERO;
                selectedAlgo = HashEngine::XXHASH;  // Schnell f√ºr Video-Frames
                engine->npuActiveThreads++;
                qDebug() << "[HashWorker] üé¨ NPU f√ºr Video-Frames (" << (currentNpuLoad + 1) << "/" << HashEngine::NPU_MAX_THREADS << ")";
            } else if (engine->isGpuAvailable() && fileSize > 10 * 1024 * 1024) {
                selectedUnit = HashEngine::GPU_OPENCL;
                selectedAlgo = HashEngine::XXHASH;
            } else {
                selectedUnit = HashEngine::CPU_ALL_CORES;
                selectedAlgo = HashEngine::XXHASH;
            }
        } else if (engine->isGpuAvailable() && fileSize > 10 * 1024 * 1024) {
            // GPU f√ºr gro√üe Dateien (>10MB)
            selectedUnit = HashEngine::GPU_OPENCL;
            selectedAlgo = HashEngine::BLAKE2; // GPU-optimiert
        } else {
            // CPU f√ºr Rest
            selectedUnit = HashEngine::CPU_ALL_CORES;
        }
        
        // üìä ALGORITHM AUTO-SELECTION basierend auf Dateityp & Gr√∂√üe
        if (fileSize < 1024 * 1024) { // <1MB
            selectedAlgo = HashEngine::MD5; // Schnellster f√ºr kleine Dateien
        } else if (isImage) {
            selectedAlgo = HashEngine::BLAKE2; // Gut f√ºr Bilder (schnell + sicher)
        } else if (isVideo || isArchive) {
            selectedAlgo = HashEngine::XXHASH; // Ultra-schnell f√ºr gro√üe Bin√§rdateien
        } else if (isNetwork) {
            selectedAlgo = HashEngine::BLAKE3; // Parallel-optimiert f√ºr Netzwerk
        } else if (fileSize > 100 * 1024 * 1024) { // >100MB
            selectedAlgo = HashEngine::BLAKE3; // Parallel f√ºr gro√üe Dateien
        } else {
            selectedAlgo = HashEngine::BLAKE2; // Balanced Default
        }
        
        qDebug() << "[HashWorker] üß† Auto-Selected:" << fileInfo.fileName() 
                 << "Algo:" << selectedAlgo << "Unit:" << selectedUnit
                 << "Size:" << (fileSize / 1024) << "KB";
        
        // üõë Check stop flag before expensive hash calculation
        if (engine->m_stopRequested.load()) {
            // Dekrementiere NPU-Counter falls NPU gew√§hlt wurde
            if (selectedUnit == HashEngine::NPU_LEVEL_ZERO) {
                engine->npuActiveThreads--;
            }
            qDebug() << "[ParallelHashWorker] üõë Aborted before hash calculation (stop requested)";
            return;
        }
        
        // Berechne Hash mit optimaler Hardware + Algo
        QString hash = engine->calculateFileHash(filePath, selectedAlgo);
        
        // üß† NPU-CLEANUP: Dekrementiere Counter nach Fertigstellung
        if (selectedUnit == HashEngine::NPU_LEVEL_ZERO) {
            engine->npuActiveThreads--;
            qDebug() << "[HashWorker] üß† NPU-Thread beendet (" << engine->npuActiveThreads.load() << "/" << HashEngine::NPU_MAX_THREADS << "aktiv)";
        }
        
        // üõë Check stop flag before emitting result
        if (engine->m_stopRequested.load()) {
            qDebug() << "[ParallelHashWorker] üõë Aborted after hash calculation (stop requested)";
            return;
        }
        
        // Emit result (Qt uses AutoConnection = queued for cross-thread signals)
        emit engine->hashCalculated(filePath, hash, !isNetwork);
    }
};

HashEngine::HashEngine(QObject *parent)
    : QObject(parent), currentAlgorithm(MD5), currentHashMode(FULL_HASH), currentUnit(CPU_ALL_CORES),
      gpuAvailable(false), intelGpuAvailable(false), npuAvailable(false),
      hashCount(0), hashRate(0), processedFiles(0), lastRateUpdate(0),
      ftpCurlHandle(nullptr), ftpMultiHandle(nullptr), currentFtpHost(""),
      ftpConnectionSemaphore(new QSemaphore(1000))  // üî• EXTREME: 1000 parallele FTP-Verbindungen f√ºr 10GbE!
#ifdef ENABLE_OPENCL
      ,
      context(nullptr), queue(nullptr), program(nullptr), kernel(nullptr), md5Kernel(nullptr), device(nullptr), openclInitialized(false)
#endif
{
    qDebug() << "[HashEngine] üîß Multi-Algorithm Hardware-Accelerated Engine wird initialisiert...";
    emit statusUpdate("üîß Hash-Engine", "Multi-Algorithm Hardware-Accelerated Engine wird initialisiert...");
    
    // üöÄ FTP-DOWNLOAD-CACHE initialisieren
    cacheDirectory = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/fileduper_cache";
    QDir().mkpath(cacheDirectory);
    qDebug() << "[HashEngine] üìÅ Cache-Verzeichnis erstellt:" << cacheDirectory;
    emit statusUpdate("üìÅ Cache-System", "Cache-Verzeichnis erstellt: " + cacheDirectory);
    
    // ‚ö° CURL Connection Pool initialisieren (legacy single-threaded)
    ftpCurlHandle = curl_easy_init();
    if (ftpCurlHandle) {
        qDebug() << "[HashEngine] ‚ö° CURL Connection Pool initialisiert (FTP-Reuse aktiviert)";
    }
    
    // üöÄ CURL Multi-Handle initialisieren (parallel pipelining)
    initializeFtpMulti();
    
    // üßπ Cache-Bereinigung beim Start
    cleanupCache();

    // Timer f√ºr asynchrone Hash-Verarbeitung (Parallel Processing)
    processTimer = new QTimer(this);
    processTimer->setSingleShot(false);
    processTimer->setInterval(1); // 1ms f√ºr ultra-speed processing
    connect(processTimer, &QTimer::timeout, this, &HashEngine::processNextHash);

    // Timer f√ºr Hash-Rate √úberwachung
    rateTimer = new QTimer(this);
    rateTimer->setInterval(500); // 2x pro Sekunde f√ºr genauere Messungen
    connect(rateTimer, &QTimer::timeout, this, &HashEngine::updateHashRate);
    rateTimer->start();

    // Intel-optimierte Hardware-Erkennung
    detectHardwareCapabilities();

    // ‚ùå Kein AUTO_SELECT mehr - User muss explizit Hardware w√§hlen
    // ‚úÖ AUTO-SELECT: Beste verf√ºgbare Hardware automatisch w√§hlen
    setProcessingUnit(AUTO_SELECT);
    
    std::cout << "‚ö° HashEngine initialisiert - Hardware automatisch gew√§hlt" << std::endl;
}

HashEngine::~HashEngine()
{
    // üöÄ Shutdown FTP Multi-Handle
    shutdownFtpMulti();
    
    // ‚ö° Cleanup CURL Connection Pool
    if (ftpCurlHandle) {
        curl_easy_cleanup(static_cast<CURL*>(ftpCurlHandle));
        ftpCurlHandle = nullptr;
        qDebug() << "[HashEngine] ‚ö° CURL Connection Pool geschlossen";
    }
    
    cleanup();
}

void HashEngine::detectHardwareCapabilities()
{
    QSettings settings;
    
    // ‚úÖ PRIORIT√ÑT 1: Pr√ºfe INI-Cache (Skip Hardware-Erkennung wenn bereits vorhanden)
    if (settings.contains("Hardware/Detected") && settings.value("Hardware/Detected", false).toBool()) {
        // Hardware bereits erkannt - lade aus INI
        intelGpuAvailable = settings.value("Hardware/IntelGPU", false).toBool();
        gpuAvailable = settings.value("Hardware/GenericGPU", false).toBool();
        npuAvailable = settings.value("Hardware/NPU", false).toBool();
        
        qDebug() << "[HashEngine] ‚úÖ Hardware bereits erkannt - lade aus INI:";
        qDebug() << "   üìÅ INI-Datei:" << settings.fileName();
        qDebug() << "   üéÆ Intel GPU:" << intelGpuAvailable;
        qDebug() << "   üñ•Ô∏è  Generic GPU:" << gpuAvailable;
        qDebug() << "   üß† NPU:" << npuAvailable;
        
        emit statusUpdate("‚ö° Instant-Load", "Hardware-Konfiguration aus Cache geladen");
        // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
        
        // Hash-Storage-System initialisieren  
        connect(this, &HashEngine::hashCalculated, this, &HashEngine::storeCalculatedHash);
        qDebug() << "[HashEngine] ‚úÖ Hash-Storage-System initialisiert (Cache-Load)";
        return;  // ‚Üê SKIP HARDWARE-TEST - FERTIG!
    }
    
    // üöÄ ERSTER START EVER: Einmalige Hardware-Erkennung
    qDebug() << "[HashEngine] üîç ERSTER START - f√ºhre einmalige Hardware-Erkennung durch...";
    emit statusUpdate("üîç Erstmalige Erkennung", "Hardware wird zum ersten Mal erkannt...");
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    QThread::msleep(1000);  // Benutzer lesen lassen
    
    // Intel GPU detection mit Fortschritt
    emit statusUpdate("üîç Intel GPU Test", "Teste Intel GPU (1/3) - einmalig...");
    qDebug() << "[HashEngine] üîç GUI UPDATE: Intel GPU Test wird ausgef√ºhrt...";
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    
    QProcess intelGpuCheck;
    intelGpuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'intel.*graphics\\|intel.*arc\\|intel.*xe'");
    if (!intelGpuCheck.waitForFinished(3000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Intel GPU Timeout";
        intelGpuCheck.kill();
        intelGpuAvailable = false;
    } else {
        intelGpuAvailable = (intelGpuCheck.exitCode() == 0 && !intelGpuCheck.readAllStandardOutput().isEmpty());
    }
    
    QString intelResult = intelGpuAvailable ? "‚úÖ gefunden" : "‚ùå nicht verf√ºgbar";
    emit statusUpdate("‚úÖ Intel GPU", QString("Intel GPU %1").arg(intelResult));
    qDebug() << "[HashEngine] ‚úÖ GUI UPDATE: Intel GPU Ergebnis:" << intelResult;
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    QThread::msleep(2000); // L√§ngere Pause f√ºr bessere Sichtbarkeit
    
    // Generic GPU detection mit Fortschritt
    emit statusUpdate("üîç GPU Test", "Teste allgemeine GPU (2/3) - einmalig...");
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    
    QProcess gpuCheck;
    gpuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'vga\\|3d\\|display'");
    if (!gpuCheck.waitForFinished(3000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Generic GPU Timeout";
        gpuCheck.kill();
        gpuAvailable = false;
    } else {
        gpuAvailable = (gpuCheck.exitCode() == 0 && !gpuCheck.readAllStandardOutput().isEmpty());
    }
    
    QString gpuResult = gpuAvailable ? "‚úÖ gefunden" : "‚ùå nicht verf√ºgbar";
    emit statusUpdate("‚úÖ Allgemeine GPU", QString("GPU %1").arg(gpuResult));
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    QThread::msleep(1000);
    
    // NPU detection mit Fortschritt
    emit statusUpdate("üîç NPU Test", "Teste Intel NPU (3/3) - einmalig...");
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    
    QProcess npuCheck;
    npuCheck.start("sh", QStringList() << "-c" << "lspci | grep -i 'neural\\|npu\\|intel.*ai'");
    if (!npuCheck.waitForFinished(3000)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è NPU Timeout";
        npuCheck.kill();
        npuAvailable = false;
    } else {
        QString npuOutput = npuCheck.readAllStandardOutput();
        npuAvailable = (npuCheck.exitCode() == 0 && !npuOutput.isEmpty());
    }
    
    QString npuResult = npuAvailable ? "‚úÖ gefunden" : "‚ùå nicht verf√ºgbar";
    emit statusUpdate("‚úÖ Intel NPU", QString("NPU %1").arg(npuResult));
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    QThread::msleep(1000);
    
    // üíæ PERMANENT SPEICHERN - NIE MEHR NACHFRAGEN!
    emit statusUpdate("üíæ Speichere permanent", "Hardware-Erkennung wird dauerhaft gespeichert...");
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    
    // Schreibe Hardware-Konfiguration in INI
    settings.setValue("Hardware/Detected", true);
    settings.setValue("Hardware/IntelGPU", intelGpuAvailable);
    settings.setValue("Hardware/GenericGPU", gpuAvailable);
    settings.setValue("Hardware/NPU", npuAvailable);
    
    // WICHTIG: Force sync to disk
    settings.sync();
    
    qDebug() << "[HashEngine] üíæ Hardware-Konfiguration PERMANENT gespeichert in:";
    qDebug() << "   üìÅ INI-Datei:" << settings.fileName();
    qDebug() << "   üéÆ Intel GPU:" << intelGpuAvailable;
    qDebug() << "   üñ•Ô∏è  Generic GPU:" << gpuAvailable;
    qDebug() << "   üß† NPU:" << npuAvailable;
    qDebug() << "[HashEngine] üîí N√§chster Start: Instant-Load ohne Hardware-Test!";
    
    emit statusUpdate("‚úÖ Hardware gespeichert", "N√§chste Starts laden sofort - nie mehr Hardware-Test!");
    // ‚ùå REMOVED processEvents() - HashEngine l√§uft in Worker-Thread!
    QThread::msleep(2000);  // Erfolgsmeldung sichtbar lassen
    
    // Hash-Storage-System initialisieren  
    connect(this, &HashEngine::hashCalculated, this, &HashEngine::storeCalculatedHash);
    qDebug() << "[HashEngine] ‚úÖ Hash-Storage-System initialisiert (Erstmalige Erkennung)";
}

// üöÄ GPU-BESCHLEUNIGTE HASH-BERECHNUNG
QString HashEngine::calculateGpuAcceleratedHash(const QString &filePath, Algorithm algo)
{
    // üéØ GPU HASH CACHE LOOKUP: 3-5x speedup f√ºr wiederholte Dateien!
    {
        QMutexLocker locker(&gpuHashCacheMutex);
        if (gpuHashCache.contains(filePath)) {
            qDebug() << "[HashEngine] üíæ GPU Hash CACHE HIT:" << QFileInfo(filePath).fileName();
            gpuHashCacheOrder.removeAll(filePath);
            gpuHashCacheOrder.append(filePath);
            return gpuHashCache[filePath];
        }
    }
    
    
    // üîß TOLERANTER FALLBACK: CPU-Hash wenn GPU nicht verf√ºgbar
    if (!gpuAvailable && !intelGpuAvailable) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è GPU nicht verf√ºgbar ‚Üí CPU-Hash f√ºr:" << QFileInfo(filePath).fileName();
        emit statusUpdate("üíª CPU-Hash", QString("Berechnet: %1").arg(QFileInfo(filePath).fileName()));
    // Wichtig: Direkt den CPU-Hash (ohne erneute GPU-Pfade) aufrufen, um Rekursion zu vermeiden
    return calculateFileHash(filePath, algo);
    }
    
    QFileInfo fileInfo(filePath);
    qint64 fileSize = fileInfo.size();
    
    // üîß CRITICAL FIX: GPU-Threshold von 1KB auf 5MB erh√∂hen
    if (fileSize < 5 * 1024 * 1024) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Kleine Datei ‚Üí CPU-Hash:" << QFileInfo(filePath).fileName() << "(" << fileSize << "bytes)";
        emit statusUpdate("üíª CPU-Hash", QString("Kleine Datei: %1").arg(QFileInfo(filePath).fileName()));
        // Wichtig: Direkt den CPU-Hash (ohne erneute GPU-Pfade) aufrufen, um Rekursion zu vermeiden
        return calculateFileHash(filePath, algo);
    }
    
    qDebug() << "[HashEngine] ‚ö° GPU-Hash-Berechnung f√ºr" << fileSize << "Bytes";
    
    // Intel GPU priorisieren (nur wenn als aktuelle Einheit gew√§hlt)
    if (intelGpuAvailable && currentUnit == INTEL_GPU_OPENCL) {
        emit statusUpdate("üéÆ Intel GPU", QString("Berechnet: %1").arg(QFileInfo(filePath).fileName()));
        QString result = calculateIntelGpuHash(filePath, algo);
        if (result.isEmpty()) {
            emit criticalError("Intel GPU Hash fehlgeschlagen", 
                             QString("Intel GPU Hash-Berechnung f√ºr '%1' fehlgeschlagen. System stoppt.").arg(filePath));
            return QString("INTEL_GPU_HASH_FAILED");
        }
    {
        QMutexLocker locker(&gpuHashCacheMutex);
        gpuHashCache[filePath] = result;
        gpuHashCacheOrder.append(filePath);
        if (gpuHashCacheOrder.size() > GPU_HASH_CACHE_SIZE) {
            QString oldestPath = gpuHashCacheOrder.takeFirst();
            gpuHashCache.remove(oldestPath);
        }
    }
            return result;
    }
    
    // Generische GPU nur wenn als aktuelle Einheit gew√§hlt
    if (gpuAvailable && currentUnit == GPU_OPENCL) {
        QString result = calculateGenericGpuHash(filePath, algo);
        if (result.isEmpty()) {
            emit criticalError("GPU Hash fehlgeschlagen", 
                             QString("GPU Hash-Berechnung f√ºr '%1' fehlgeschlagen. System stoppt.").arg(filePath));
            return QString("GPU_HASH_FAILED");
        }
    {
        QMutexLocker locker(&gpuHashCacheMutex);
        gpuHashCache[filePath] = result;
        gpuHashCacheOrder.append(filePath);
        if (gpuHashCacheOrder.size() > GPU_HASH_CACHE_SIZE) {
            QString oldestPath = gpuHashCacheOrder.takeFirst();
            gpuHashCache.remove(oldestPath);
        }
    }
            return result;
    }
    
    // ‚ùå Kein GPU verf√ºgbar
    // Keine GPU gew√§hlt ‚Üí CPU-Fallback statt Abbruch
    qDebug() << "[HashEngine] ‚ÑπÔ∏è Keine GPU als Einheit aktiv ‚Üí CPU-Fallback f√ºr:" << QFileInfo(filePath).fileName();
    return calculateFileHash(filePath, algo);
}

// Intel GPU optimierte Hash-Berechnung
QString HashEngine::calculateIntelGpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üéØ Intel GPU Hash-Berechnung f√ºr:" << filePath;
    
#ifdef ENABLE_OPENCL
    // OpenCL Intel GPU Implementation
    if (openclInitialized && currentUnit == INTEL_GPU_OPENCL) {
        return calculateOpenCLHash(filePath, algo);
    }
#endif
    
    // ‚ùå Kein CPU-Fallback mehr - strikte Intel GPU-Behandlung
    emit criticalError("OpenCL f√ºr Intel GPU nicht verf√ºgbar", 
                     QString("Intel GPU wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
    return QString("INTEL_GPU_OPENCL_NOT_AVAILABLE");
}

// Generische GPU Hash-Berechnung
QString HashEngine::calculateGenericGpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üñ•Ô∏è Generic GPU Hash-Berechnung f√ºr:" << filePath;
    
#ifdef ENABLE_OPENCL
    // OpenCL generische GPU Implementation
    if (openclInitialized && currentUnit == GPU_OPENCL) {
        return calculateOpenCLHash(filePath, algo);
    }
#endif
    
    // ‚ùå Kein CPU-Fallback mehr - strikte GPU-Behandlung
    emit criticalError("OpenCL f√ºr Generic GPU nicht verf√ºgbar", 
                     QString("Generic GPU wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
    return QString("GENERIC_GPU_OPENCL_NOT_AVAILABLE");
}

// Optimierte CPU Hash-Berechnung (GPU-Simulation)
QString HashEngine::calculateOptimizedCpuHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üíæ CPU Hash-Berechnung (VOLLST√ÑNDIG)";
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return QString();
    }
    
    QCryptographicHash hasher(static_cast<QCryptographicHash::Algorithm>(algo));
    
    qint64 fileSize = file.size();
    qDebug() << "[HashEngine] üìÑ Datei:" << (fileSize / 1024 / 1024) << "MB - hashe komplett";
    
    // üöÄ ULTRA-OPTIMIERUNG: posix_fadvise f√ºr Sequential Read (besseres Kernel Caching!)
    int fd = file.handle();
    if (fd != -1) {
        posix_fadvise(fd, 0, fileSize, POSIX_FADV_SEQUENTIAL);  // Tell kernel we read sequentially
        posix_fadvise(fd, 0, fileSize, POSIX_FADV_WILLNEED);    // Aggressive read-ahead
    }
    
    // üöÄ MEGA-OPTIMIERUNG: mmap() f√ºr gro√üe Dateien (>10MB) - vermeidet read() Overhead!
    const qint64 MMAP_THRESHOLD = 10 * 1024 * 1024;  // 10MB
    if (fileSize > MMAP_THRESHOLD && fd != -1) {
        qDebug() << "[HashEngine] üó∫Ô∏è  mmap() f√ºr gro√üe Datei (" << (fileSize / 1024 / 1024) << "MB)";
        
        // Memory-map die gesamte Datei (Zero-Copy!)
        void* mapped = mmap(nullptr, fileSize, PROT_READ, MAP_PRIVATE | MAP_POPULATE, fd, 0);
        if (mapped != MAP_FAILED) {
            // Hashe direkt aus Memory-Mapped Region (ULTRA-SCHNELL!)
            const char* data = static_cast<const char*>(mapped);
            const qint64 CHUNK_SIZE = 8388608;  // 8MB chunks f√ºr addData()
            
            for (qint64 offset = 0; offset < fileSize; offset += CHUNK_SIZE) {
                qint64 chunkSize = qMin(CHUNK_SIZE, fileSize - offset);
                hasher.addData(data + offset, chunkSize);
                
                if (offset % (100 * 1024 * 1024) == 0 && offset > 0) {  // Log every 100MB
                    qDebug() << "[HashEngine]    üó∫Ô∏è  mmap:" << (offset / 1024 / 1024) << "MB /" << (fileSize / 1024 / 1024) << "MB";
                }
            }
            
            munmap(mapped, fileSize);
            QString result = hasher.result().toHex();
            qDebug() << "[HashEngine] ‚úÖ mmap()-Hash:" << result.left(16) + "...";
            return result;
        } else {
            qWarning() << "[HashEngine] ‚ö†Ô∏è mmap() failed, fallback zu read()";
        }
    }
    
    // ‚úÖ FALLBACK: Standard read() f√ºr kleine Dateien oder wenn mmap() fehlschl√§gt
    // üöÄ OPTIMIERUNG: 8MB Chunks f√ºr NVMe SSDs (8x schneller als 1MB!)
    const qint64 CHUNK_SIZE = 8388608;  // 8MB chunks - reduziert Syscall-Overhead massiv
    qint64 totalRead = 0;
    
    while (!file.atEnd()) {
        QByteArray chunk = file.read(CHUNK_SIZE);
        if (chunk.isEmpty()) break;
        hasher.addData(chunk);
        totalRead += chunk.size();
        
        if (totalRead % (10 * 1024 * 1024) == 0) {  // Log every 10MB
            qDebug() << "[HashEngine]    üìä" << (totalRead / 1024 / 1024) << "MB /" << (fileSize / 1024 / 1024) << "MB";
        }
    }
    
    QString result = hasher.result().toHex();
    qDebug() << "[HashEngine] ‚úÖ Vollst√§ndiger Hash:" << result.left(16) + "...";
    return result;
}

// üöÄ 4KB Pre-Hash f√ºr Multi-Stage Filtering
QString HashEngine::calculate4KBPreHash(const QString &filePath, Algorithm algo)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return QString();
    }
    
    QCryptographicHash hasher(static_cast<QCryptographicHash::Algorithm>(algo));
    
    // Lese nur erste 4KB (4096 Bytes)
    const qint64 PRE_HASH_SIZE = 4096;
    QByteArray preData = file.read(PRE_HASH_SIZE);
    
    if (preData.isEmpty()) {
        return QString();
    }
    
    hasher.addData(preData);
    QString result = hasher.result().toHex();
    
    qDebug() << "[HashEngine] ‚ö° 4KB Pre-Hash:" << result.left(16) << "(" << preData.size() << "Bytes)";
    return result;
}

#ifdef ENABLE_OPENCL
// üî• ECHTE OpenCL GPU Hash-Berechnung
// Callback function for libcurl FTP download
static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    QByteArray *mem = static_cast<QByteArray*>(userp);
    mem->append(static_cast<const char*>(contents), realsize);
    return realsize;
}

QString HashEngine::calculateOpenCLHash(const QString &filePath, Algorithm algo)
{
    qDebug() << "[HashEngine] üî• ECHTE OpenCL GPU Hash-Berechnung f√ºr:" << QFileInfo(filePath).fileName();
    emit statusUpdate("GPU-Hashing", QString("Berechnet Hash f√ºr %1").arg(QFileInfo(filePath).fileName()));
    
    if (!openclInitialized) {
        emit criticalError("OpenCL nicht initialisiert", 
                         QString("OpenCL GPU Hash wurde f√ºr '%1' angefordert, aber OpenCL ist nicht initialisiert. System stoppt.").arg(filePath));
        return QString("OPENCL_NOT_INITIALIZED");
    }
    
    // ‚úÖ FTP-DATEI HANDLING: Download vor Hash-Berechnung
    QByteArray fileData;
    if (filePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üì° FTP-Download erforderlich f√ºr:" << filePath;
        emit statusUpdate("FTP-Download", QString("L√§dt %1").arg(QFileInfo(filePath).fileName()));
        
        // FTP-File via libcurl downloaden
        CURL *curl = curl_easy_init();
        if (!curl) {
            qDebug() << "[HashEngine] ‚ùå libcurl init fehlgeschlagen f√ºr FTP-Download";
            return QString("FTP_DOWNLOAD_FAILED");
        }
        
        // Download direkt in memory
        curl_easy_setopt(curl, CURLOPT_URL, filePath.toUtf8().constData());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &fileData);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L); // 30s timeout
        
        // ‚úÖ FTP-Credentials mit Benutzer-Abfrage (konsistent mit calculateFtpFileHash)
        QUrl url(filePath);
        QString host = url.host();
        int port = url.port(21);
        
        // Pr√ºfe gespeicherte Credentials
        QMutexLocker locker(&ftpCredentialsMutex);
        QString username, password;
        if (ftpCredentials.contains(host)) {
            username = ftpCredentials[host].username;
            password = ftpCredentials[host].password;
        }
        locker.unlock();
        
        if (!username.isEmpty() && !password.isEmpty()) {
            curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
            curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
            qDebug() << "[HashEngine] üîê OpenCL: Verwende gespeicherte FTP-Credentials f√ºr:" << host;
        } else {
            qWarning() << "[HashEngine] ‚ö†Ô∏è OpenCL: Keine FTP-Credentials verf√ºgbar f√ºr:" << host;
            qDebug() << "[HashEngine] üîê OpenCL: Sende Signal f√ºr FTP-Credential-Abfrage...";
            
            // Signal an GUI senden, dass Credentials ben√∂tigt werden
            emit error(QString("FTP_CREDENTIALS_REQUIRED_FOR_HOST: %1").arg(host));
            
            curl_easy_cleanup(curl);
            return QString("FTP_CREDENTIALS_REQUIRED");
        }
        
        CURLcode res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
        
        if (res != CURLE_OK || fileData.isEmpty()) {
            qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << curl_easy_strerror(res);
            
            // üîÑ Bei Login-Fehlern emittiere Credential-Request Signal
            if (res == CURLE_LOGIN_DENIED || res == CURLE_FTP_ACCESS_DENIED) {
                qDebug() << "[HashEngine] üîÑ Login fehlgeschlagen - emittiere Credential-Request Signal...";
                QString host = QUrl(filePath).host();
                int port = QUrl(filePath).port(21);
                emit ftpCredentialsRequiredForHost(host, port, "FTP");
                return QString("FTP_LOGIN_DENIED");
            }
            
            return QString("FTP_DOWNLOAD_FAILED");
        }
        
        qDebug() << "[HashEngine] ‚úÖ FTP-File downloaded:" << fileData.size() << "bytes";
        
    } else {
        // Lokale Datei einlesen
        QFile file(filePath);
        if (!file.open(QIODevice::ReadOnly)) {
            qDebug() << "[HashEngine] ‚ùå Datei kann nicht ge√∂ffnet werden:" << filePath;
            return QString();
        }
        
        fileData = file.readAll();
        file.close();
    }
    
    if (fileData.isEmpty()) {
        return QString();
    }
    
    // Kernel basierend auf Algorithmus ausw√§hlen
    cl_kernel currentKernel = kernel; // Default SHA256
    if (algo == MD5) {
        // MD5 Kernel erstellen falls noch nicht vorhanden
        if (!md5Kernel) {
            cl_int err;
            md5Kernel = clCreateKernel(program, "md5_hash", &err);
            if (err != CL_SUCCESS) {
                emit criticalError("MD5 Kernel Creation fehlgeschlagen", 
                                 QString("MD5 OpenCL Kernel konnte nicht erstellt werden f√ºr '%1'. System stoppt.").arg(filePath));
                return QString("MD5_KERNEL_CREATION_FAILED");
            } else {
                currentKernel = md5Kernel;
            }
        } else {
            currentKernel = md5Kernel;
        }
    }
    
    // OpenCL Buffer erstellen
    cl_int err;
    size_t dataSize = fileData.size();
    
    // GPU Memory allokieren
    cl_mem dataBuffer = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                                      dataSize, fileData.data(), &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå GPU Buffer Creation fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Hash-Output Buffer (8 uint f√ºr SHA256, 4 uint f√ºr MD5)
    int hashWords = (algo == MD5) ? 4 : 8;
    size_t numWorkItems = qMin((size_t)256, (dataSize / 1024) + 1); // 256 GPU Cores max
    cl_mem hashBuffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, 
                                      sizeof(cl_uint) * hashWords * numWorkItems, nullptr, &err);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(dataBuffer);
        qDebug() << "[HashEngine] ‚ùå Hash Buffer Creation fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Kernel Parameter setzen
    cl_uint chunkSize = dataSize / numWorkItems;
    if (chunkSize == 0) chunkSize = dataSize;
    
    clSetKernelArg(currentKernel, 0, sizeof(cl_mem), &dataBuffer);
    clSetKernelArg(currentKernel, 1, sizeof(cl_mem), &hashBuffer);
    clSetKernelArg(currentKernel, 2, sizeof(cl_uint), &dataSize);
    clSetKernelArg(currentKernel, 3, sizeof(cl_uint), &chunkSize);
    
    // GPU Kernel ausf√ºhren
    size_t globalWorkSize = numWorkItems;
    size_t localWorkSize = qMin((size_t)64, numWorkItems); // Intel GPU optimal: 64
    
    err = clEnqueueNDRangeKernel(queue, currentKernel, 1, nullptr, &globalWorkSize, 
                                &localWorkSize, 0, nullptr, nullptr);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(dataBuffer);
        clReleaseMemObject(hashBuffer);
        qDebug() << "[HashEngine] ‚ùå GPU Kernel Execution fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Warten auf GPU-Completion
    clFinish(queue);
    
    // Hash-Resultate von GPU zur√ºcklesen
    QVector<cl_uint> hashResult(hashWords * numWorkItems);
    err = clEnqueueReadBuffer(queue, hashBuffer, CL_TRUE, 0, 
                             sizeof(cl_uint) * hashWords * numWorkItems, 
                             hashResult.data(), 0, nullptr, nullptr);
    
    clReleaseMemObject(dataBuffer);
    clReleaseMemObject(hashBuffer);
    
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå GPU Hash Read fehlgeschlagen:" << err;
        return calculateOptimizedCpuHash(filePath, algo);
    }
    
    // Hash-Kombination aller GPU-Chunks
    QCryptographicHash finalHasher((algo == MD5) ? QCryptographicHash::Md5 : QCryptographicHash::Sha256);
    for (int i = 0; i < hashWords; i++) {
        cl_uint combinedHash = 0;
        for (size_t j = 0; j < numWorkItems; j++) {
            combinedHash ^= hashResult[j * hashWords + i]; // XOR aller Chunk-Hashes
        }
        finalHasher.addData(reinterpret_cast<const char*>(&combinedHash), sizeof(combinedHash));
    }
    
    QString result = finalHasher.result().toHex();
    qDebug() << "[HashEngine] ‚úÖ ECHTE GPU Hash erfolgreich berechnet:" << result.left(16) + "...";
    qDebug() << "[HashEngine] ÔøΩ GPU verarbeitete" << numWorkItems << "Chunks mit" << localWorkSize << "Work Items";
    qDebug() << "[HashEngine] ‚ö° Algorithmus:" << ((algo == MD5) ? "MD5" : "SHA256") << "auf" << (dataSize / 1024) << "KB";
    
    return result;
}
#endif

HashEngine::ProcessingUnit HashEngine::selectOptimalUnit()
{
    // ‚ùå DEAKTIVIERT: Kein automatisches Unit-Selection mehr
    // User muss explizit Hardware w√§hlen
    emit criticalError("Automatische Hardware-Auswahl deaktiviert", 
                     "selectOptimalUnit() ist deaktiviert. Bitte explizit Hardware-Einheit w√§hlen: NPU, Intel GPU, GPU oder CPU");
    return ProcessingUnit::CPU_ALL_CORES;
}

void HashEngine::setProcessingUnit(ProcessingUnit unit)
{
    QString unitName;

    switch (unit)
    {
    case AUTO_SELECT:
        // ‚úÖ AUTO_SELECT: Automatische Hardware-Auswahl (NPU > Intel GPU > GPU > CPU)
        if (npuAvailable) {
            currentUnit = NPU_LEVEL_ZERO;
            unitName = "Intel NPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] ü§ñ Auto-Select: Intel NPU aktiviert";
        } else if (intelGpuAvailable) {
            currentUnit = INTEL_GPU_OPENCL;
            configureIntelGpu();
            unitName = "Intel GPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üéØ Auto-Select: Intel GPU aktiviert";
        } else if (gpuAvailable) {
            currentUnit = GPU_OPENCL;
            unitName = "Generische GPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üñ•Ô∏è Auto-Select: Generische GPU aktiviert";
        } else {
            currentUnit = CPU_ALL_CORES;
            unitName = "CPU (Auto-gew√§hlt)";
            qDebug() << "[HashEngine] üíª Auto-Select: CPU Fallback aktiviert";
        }
        break;
        
    case NPU_LEVEL_ZERO:
        if (!npuAvailable)
        {
            emit criticalError("Intel NPU nicht verf√ºgbar", "NPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = NPU_LEVEL_ZERO;
        unitName = "Intel NPU";
        break;
        
    case INTEL_GPU_OPENCL:
        if (!intelGpuAvailable)
        {
            emit criticalError("Intel GPU nicht verf√ºgbar", "Intel GPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = INTEL_GPU_OPENCL;
        configureIntelGpu();
        unitName = "Intel GPU";
        break;
        
    case GPU_OPENCL:
        if (!gpuAvailable)
        {
            emit criticalError("GPU nicht verf√ºgbar", "GPU wurde angefordert aber ist nicht verf√ºgbar. System stoppt.");
            return;
        }
        currentUnit = GPU_OPENCL;
        unitName = "GPU";
        break;
        
    case CPU_ALL_CORES:
        currentUnit = CPU_ALL_CORES;
        unitName = "CPU";
        break;
    }

    emit processingUnitChanged(currentUnit);
    std::cout << "‚öôÔ∏è Hash-Engine auf " << unitName.toUtf8().constData() << " umgestellt" << std::endl;
}

void HashEngine::setPresetManager(QObject *presetManager)
{
    // PresetManager f√ºr FTP-Credential-Abfrage setzen
    this->presetManager = presetManager;
    qDebug() << "[HashEngine] üîê PresetManager f√ºr FTP-Credentials gesetzt";
}

void HashEngine::setExpectedFilesCount(int count)
{
    expectedFilesCount = count;
    qDebug() << "[HashEngine] üìä Erwarte insgesamt" << expectedFilesCount << "Dateien f√ºr Hash-Berechnung";
}

void HashEngine::configureIntelGpu()
{
#ifdef ENABLE_OPENCL
    if (currentUnit == INTEL_GPU_OPENCL && openclInitialized)
    {
        // Intel GPU-spezifische Optimierungen
        size_t preferredWorkGroupSize = 256; // Optimiert f√ºr Intel Xe
        // Weitere Intel-spezifische Konfiguration hier
        std::cout << "üîß Intel GPU Optimierungen aktiviert (WorkGroup: 256)" << std::endl;
    }
#endif
}

QString HashEngine::calculateFileHash(const QString &filePath)
{
    // ‚úÖ CRITICAL FIX: Handle FTP URLs before QFileInfo to prevent segfault
    if (filePath.startsWith("ftp://"))
    {
        // üîá REDUCED LOGGING: Nur bei URL-Bereinigung loggen
        
        // ‚úÖ FIX: Remove |size suffix from FTP URLs
        QString cleanFtpUrl = filePath;
        if (cleanFtpUrl.contains("|")) {
            cleanFtpUrl = cleanFtpUrl.split("|").first();
            qDebug() << "[HashEngine] üßπ FTP-URL bereinigt (|size):" << cleanFtpUrl.right(60);
        }
        
        // üîß CRITICAL FIX: Remove duplicate path segments with ///
        if (cleanFtpUrl.contains("///")) {
            // Format: ftp://host:port/BAD_PATH///GOOD_PATH
            // Wir wollen nur: ftp://host:port/GOOD_PATH
            QRegularExpression ftpRegex("^(ftp://[^/]+)(/.*?)(///)(.+)$");
            QRegularExpressionMatch match = ftpRegex.match(cleanFtpUrl);
            if (match.hasMatch()) {
                QString ftpHost = match.captured(1);  // ftp://host:port
                QString realPath = match.captured(4); // Der Pfad nach ///
                cleanFtpUrl = ftpHost + realPath;
                qDebug() << "[HashEngine] üîß Bereinigter FTP-Pfad:" << cleanFtpUrl;
            }
        }
    // üîí Wichtig: F√ºr korrekte Duplikat-Erkennung IMMER Inhalts-Hash berechnen
    // NPU- oder Feature-Vektor-Ergebnisse sind zus√§tzlich m√∂glich, ersetzen aber nicht den Content-Hash.
    // ‚úÖ FTP-Hash-Berechnung (streaming, vollst√§ndiger Inhalt)
        return calculateFtpFileHash(cleanFtpUrl, currentAlgorithm);
    }

    // ‚úÖ SAFETY: Only create QFileInfo for local files (not FTP URLs)
    QFileInfo fileInfo(filePath);
    if (!fileInfo.exists() || !fileInfo.isReadable())
    {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Datei nicht lesbar:" << filePath;
        return QString(); // Don't emit error for cleaner processing
    }

    // üöÄ GPU-BESCHLEUNIGUNG: Videos bevorzugt auf GPU/OpenCL
    QString ext = QFileInfo(filePath).suffix().toLower();
    bool isVideo = QStringList({"mp4","avi","mkv","mov","wmv","flv","webm","m4v","3gp"}).contains(ext);
    if (isVideo && (intelGpuAvailable || gpuAvailable)) {
        ProcessingUnit prev = currentUnit;
        if (intelGpuAvailable) currentUnit = INTEL_GPU_OPENCL; else currentUnit = GPU_OPENCL;
        QString gpuHash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        // Fallbacks liefern Fehlercodes-Strings wie *_FAILED ‚Äì dann CPU nehmen
        if (!gpuHash.isEmpty() && !gpuHash.endsWith("FAILED") && !gpuHash.contains("NOT_AVAILABLE") ) {
            currentUnit = prev;
            hashCount++;
            return gpuHash;
        }
        currentUnit = prev; // Restore
        // üîá GPU-Fallback nur bei debug-mode loggen
        if (gpuHash.isEmpty() || gpuHash.endsWith("FAILED")) {
            qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Videohash fehlgeschlagen ‚Üí CPU-Fallback:" << filePath.right(50);
        }
    }

    // üöÄ NPU-BESCHLEUNIGUNG: Wenn NPU verf√ºgbar, nutze GPU als beschleunigten Fallback
    QString hash;
    if (currentUnit == NPU_LEVEL_ZERO && npuAvailable) {
        qDebug() << "[HashEngine] ü§ñ NPU aktiv ‚Üí GPU-beschleunigte Hash-Berechnung f√ºr:" << filePath;
        emit statusUpdate("üß† NPU+GPU", QString("Berechnet: %1").arg(QFileInfo(filePath).fileName()));
        // NPU nutzt GPU f√ºr Hash-Berechnung (Intel NPU + Intel GPU Kombination)
        if (intelGpuAvailable || gpuAvailable) {
            hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
            if (!hash.isEmpty()) {
                qDebug() << "[HashEngine] ‚úÖ NPU+GPU-Hash erfolgreich:" << hash.left(16) + "...";
                emit npuActivitySignal(75); // NPU zeigt Aktivit√§t
                return hash;
            }
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è NPU-Fallback zu CPU f√ºr:" << filePath;
        emit statusUpdate("üíª CPU-Hash", QString("NPU-Fallback: %1").arg(QFileInfo(filePath).fileName()));
        emit npuActivitySignal(25); // NPU zeigt geringe Aktivit√§t
    }
    
    // üöÄ GPU-BESCHLEUNIGUNG: Wenn NPU nicht verf√ºgbar, automatisch GPU verwenden
    if (!npuAvailable && (gpuAvailable || intelGpuAvailable)) {
        qDebug() << "[HashEngine] üéØ NPU nicht verf√ºgbar ‚Üí GPU-Hashing f√ºr:" << filePath;
        emit statusUpdate("‚ö° GPU-Hash", QString("Berechnet: %1").arg(QFileInfo(filePath).fileName()));
        hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        if (!hash.isEmpty()) {
            qDebug() << "[HashEngine] ‚úÖ GPU-Hash erfolgreich:" << hash.left(16) + "...";
            return hash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Fallback zu CPU f√ºr:" << filePath;
        emit statusUpdate("üíª CPU-Hash", QString("GPU-Fallback: %1").arg(QFileInfo(filePath).fileName()));
    } else if (gpuAvailable || intelGpuAvailable) {
        qDebug() << "[HashEngine] ‚ö° GPU-beschleunigte Hash-Berechnung f√ºr:" << filePath;
        emit statusUpdate("‚ö° GPU-Hash", QString("Berechnet: %1").arg(QFileInfo(filePath).fileName()));
        hash = calculateGpuAcceleratedHash(filePath, currentAlgorithm);
        if (!hash.isEmpty()) {
            qDebug() << "[HashEngine] ‚úÖ GPU-Hash erfolgreich:" << hash.left(16) + "...";
            return hash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è GPU-Fallback zu CPU f√ºr:" << filePath;
        emit statusUpdate("üíª CPU-Hash", QString("GPU-Fallback: %1").arg(QFileInfo(filePath).fileName()));
    }
    
    // CPU-Fallback f√ºr normale Hash-Berechnung
    if (currentHashMode == QUICK_HASH)
    {
        hash = calculateQuickHash(filePath, currentAlgorithm);
    }
    else
    {
        hash = calculateFullHash(filePath, currentAlgorithm);
    }

    hashCount++;
    return hash;
}

// üöÄ SIMD SHA256-NI: CPU Hardware-accelerated SHA256 (Intel SHA Extensions)
// Expected speedup: +20-30% compared to generic software implementation
#ifdef __x86_64__

// Check if CPU supports SHA256-NI
static bool has_sha_ni() {
    static int result = -1;
    if (result != -1) return result;
    
    unsigned int eax, ebx, ecx, edx;
    if (__get_cpuid(7, &eax, &ebx, &ecx, &edx) && (ebx & (1 << 29))) {
        result = 1;
        return true;
    }
    result = 0;
    return false;
}

// SHA256-NI implementation using Intel SHA Extensions
QString HashEngine::calculateSha256WithNI(const QString &filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        return QString();
    }

    // Use OpenSSL EVP with SHA256-NI if available
    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    if (!mdctx) {
        file.close();
        return QString();
    }

    // Try to use SHA256 with hardware acceleration
    const EVP_MD *md = EVP_sha256();
    if (!md || EVP_DigestInit_ex(mdctx, md, nullptr) != 1) {
        EVP_MD_CTX_free(mdctx);
        file.close();
        return QString();
    }

    // Read file in optimized 8MB chunks (from previous optimization)
    const qint64 bufferSize = 8388608; // 8MB blockSize
    QByteArray buffer(bufferSize, 0);

    qint64 bytesRead = 0;
    while (!file.atEnd()) {
        bytesRead = file.read(buffer.data(), bufferSize);
        if (bytesRead < 0) {
            EVP_MD_CTX_free(mdctx);
            file.close();
            return QString();
        }
        if (EVP_DigestUpdate(mdctx, buffer.data(), bytesRead) != 1) {
            EVP_MD_CTX_free(mdctx);
            file.close();
            return QString();
        }
    }

    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int digest_len = 0;

    if (EVP_DigestFinal_ex(mdctx, digest, &digest_len) != 1) {
        EVP_MD_CTX_free(mdctx);
        file.close();
        return QString();
    }

    EVP_MD_CTX_free(mdctx);
    file.close();

    // Convert to hex string - Qt6 kompatibel
    QString resultString;
    for (unsigned int i = 0; i < digest_len; ++i) {
        resultString.append(QString::asprintf("%02x", digest[i]));
    }

    if (has_sha_ni()) {
        qDebug() << "[HashEngine] üöÄ SHA256-NI (Hardware) f√ºr:" << QFileInfo(filePath).fileName();
    }

    return resultString;
}

#else

// Fallback for non-x86 architectures
QString HashEngine::calculateSha256WithNI(const QString &filePath) {
    // Fall back to standard calculateFullHash for non-x86
    return calculateFullHash(filePath, SHA256);
}

#endif

QString HashEngine::calculateFullHash(const QString &filePath, Algorithm algo)
{
    // ÔøΩ DEBUG: Check file path details
    qDebug() << "[HashEngine] üìÇ calculateFullHash called with path:" << filePath;
    qDebug() << "[HashEngine] üìÇ Path length:" << filePath.length();
    qDebug() << "[HashEngine] üìÇ File exists:" << QFileInfo(filePath).exists();
    qDebug() << "[HashEngine] üìÇ Is absolute:" << QFileInfo(filePath).isAbsolute();
    qDebug() << "[HashEngine] üìÇ Is readable:" << QFileInfo(filePath).isReadable();
    
    // ÔøΩüöÄ SIMD SHA256-NI: Use hardware-accelerated SHA256 if available
    if (algo == SHA256) {
        QString niHash = calculateSha256WithNI(filePath);
        if (!niHash.isEmpty()) {
            return niHash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è SHA256-NI fallback zu QCryptographicHash";
    }
    
    // üöÄ SIMD SHA512-NI: Hardware-accelerated SHA512 (Option D)
    if (algo == SHA512) {
        QString niHash = calculateSha256WithNI(filePath); // SHA512-NI uses same EVP path
        if (!niHash.isEmpty()) {
            return niHash;
        }
        qDebug() << "[HashEngine] ‚ö†Ô∏è SHA512-NI fallback zu QCryptographicHash";
    }
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly))
    {
        qDebug() << "[HashEngine] ‚ùå‚ùå‚ùå FULL-HASH: DATEI KANN NICHT GE√ñFFNET WERDEN:" << filePath;
        qDebug() << "[HashEngine] ‚ùå Fehler:" << file.errorString();
        return QString();
    }

    QCryptographicHash::Algorithm qtAlgo;
    switch (algo)
    {
    case MD5:
        qtAlgo = QCryptographicHash::Md5;
        break;
    case SHA1:
        qtAlgo = QCryptographicHash::Sha1;
        break;
    case SHA256:
        qtAlgo = QCryptographicHash::Sha256;
        break;
    case SHA512:
        qtAlgo = QCryptographicHash::Sha512;
        break;
    case SHA3:
        qtAlgo = QCryptographicHash::Sha3_256;
        break;
    case BLAKE2:
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        qtAlgo = QCryptographicHash::Blake2b_256;
#else
        qtAlgo = QCryptographicHash::Sha256; // Qt5 fallback
#endif
        break;
    case BLAKE3:
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        qtAlgo = QCryptographicHash::Blake2b_256;
#else
        qtAlgo = QCryptographicHash::Sha256; // Qt5 fallback
#endif
        break;
    case XXHASH:
    case MURMUR3:
    case CITYHASH:
    case FARMHASH:
    case HIGHWAY:
    case METROHASH:
    case SPOOKY:
        // Fast hash algos - fallback to MD5 for now (similar speed)
        // TODO: Implement native xxHash/Murmur3 for better performance
        qtAlgo = QCryptographicHash::Md5;
        break;
    }

    QCryptographicHash hash(qtAlgo);

    // üéØ INTELLIGENTER SAMPLE-HASH: Anfang + Ende
    // Verhindert falsche Duplikate bei Dateien mit gleichen Headern (z.B. VOB, ISO)
    qint64 fileSize = file.size();
    const qint64 SAMPLE_SIZE = 1048576;  // 1MB pro Sample
    
    if (fileSize <= SAMPLE_SIZE * 2) {
        // Kleine Dateien (< 2MB): Hashe komplett
        while (!file.atEnd()) {
            QByteArray buffer = file.read(65536);
            if (buffer.isEmpty()) break;
            hash.addData(buffer);
        }
    } else {
        // Gro√üe Dateien: Sample-Hash (Anfang + Ende)
        
        // 1Ô∏è‚É£ ANFANG: Erste 1MB
        file.seek(0);
        QByteArray startChunk = file.read(SAMPLE_SIZE);
        hash.addData(startChunk);
        
        // 2Ô∏è‚É£ ENDE: Letzte 1MB
        qint64 endOffset = fileSize - SAMPLE_SIZE;
        file.seek(endOffset);
        QByteArray endChunk = file.read(SAMPLE_SIZE);
        hash.addData(endChunk);
    }

    return hash.result().toHex();
}

QString HashEngine::calculateQuickHash(const QString &filePath, Algorithm algo)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly))
    {
        qDebug() << "[HashEngine] ‚ùå‚ùå‚ùå DATEI KANN NICHT GE√ñFFNET WERDEN:" << filePath;
        qDebug() << "[HashEngine] ‚ùå Fehler:" << file.errorString();
        qDebug() << "[HashEngine] ‚ùå Existiert:" << QFileInfo(filePath).exists();
        qDebug() << "[HashEngine] ‚ùå Lesbar:" << QFileInfo(filePath).isReadable();
        return QString();
    }

    QCryptographicHash::Algorithm qtAlgo;
    switch (algo)
    {
    case MD5:
        qtAlgo = QCryptographicHash::Md5;
        break;
    case SHA1:
        qtAlgo = QCryptographicHash::Sha1;
        break;
    case SHA256:
        qtAlgo = QCryptographicHash::Sha256;
        break;
    case SHA512:
        qtAlgo = QCryptographicHash::Sha512;
        break;
    case SHA3:
        qtAlgo = QCryptographicHash::Sha3_256;
        break;
    case BLAKE2:
        qtAlgo = QCryptographicHash::Sha256; // Qt5 fallback
        break;
    case BLAKE3:
        qtAlgo = QCryptographicHash::Sha256; // Qt5 fallback
        break;
    case XXHASH:
    case MURMUR3:
    case CITYHASH:
    case FARMHASH:
    case HIGHWAY:
    case METROHASH:
    case SPOOKY:
        qtAlgo = QCryptographicHash::Md5; // Fast fallback
        break;
    }

    QCryptographicHash hash(qtAlgo);
    qint64 fileSize = file.size();
    
    // ‚úÖ SPEED OPTIMIZATION: Adaptive hash size based on file size
    int blockSize = 1024; // Default 1KB
    if (fileSize > 100 * 1024 * 1024) { // Files > 100MB
        blockSize = 4096; // Use 4KB blocks for better uniqueness
    } else if (fileSize > 10 * 1024 * 1024) { // Files > 10MB
        blockSize = 2048; // Use 2KB blocks
    }
    
    // First block
    QByteArray firstBlock = file.read(blockSize);
    hash.addData(firstBlock);

    // Last block (if file is larger than 2 * blockSize)
    if (fileSize > 2 * blockSize)
    {
        file.seek(fileSize - blockSize);
        QByteArray lastBlock = file.read(blockSize);
        hash.addData(lastBlock);
        
        // ‚úÖ MIDDLE BLOCK for very large files (> 50MB)
        if (fileSize > 50 * 1024 * 1024) {
            file.seek(fileSize / 2); // Middle of file
            QByteArray middleBlock = file.read(blockSize);
            hash.addData(middleBlock);
        }
    }

    // Add file size and modification time for better uniqueness
    hash.addData(QByteArray::number(fileSize));

    return hash.result().toHex();
}

void HashEngine::calculateFileHashAsync(const QString &filePath, const QString &algorithm)
{
    QMutexLocker locker(&queueMutex);
    
    // üß† SMART-DETECT: Store per-file algorithm override (thread-safe)
    if (!algorithm.isEmpty()) {
        Algorithm selectedAlgo = currentAlgorithm; // Default fallback
        
        // Parse algorithm string (case-insensitive)
        QString algoUpper = algorithm.toUpper();
        if (algoUpper == "MD5") selectedAlgo = MD5;
        else if (algoUpper == "SHA1") selectedAlgo = SHA1;
        else if (algoUpper == "SHA256") selectedAlgo = SHA256;
        else if (algoUpper == "SHA512") selectedAlgo = SHA512;
        else if (algoUpper == "SHA3") selectedAlgo = SHA3;
        else if (algoUpper == "XXHASH") selectedAlgo = XXHASH;
        else if (algoUpper == "BLAKE2") selectedAlgo = BLAKE2;
        else if (algoUpper == "BLAKE3") selectedAlgo = BLAKE3;
        else if (algoUpper == "MURMUR3") selectedAlgo = MURMUR3;
        else if (algoUpper == "CITYHASH") selectedAlgo = CITYHASH;
        else if (algoUpper == "FARMHASH") selectedAlgo = FARMHASH;
        else if (algoUpper == "HIGHWAY") selectedAlgo = HIGHWAY;
        else if (algoUpper == "METROHASH") selectedAlgo = METROHASH;
        else if (algoUpper == "SPOOKY") selectedAlgo = SPOOKY;
        else {
            qWarning() << "[HashEngine] ‚ö†Ô∏è Unknown algorithm:" << algorithm << "- using default";
        }
        
        // Thread-safe per-file algorithm storage
        QMutexLocker algoLocker(&algorithmOverrideMutex);
        fileAlgorithmOverrides[filePath] = selectedAlgo;
        
        qDebug() << "[HashEngine] üß† Smart-Detect: Nutze" << algorithm << "f√ºr" << QFileInfo(filePath).fileName();
    }
    
    // üõ°Ô∏è CRITICAL FIX: Prevent infinite loops by checking for already processed files
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    if (canonicalPath.isEmpty()) canonicalPath = filePath; // Fallback for network URLs
    
    // ‚ö†Ô∏è REMOVED: Duplicate check here causes race condition with chunked processing
    // The check in processOneFile() is sufficient
    
    hashQueue.enqueue(filePath);
    
    // üîç DEBUG: Log exact path being added to queue
    qDebug() << "[HashEngine] üì• ENQUEUE:" << filePath;
    qDebug() << "[HashEngine] üì• filePath.length():" << filePath.length() << "exists:" << QFileInfo(filePath).exists();

    if (!processTimer->isActive())
    {
        processTimer->start();
    }
}

void HashEngine::calculateMultipleHashes(const QStringList &filePaths)
{
    // ÔøΩ PARALLEL OPTIMIZATION: Use ThreadPool for massive speedup!
    qDebug() << "[HashEngine] üöÄ PARALLEL HASH requested for" << filePaths.size() << "files";
    
    // Filter bereits verarbeitete Dateien
    QStringList filesToProcess;
    {
        QMutexLocker locker(&queueMutex);
        for (const QString &path : filePaths) {
            QString canonicalPath = QFileInfo(path).canonicalFilePath();
            if (canonicalPath.isEmpty()) canonicalPath = path;
            
            if (!processedFilePaths.contains(canonicalPath)) {
                filesToProcess.append(path);
                processedFilePaths.insert(canonicalPath);
            }
        }
    }
    
    if (filesToProcess.isEmpty()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Alle Dateien bereits verarbeitet";
        return;
    }
    
    // ‚úÖ DON'T add to expectedFilesCount - Scanner already set it via setExpectedFilesCount()
    qDebug() << "[HashEngine] üìä Processing" << filesToProcess.size() << "files (total expected:" << expectedFilesCount << ")";
    
    emit hashProgress(processedFiles.load(), expectedFilesCount);
    
    // üöÄ USE PARALLEL CALCULATION (ThreadPool) statt sequentieller Queue!
    calculateHashesParallel(filesToProcess);
    
    std::cout << "üìä " << filesToProcess.size() << "/" << filePaths.size() << " neue Dateien zur PARALLELEN Hash-Berechnung eingereicht" << std::endl;
}

// ÔøΩ PARALLEL HASH CALCULATION: Multiple files hashed simultaneously via ThreadPool
// Expected speedup: +2-3x (parallel execution on multiple cores)
// GPU-Hash-Cache is mutex-protected (gpuHashCacheMutex) for thread-safety
void HashEngine::calculateHashesParallel(const QStringList &filePaths)
{
    // üõë Reset stop flag for new scan
    m_stopRequested.store(false);
    
    qDebug() << "[HashEngine] üßµ PARALLEL HASH: Starten von" << filePaths.size() << "parallelen Hash-Berechnungen...";
    
    QThreadPool* pool = QThreadPool::globalInstance();
    
    // üåê FTP-SPECIAL: Count FTP URLs to adjust ThreadPool
    int ftpFileCount = 0;
    for (const QString &path : filePaths) {
        if (path.startsWith("ftp://") || path.startsWith("ftps://")) {
            ftpFileCount++;
        }
    }
    
    // üöÄ ULTRA-OPTIMIZATION: F√ºr 5M+ Dateien maximale ThreadPool-Skalierung
    int cpuCores = QThread::idealThreadCount();
    if (filePaths.size() > 1000000) {
        // Bei 5M+ Dateien: 4x CPU-Cores f√ºr MAXIMALE Parallelit√§t
        pool->setMaxThreadCount(cpuCores * 4);  // 4x Cores bei Millionen von Dateien
        qDebug() << "[HashEngine] üöÄüöÄüöÄ ULTRA-MASSIVE DATASET:" << filePaths.size() << "Dateien ‚Üí ThreadPool MASSIV erweitert auf" << pool->maxThreadCount() << "Threads (4x Cores)";
    } else if (filePaths.size() > 100000) {
        // Bei 100K-1M Dateien: 2x CPU-Cores
        pool->setMaxThreadCount(cpuCores * 2);
        qDebug() << "[HashEngine] üöÄ MASSIVE DATASET:" << filePaths.size() << "Dateien ‚Üí ThreadPool erweitert auf" << pool->maxThreadCount() << "Threads (2x Cores)";
    } else if (filePaths.size() > 10000) {
        pool->setMaxThreadCount(cpuCores * 1.5);
    } else if (ftpFileCount > 10) {
        // üåê FTP-BLOCKING-WORKAROUND: FTP-Downloads blockieren Worker-Threads
        // ‚Üí Erh√∂he ThreadPool MASSIV um blockierte Threads zu kompensieren
        int minThreads = qMin(ftpFileCount * 2, 2000);  // 2x FTP-Files, max 2000 Threads
        pool->setMaxThreadCount(minThreads);
        qDebug() << "[HashEngine] üåê FTP-DATASET:" << ftpFileCount << "FTP-Dateien erkannt ‚Üí ThreadPool auf" << pool->maxThreadCount() << "Threads (2x FTP-Count)";
    }
    
    
    // üßπ CRITICAL: Clear processed files cache to allow re-processing
    processedFilePaths.clear();
    int submittedCount = 0;
    for (const QString &filePath : filePaths) {
        // üõ°Ô∏è Skip already processed files
        QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
        if (canonicalPath.isEmpty()) canonicalPath = filePath;
        
        if (processedFilePaths.contains(canonicalPath)) {
            qDebug() << "[HashEngine] ‚ö†Ô∏è Datei bereits verarbeitet, √ºberspringe:" << filePath;
            continue;
        }
        
        processedFilePaths.insert(canonicalPath);
        
        // üß† SMART ROUTING: Bilder ‚Üí NPU Batch Queue, Rest ‚Üí direkter Worker
        QFileInfo fileInfo(filePath);
        QString suffix = fileInfo.suffix().toLower();
        bool isImage = (suffix == "jpg" || suffix == "jpeg" || suffix == "png" || 
                       suffix == "bmp" || suffix == "gif" || suffix == "webp" || 
                       suffix == "heic" || suffix == "heif");
        
        if (isImage && isNpuAvailable()) {
            // üß† Bilder gehen in NPU Batch Queue f√ºr effiziente Parallel-Verarbeitung
            QMutexLocker locker(&npuBatchMutex);
            npuBatchQueue.enqueue(filePath);
            
            qDebug() << "[HashEngine] üß† Bild in NPU-Batch-Queue:" << fileInfo.fileName() 
                     << "Queue:" << npuBatchQueue.size() << "/" << NPU_BATCH_SIZE;
            
            // Start Batch-Processing wenn Queue voll
            if (npuBatchQueue.size() >= NPU_BATCH_SIZE) {
                locker.unlock();
                qDebug() << "[HashEngine] üöÄ NPU-Batch voll - starte Verarbeitung";
                QTimer::singleShot(0, this, &HashEngine::processNpuBatchQueue);
            }
            submittedCount++;
            continue;
        }
        
        // Create and submit worker to ThreadPool (non-image files)
        ParallelHashWorker* worker = new ParallelHashWorker(this, filePath);
        pool->start(worker);  // Auto-delete after completion
        submittedCount++;
    }
    
    // üß† Verarbeite verbleibende Bilder in NPU-Queue (auch wenn Batch nicht voll)
    {
        QMutexLocker locker(&npuBatchMutex);
        if (!npuBatchQueue.isEmpty()) {
            int remaining = npuBatchQueue.size();
            locker.unlock();
            qDebug() << "[HashEngine] üß† Verarbeite verbleibende" << remaining << "Bilder in NPU-Queue";
            QTimer::singleShot(100, this, &HashEngine::processNpuBatchQueue);
        }
    }
    
    emit hashProgress(0, filePaths.size());
    qDebug() << "[HashEngine] ‚úÖ PARALLEL:" << submittedCount << "Worker in ThreadPool eingereicht (max" 
             << pool->maxThreadCount() << "Threads)";
}

// ÔøΩüß† NPU-FIRST: Feature-Vector-based Image Processing (KEIN Hash!)
void HashEngine::processImagesWithNpuUltraFast(const QStringList &imageFiles)
{
    qDebug() << "[HashEngine] üß† NPU-FIRST: Verarbeite" << imageFiles.size() << "Bilder mit Feature-Vectors!";
    
    // TOLERANTER NPU-FALLBACK: Keine kritischen Fehler mehr!
    if (!isNpuAvailable()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Fallback zu Standard-Hash f√ºr" << imageFiles.size() << "Dateien";
        // Statt Fehlermeldung: Einfach normal weiterarbeiten
        for (const QString &imageFile : imageFiles) {
            QString hash = calculateFileHash(imageFile);
            emitHashCalculated(imageFile, hash); // FTP ist nicht lokal
        }
        return;
    }
    
    // üöÄ NPU Feature-Vector Processing f√ºr jedes Bild
    int processed = 0;
    for (const QString &imagePath : imageFiles) {
        qDebug() << "[HashEngine] üñºÔ∏è NPU verarbeitet Bild:" << QFileInfo(imagePath).fileName();
        
        // Feature-Vector-Extraktion (2048-dimensional vector)
        QVector<float> featureVector = extractImageFeatures(imagePath);
        
        if (!featureVector.isEmpty()) {
            // Cosine-Similarity-based Duplicate Detection
            QString vectorHash = calculateFeatureVectorHash(featureVector);
            
            // Emit als "Hash" f√ºr Kompatibilit√§t mit Scanner-Pipeline
            emitHashCalculated(imagePath, vectorHash); // FTP ist nicht lokal
            processed++;
            
            qDebug() << "[HashEngine] ‚úÖ NPU Feature-Vector erstellt f√ºr:" << QFileInfo(imagePath).fileName();
        } else {
            qWarning() << "[HashEngine] ‚ùå NPU Feature-Vector-Extraktion fehlgeschlagen:" << imagePath;
            // Fallback: Empty hash f√ºr kompatibilit√§t
            emit hashCalculated(imagePath, "npu_failed_" + QFileInfo(imagePath).fileName(), false); // FTP ist nicht lokal
        }
        
        // Progress-Update
        emit hashProgress(processed, imageFiles.size());
    }
    
    qDebug() << "[HashEngine] üéØ NPU-FIRST abgeschlossen:" << processed << "/" << imageFiles.size() << "Bilder verarbeitet";
}

void HashEngine::processNextHash()
{
    QMutexLocker locker(&queueMutex);

    if (hashQueue.isEmpty())
    {
        processTimer->stop();
        
        // üîß DEADLOCK-PREVENTION: Track progress to detect stuck threads
        static int lastProcessedCount = 0;
        static int noProgressIterations = 0;
        int currentProcessed = processedFiles.load();
        
        if (currentProcessed == lastProcessedCount) {
            noProgressIterations++;
            qDebug() << "[HashEngine] ‚ö†Ô∏è Keine Fortschritte:" << noProgressIterations << "Iterationen bei" << currentProcessed << "/" << expectedFilesCount << "Dateien";
            
            // üö® TIMEOUT: Nach 30 Sekunden ohne Fortschritt (60 * 500ms) ‚Üí Abschluss erzwingen
            if (noProgressIterations >= 60) {
                qWarning() << "[HashEngine] ‚è∞ TIMEOUT: Queue leer und keine Fortschritte nach 30 Sekunden!";
                qWarning() << "[HashEngine] üìä Verarbeitet:" << currentProcessed << "von" << expectedFilesCount << "erwartet (" << (expectedFilesCount - currentProcessed) << "fehlen)";
                qWarning() << "[HashEngine] üöÄ Erzwinge Scan-Abschluss mit vorhandenen Hashes...";
                noProgressIterations = 0;
                startSortingPhase(); // Fahre mit vorhandenen Hashes fort
                return;
            }
        } else {
            lastProcessedCount = currentProcessed;
            noProgressIterations = 0; // Reset counter wenn Fortschritt gemacht wird
        }
        
        // ‚úÖ CRITICAL FIX: Nur starten wenn ALLE erwarteten Dateien verarbeitet wurden
        if (expectedFilesCount > 0 && currentProcessed >= expectedFilesCount) {
            // üöÄ NACH HASH-BERECHNUNG: STARTE SORTIERUNG UND DUPLIKAT-VERGLEICH!
            qDebug() << "[HashEngine] ‚úÖ Hash-Berechnung VOLLST√ÑNDIG abgeschlossen - starte Sortierung...";
            qDebug() << "[HashEngine] üìä Verarbeitet:" << currentProcessed << "/" << expectedFilesCount << "Dateien";
            emit statusUpdate("Sortierung", "Startet Sortierung nach Hashes");
            
            // Phase 2: Sortierung nach Hashes
            startSortingPhase();
        } else {
            qDebug() << "[HashEngine] ‚è≥ Queue leer, aber noch nicht alle Dateien verarbeitet (" 
                     << currentProcessed << "/" << expectedFilesCount << "), warte...";
            // Restart timer to check again later
            processTimer->start();
        }
        
        return;
    }

    // ‚ö†Ô∏è SINGLE-THREADED PROCESSING to fix segmentation fault
    QString filePath = hashQueue.dequeue();
    int remaining = hashQueue.size();
    locker.unlock();
    
    // üîç DEBUG: Log exact path being processed
    qDebug() << "[HashEngine] üîì DEQUEUE:" << filePath;
    qDebug() << "[HashEngine] üîì filePath.length():" << filePath.length() << "isAbsolute:" << QFileInfo(filePath).isAbsolute();
    qDebug() << "[HashEngine] üîì exists:" << QFileInfo(filePath).exists() << "isReadable:" << QFileInfo(filePath).isReadable();

    // üñ•Ô∏è GUI Responsiveness: processEvents alle 5 Dateien (nicht zu h√§ufig)
    static int processCounter = 0;
    if (++processCounter % 5 == 0) {
        // REMOVED: QApplication::processEvents(QEventLoop::ExcludeUserInputEvents);
    }

    // ÔøΩüõ°Ô∏è CRITICAL FIX: Normalize path once and avoid double-skip of the just dequeued file
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    if (canonicalPath.isEmpty()) canonicalPath = filePath; // Fallback for network URLs
    
    // Do not skip the item we just dequeued; duplicates are filtered at enqueue time.
    // Only skip if another worker already processed it (not our single-thread path), which shouldn't happen now.
    // Keep the processedFilePaths insert here to guard against re-entrancy from async signals.
    if (!processedFilePaths.contains(canonicalPath)) {
        processedFilePaths.insert(canonicalPath);
    }

    // üß† SMART-DETECT: Check if file has algorithm override (thread-safe)
    Algorithm fileAlgorithm = currentAlgorithm; // Default
    {
        QMutexLocker algoLocker(&algorithmOverrideMutex);
        if (fileAlgorithmOverrides.contains(filePath)) {
            fileAlgorithm = fileAlgorithmOverrides[filePath];
            fileAlgorithmOverrides.remove(filePath); // Cleanup after use
        }
    }

    // Process ONE file at a time (thread-safe) with selected algorithm
    QString hash;
    
    // üî• CRITICAL FIX: FTP files need special handling!
    if (filePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üåê FTP-Datei erkannt in processOneFile, verwende FTP-Stream-Hash";
        
        // Extract host from URL: ftp://192.168.1.224:21/path/file.ext ‚Üí 192.168.1.224
        QUrl url(filePath);
        QString host = url.host();
        
        // Lookup credentials for this host
        QMutexLocker locker(&ftpCredentialsMutex);
        QString username, password;
        if (ftpCredentials.contains(host)) {
            username = ftpCredentials[host].username;
            password = ftpCredentials[host].password;
            qDebug() << "[HashEngine] üîê Credentials gefunden f√ºr Host:" << host << "User:" << username;
        } else {
            qDebug() << "[HashEngine] ‚ö†Ô∏è KEINE Credentials f√ºr Host:" << host;
        }
        locker.unlock();
        
        // Use stored credentials (set by Scanner via setFtpCredentials)
        hash = calculateFtpStreamHash(filePath, username, password, fileAlgorithm);
    } else {
        hash = calculateFileHash(filePath, fileAlgorithm);
    }
    
    qDebug() << "[HashEngine] üîç Hash-Berechnung Ergebnis f√ºr" << QFileInfo(filePath).fileName() 
             << "‚Üí hash.isEmpty():" << hash.isEmpty() << "length:" << hash.length();

    // üîß CRITICAL FIX: Check if hash is already stored BEFORE incrementing counter
    if (!hash.isEmpty())
    {
        qDebug() << "[HashEngine] ‚úÖ Hash NICHT leer - rufe storeCalculatedHash() auf";
        
        // storeCalculatedHash() handles duplicate detection internally
        storeCalculatedHash(filePath, hash);
        emit hashCalculated(filePath, hash, !filePath.startsWith("ftp://")); // Lokale Datei wenn nicht FTP
    } else {
        qDebug() << "[HashEngine] ‚ùå Hash IST LEER - speichere NICHT!";
    }

    // ‚úÖ Progress-Update: Count all processed files
    processedFiles++;
    if (processedFiles % 10 == 0) { // Every 10 files
        qDebug() << "üöÄ Processed" << processedFiles << "files, remaining:" << remaining;
        
        // üßπ Periodic memory cleanup for local files too
        periodicMemoryCleanup();
    }
    
    // ‚ùå DEAKTIVIERT: Scanner sendet eigenes scanProgress-Signal mit korrekten Zahlen
    // HashEngine's expectedFilesCount z√§hlt nur lokale Dateien, nicht FTP
    // ‚úÖ FIX: Use expectedFilesCount (constant) instead of dynamic calculation
    // int totalFiles = (expectedFilesCount > 0) ? expectedFilesCount : (remaining + processedFiles.load());
    // emit hashProgress(processedFiles.load(), totalFiles);
}

void HashEngine::updateHashRate()
{
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();

    if (lastRateUpdate > 0)
    {
        qint64 timeDiff = currentTime - lastRateUpdate;
        if (timeDiff > 0)
        {
            int currentHashCount = hashCount.load();
            int rate = (currentHashCount * 1000) / timeDiff;
            hashRate.store(rate);
            emit hashRateChanged(rate);
        }
    }

    lastRateUpdate = currentTime;
    hashCount.store(0); // Reset f√ºr n√§chste Messung
}

#ifdef ENABLE_OPENCL
void HashEngine::initializeOpenCL()
{
    qDebug() << "[HashEngine] üîß ECHTE OpenCL-Initialisierung f√ºr GPU-Beschleunigung...";
    
    cl_int err;
    
    // 1. Platform ID ermitteln
    cl_uint numPlatforms;
    err = clGetPlatformIDs(0, nullptr, &numPlatforms);
    if (err != CL_SUCCESS || numPlatforms == 0) {
        qDebug() << "[HashEngine] ‚ùå Keine OpenCL Platforms gefunden";
        openclInitialized = false;
        return;
    }
    
    QVector<cl_platform_id> platforms(numPlatforms);
    clGetPlatformIDs(numPlatforms, platforms.data(), nullptr);
    
    // Intel Platform priorisieren
    cl_platform_id selectedPlatform = platforms[0]; // Default
    for (cl_platform_id platform : platforms) {
        char platformName[128];
        clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(platformName), platformName, nullptr);
        qDebug() << "[HashEngine] üîç OpenCL Platform gefunden:" << platformName;
        
        // Intel Platform bevorzugen
        if (QString(platformName).contains("Intel", Qt::CaseInsensitive)) {
            selectedPlatform = platform;
            qDebug() << "[HashEngine] ‚úÖ Intel OpenCL Platform ausgew√§hlt:" << platformName;
            break;
        }
    }
    
    // 2. Device ID ermitteln (GPU bevorzugt)
    cl_uint numDevices;
    cl_device_type deviceType = (currentUnit == INTEL_GPU_OPENCL || currentUnit == GPU_OPENCL) ? 
                               CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_ALL;
    
    err = clGetDeviceIDs(selectedPlatform, deviceType, 0, nullptr, &numDevices);
    if (err != CL_SUCCESS || numDevices == 0) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è Keine GPU gefunden, versuche CPU-Device...";
        err = clGetDeviceIDs(selectedPlatform, CL_DEVICE_TYPE_CPU, 0, nullptr, &numDevices);
        if (err != CL_SUCCESS || numDevices == 0) {
            qDebug() << "[HashEngine] ‚ùå Keine OpenCL Devices gefunden";
            openclInitialized = false;
            return;
        }
    }
    
    QVector<cl_device_id> devices(numDevices);
    clGetDeviceIDs(selectedPlatform, deviceType, numDevices, devices.data(), nullptr);
    
    device = devices[0]; // Erstes verf√ºgbares Device
    
    char deviceName[128];
    clGetDeviceInfo(device, CL_DEVICE_NAME, sizeof(deviceName), deviceName, nullptr);
    qDebug() << "[HashEngine] ‚úÖ OpenCL Device ausgew√§hlt:" << deviceName;
    
    // 3. Context erstellen
    context = clCreateContext(nullptr, 1, &device, nullptr, nullptr, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Context Creation fehlgeschlagen:" << err;
        openclInitialized = false;
        return;
    }
    
    // 4. Command Queue erstellen
    queue = clCreateCommandQueue(context, device, 0, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Command Queue Creation fehlgeschlagen:" << err;
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // 5. Kombiniertes Kernel Source laden (SHA256 + MD5)
    QString sha256KernelPath = "/home/nex/c++/kernels/sha256_kernel.cl";
    QString md5KernelPath = "/home/nex/c++/kernels/md5_kernel.cl";
    
    QFile sha256File(sha256KernelPath);
    QFile md5File(md5KernelPath);
    
    if (!sha256File.open(QIODevice::ReadOnly)) {
        qDebug() << "[HashEngine] ‚ùå SHA256 Kernel-Datei nicht gefunden:" << sha256KernelPath;
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    QByteArray combinedKernelSource = sha256File.readAll();
    sha256File.close();
    
    // MD5 Kernel hinzuf√ºgen (optional - fallback wenn nicht vorhanden)
    if (md5File.open(QIODevice::ReadOnly)) {
        combinedKernelSource.append("\n\n"); // Trenner
        combinedKernelSource.append(md5File.readAll());
        md5File.close();
        qDebug() << "[HashEngine] ‚úÖ MD5 Kernel Source hinzugef√ºgt";
    } else {
        qDebug() << "[HashEngine] ‚ö†Ô∏è MD5 Kernel-Datei nicht gefunden - nur SHA256 verf√ºgbar";
    }
    
    const char* kernelSourcePtr = combinedKernelSource.constData();
    size_t kernelSourceSize = combinedKernelSource.size();
    
    // 6. Program erstellen und kompilieren
    program = clCreateProgramWithSource(context, 1, &kernelSourcePtr, &kernelSourceSize, &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå OpenCL Program Creation fehlgeschlagen:" << err;
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    err = clBuildProgram(program, 1, &device, "-cl-std=CL2.0", nullptr, nullptr);
    if (err != CL_SUCCESS) {
        // Build Log ausgeben bei Fehlern
        size_t logSize;
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logSize);
        QByteArray buildLog(logSize, 0);
        clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, logSize, buildLog.data(), nullptr);
        qDebug() << "[HashEngine] ‚ùå OpenCL Build Error:" << buildLog;
        
        clReleaseProgram(program);
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // 7. Beide Kernel erstellen
    kernel = clCreateKernel(program, "sha256_hash", &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ùå SHA256 Kernel Creation fehlgeschlagen:" << err;
        clReleaseProgram(program);
        clReleaseCommandQueue(queue);
        clReleaseContext(context);
        openclInitialized = false;
        return;
    }
    
    // MD5 Kernel erstellen (optional)
    md5Kernel = clCreateKernel(program, "md5_hash", &err);
    if (err != CL_SUCCESS) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è MD5 Kernel Creation fehlgeschlagen - nur SHA256 verf√ºgbar:" << err;
        md5Kernel = nullptr;
    } else {
        qDebug() << "[HashEngine] ‚úÖ MD5 Kernel erfolgreich erstellt";
    }
    
    qDebug() << "[HashEngine] ‚úÖ ECHTE OpenCL-Initialisierung erfolgreich abgeschlossen!";
    qDebug() << "[HashEngine] üöÄ GPU-beschleunigte Hash-Berechnung ist bereit";
    openclInitialized = true;
}
#endif

void HashEngine::cleanup()
{
#ifdef ENABLE_OPENCL
    if (openclInitialized)
    {
        qDebug() << "[HashEngine] üßπ OpenCL Ressourcen werden freigegeben...";
        
        if (kernel) {
            clReleaseKernel(kernel);
            kernel = nullptr;
        }
        
        if (md5Kernel) {
            clReleaseKernel(md5Kernel);
            md5Kernel = nullptr;
        }
        
        if (program) {
            clReleaseProgram(program);
            program = nullptr;
        }
        
        if (queue) {
            clReleaseCommandQueue(queue);
            queue = nullptr;
        }
        
        if (context) {
            clReleaseContext(context);
            context = nullptr;
        }
        
        device = nullptr;
        openclInitialized = false;
        qDebug() << "[HashEngine] ‚úÖ OpenCL Cleanup abgeschlossen";
    }
#endif
    
    // üõ°Ô∏è CRITICAL: Clear processed files to prevent infinite loops in next scan
    processedFilePaths.clear();
    
    // üßπ ERWEITERTE MEMORY-BEREINIGUNG
    fileHashes.clear();
    ftpDownloadCache.clear();
    activeTempFiles.clear();
    
    // Force deallocation of large containers
    if (fileHashes.size() > 1000) {
        QHash<QString, QString> emptyHash;
        fileHashes.swap(emptyHash);
    }
    
    qDebug() << "[HashEngine] üõ°Ô∏è Processed files cache + Memory containers cleared";
}

// Getters
void HashEngine::setAlgorithm(Algorithm algo)
{
    currentAlgorithm = algo;
    std::cout << "üîß Hash-Algorithmus ge√§ndert" << std::endl;
    
    // Map algorithm enum to readable name
    QString algoName;
    switch(algo) {
        case MD5: algoName = "MD5"; break;
        case SHA1: algoName = "SHA1"; break;
        case SHA256: algoName = "SHA256"; break;
        case SHA512: algoName = "SHA512"; break;
        case XXHASH: algoName = "xxHash"; break;
        case SHA3: algoName = "SHA3"; break;
        default: algoName = "Unknown"; break;
    }
    
    emit statusUpdate("Hash-Algorithmus", QString("Ge√§ndert zu %1").arg(algoName));
}

void HashEngine::setHashMode(HashMode mode)
{
    currentHashMode = mode;
    std::cout << "üîß Hash-Modus: " << (mode == QUICK_HASH ? "Schnell" : "Vollst√§ndig") << std::endl;
}

bool HashEngine::isGpuAvailable() const { return gpuAvailable; }
bool HashEngine::isIntelGpuAvailable() const { return intelGpuAvailable; }
bool HashEngine::isNpuAvailable() const { return npuAvailable; }
int HashEngine::getHashRate() const { return hashRate.load(); }

// üõ°Ô∏è CRITICAL: Clear processed files cache to prevent infinite loops
void HashEngine::clearProcessedFiles()
{
    QMutexLocker locker(&queueMutex);
    processedFilePaths.clear();
    qDebug() << "[HashEngine] üõ°Ô∏è Processed files cache manually cleared";
}

// üßπ MEMORY MANAGEMENT: Periodic cleanup during long scans
void HashEngine::periodicMemoryCleanup() {
    static int cleanupCounter = 0;
    cleanupCounter++;
    
    // Light cleanup every 100 files
    if (cleanupCounter % 100 == 0) {
        // Remove old temp files
        QStringList expiredFiles;
        for (const QString &tempFile : activeTempFiles) {
            QFileInfo info(tempFile);
            if (!info.exists() || info.lastModified().secsTo(QDateTime::currentDateTime()) > 3600) {
                expiredFiles.append(tempFile);
            }
        }
        for (const QString &expired : expiredFiles) {
            activeTempFiles.remove(expired);
        }
        
        qDebug() << "[HashEngine] üßπ Light cleanup: removed" << expiredFiles.size() << "expired temp files";
    }
    
    // Aggressive cleanup every 1000 files
    if (cleanupCounter % 1000 == 0) {
        // Force container defragmentation if they're large
        if (fileHashes.size() > 5000) {
            QHash<QString, QString> compactHashes;
            compactHashes.reserve(fileHashes.size());
            compactHashes = fileHashes;
            fileHashes.swap(compactHashes);
            qDebug() << "[HashEngine] üíæ Aggressive cleanup: defragmented fileHashes with" << fileHashes.size() << "entries";
        }
        
        if (ftpDownloadCache.size() > 100) {
            ftpDownloadCache.clear();
            qDebug() << "[HashEngine] üíæ Aggressive cleanup: cleared FTP download cache";
        }
    }
}

void HashEngine::stopProcessing()
{
    // üõë Set stop flag for parallel workers
    m_stopRequested.store(true);
    qDebug() << "[HashEngine] üõë Stop flag set - parallel workers will abort";
    
    QMutexLocker locker(&queueMutex);
    
    // Stop all timers
    if (processTimer && processTimer->isActive()) {
        processTimer->stop();
        qDebug() << "[HashEngine] üõë Process timer stopped";
    }
    
    if (rateTimer && rateTimer->isActive()) {
        rateTimer->stop();
        qDebug() << "[HashEngine] üõë Rate timer stopped";
    }
    
    if (sortingTimer && sortingTimer->isActive()) {
        sortingTimer->stop();
        qDebug() << "[HashEngine] üõë Sorting timer stopped";
    }
    
    if (compareTimer && compareTimer->isActive()) {
        compareTimer->stop();
        qDebug() << "[HashEngine] üõë Compare timer stopped";
    }
    
    // Clear processing queues
    hashQueue.clear();
    gpuHashQueue.clear();      // üõë Stop GPU processing
    npuFeatureQueue.clear();   // üõë Stop NPU processing
    processedFilePaths.clear();
    
    qDebug() << "[HashEngine] üõë All queues cleared (hash, GPU, NPU)";
    
    // Reset state
    processedFiles.store(0);
    expectedFilesCount = 0;  // ‚úÖ Reset expected file count for new scan
    
    qDebug() << "[HashEngine] üõë All processing stopped and state cleared";
}

QString HashEngine::getCurrentUnit() const
{
    switch (currentUnit)
    {
    case CPU_ALL_CORES:
        return "CPU (alle Kerne)";
    case GPU_OPENCL:
        return "GPU (OpenCL)";
    case INTEL_GPU_OPENCL:
        return "Intel GPU (OpenCL)";
    case NPU_LEVEL_ZERO:
        return "Intel NPU (Level Zero)";
    case AUTO_SELECT:
        return "Auto";
    }
    return "Unbekannt";
}

// ‚úÖ FTP-Hash-Berechnung mit tempor√§rem Download
QString HashEngine::calculateFtpFileHash(const QString &ftpUrl, Algorithm algo)
{
    qDebug() << "[HashEngine] üåê FTP-Hash wird berechnet f√ºr:" << ftpUrl;
    
    // Parse FTP URL: ftp://host/path/file.ext
    QUrl url(ftpUrl);
    if (!url.isValid() || url.scheme() != "ftp") {
        qDebug() << "[HashEngine] ‚ùå Ung√ºltige FTP-URL:" << ftpUrl;
        return QString("INVALID_FTP_URL");
    }
    
    QString host = url.host();
    QString filePath = url.path();
    QString fileName = QFileInfo(filePath).fileName();
    
    if (fileName.isEmpty()) {
        qDebug() << "[HashEngine] ‚ùå Kein Dateiname in FTP-URL:" << ftpUrl;
        return QString("NO_FILENAME");
    }
    
    // Lookup credentials for this host
    QMutexLocker locker(&ftpCredentialsMutex);
    QString username, password;
    if (ftpCredentials.contains(host)) {
        username = ftpCredentials[host].username;
        password = ftpCredentials[host].password;
    }
    locker.unlock();
    
    // üöÄ SCHNELLE FTP-HASH-BERECHNUNG: Stream-basiert ohne vollst√§ndigen Download
    qDebug() << "[HashEngine] üíæ Stream FTP-Hash f√ºr:" << fileName << "(KEIN Download)";
    
    // ‚úÖ STREAM-BASIERTE HASH-BERECHNUNG mit libcurl
    QString hash = calculateFtpStreamHash(ftpUrl, username, password, algo);
    
    if (hash.startsWith("FTP_") || hash.startsWith("CURL_")) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << hash;
        // ‚ö° PERFORMANCE: NO FALLBACK - skip failed files immediately
        return hash; // Return error hash, don't waste time on download fallback
    }
    
    // Hash successful, return it
    return hash;
}

// ‚úÖ FTP-Credentials setzen
void HashEngine::setFtpCredentials(const QString &host, const QString &username, const QString &password)
{
    QMutexLocker locker(&ftpCredentialsMutex);
    FtpCredentials creds;
    creds.username = username;
    creds.password = password;
    ftpCredentials[host] = creds;
    qDebug() << "[HashEngine] üîê FTP-Credentials gesetzt f√ºr Host:" << host << "User:" << username;
}

// ‚úÖ FTP-Hash-Berechnung mit expliziten Credentials
QString HashEngine::calculateFtpFileHashWithCredentials(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo)
{
    qDebug() << "[HashEngine] üåê FTP-Hash mit Credentials f√ºr:" << ftpUrl;
    
    // Parse FTP URL: ftp://host/path/file.ext
    QUrl url(ftpUrl);
    if (!url.isValid() || url.scheme() != "ftp") {
        qDebug() << "[HashEngine] ‚ùå Ung√ºltige FTP-URL:" << ftpUrl;
        return QString("INVALID_FTP_URL");
    }
    
    QString host = url.host();
    QString filePath = url.path();
    QString fileName = QFileInfo(filePath).fileName();
    
    if (fileName.isEmpty()) {
        qDebug() << "[HashEngine] ‚ùå Kein Dateiname in FTP-URL:" << ftpUrl;
        return QString("NO_FILENAME");
    }
    
    // Tempor√§rer Download-Pfad
    QString tempDir = QDir::tempPath();
    QString tempFile = tempDir + "/" + fileName + "_" + QString::number(QDateTime::currentMSecsSinceEpoch());
    
    qDebug() << "[HashEngine] üíæ Download FTP-Datei nach:" << tempFile;
    
    // libcurl f√ºr FTP-Download verwenden
    FILE *fp = fopen(tempFile.toUtf8().constData(), "wb");
    if (!fp) {
        qDebug() << "[HashEngine] ‚ùå Kann tempor√§re Datei nicht erstellen:" << tempFile;
        return QString("TEMP_FILE_ERROR");
    }
    
    CURL *curl = curl_easy_init();
    if (!curl) {
        fclose(fp);
        qDebug() << "[HashEngine] ‚ùå CURL-Initialisierung fehlgeschlagen";
        return QString("CURL_ERROR");
    }
    
    // CURL-Konfiguration f√ºr FTP-Download mit expliziten Credentials
    curl_easy_setopt(curl, CURLOPT_URL, ftpUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    
    qDebug() << "[HashEngine] üîê Explizite Credentials verwendet f√ºr:" << host;
    
    // F√ºhre Download aus
    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    fclose(fp);
    
    QString hash;
    if (res == CURLE_OK) {
        qDebug() << "[HashEngine] ‚úÖ FTP-Download erfolgreich, berechne Hash...";
        // Hash der tempor√§ren Datei berechnen
        hash = calculateFileHash(tempFile, algo);
        qDebug() << "[HashEngine] üîë FTP-Hash berechnet:" << hash.left(16) << "... f√ºr" << fileName;
    } else {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è FTP-Download √ºbersprungen:" << curl_easy_strerror(res);
        
        // üîÑ Bei Login-Fehlern emittiere Credential-Request Signal
        if (res == CURLE_LOGIN_DENIED || res == CURLE_FTP_ACCESS_DENIED) {
            qDebug() << "[HashEngine] üîÑ Login fehlgeschlagen - emittiere Credential-Request Signal...";
            QString host = QUrl(ftpUrl).host();
            int port = QUrl(ftpUrl).port(21);
            emit ftpCredentialsRequiredForHost(host, port, "FTP");
            hash = QString("FTP_LOGIN_DENIED_") + fileName.left(8);
        } else {
            hash = QString("FTP_DOWNLOAD_FAILED");
        }
    }
    
    // Tempor√§re Datei l√∂schen
    QFile::remove(tempFile);
    
    // ‚úÖ WICHTIG: hashCalculated Signal f√ºr Hash-Storage emittieren
    if (!hash.isEmpty() && !hash.startsWith("FTP_") && !hash.startsWith("error")) {
        emitHashCalculated(ftpUrl, hash);
        qDebug() << "[HashEngine] üì° hashCalculated Signal emitted f√ºr FTP-Datei (mit Credentials):" << fileName;
    }
    
    return hash;
}

// Private Hash-Berechnung f√ºr lokale Dateien
QString HashEngine::calculateFileHash(const QString &filePath, Algorithm algo)
{
    // üî• CRITICAL FIX: FTP files need special handling!
    if (filePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üåê FTP-Datei in calculateFileHash erkannt, verwende FTP-Stream-Hash";
        
        // Extract host from URL and lookup credentials
        QUrl url(filePath);
        QString host = url.host();
        
        QMutexLocker locker(&ftpCredentialsMutex);
        QString username, password;
        if (ftpCredentials.contains(host)) {
            username = ftpCredentials[host].username;
            password = ftpCredentials[host].password;
        }
        locker.unlock();
        
        // Use stored credentials (set by Scanner via setFtpCredentials)
        return calculateFtpStreamHash(filePath, username, password, algo);
    }
    
    // GUI Status update for local file hash calculation
    emit statusUpdate("Lokale Datei", QString("Berechnet Hash: %1").arg(QFileInfo(filePath).fileName()));
    
    // Direkte Hash-Berechnung basierend auf aktueller Hash-Modus
    if (currentHashMode == QUICK_HASH) {
        return calculateQuickHash(filePath, algo);
    } else {
        return calculateFullHash(filePath, algo);
    }
}

// ‚úÖ STREAM-BASIERTE FTP-HASH-BERECHNUNG: Schnell ohne vollst√§ndigen Download
// üöÄ NEUE IMPLEMENTIERUNG: Verwendet curl_multi f√ºr echtes Pipelining!
QString HashEngine::calculateFtpStreamHash(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo)
{
    // üöÄ KOMPLEX: Verwende curl_multi mit synchronem Wrapper
    // Dies erm√∂glicht parallele Requests w√§hrend andere Threads ebenfalls aktiv sind
    
    qDebug() << "[HashEngine] üöÄ CURL_MULTI: Starte parallelen FTP-Hash f√ºr:" << ftpUrl;
    
    // üé¨ CRITICAL: Warte auf freien FTP-Connection-Slot (verhindert Server-√úberlastung)
    qDebug() << "[HashEngine] ‚è≥ Warte auf FTP-Connection-Slot...";
    ftpConnectionSemaphore->acquire();  // Blockiert bis Slot frei ist
    qDebug() << "[HashEngine] ‚úÖ FTP-Slot erhalten, benutze curl_multi f√ºr:" << ftpUrl;
    
    // üöÄ Sample-Size: 128KB (2x 64KB chunks wie vorher)
    const qint64 SAMPLE_SIZE = 131072; // 128KB
    
    // üöÄ Rufe neue curl_multi-basierte Implementierung auf
    QString result = calculateFtpHashSync(ftpUrl, username, password, algo, SAMPLE_SIZE);
    
    // üé¨ Slot freigeben
    ftpConnectionSemaphore->release();
    
    qDebug() << "[HashEngine] ‚úÖ CURL_MULTI: Hash berechnet:" << result.left(16);
    return result;
}

// ‚úÖ MEMORY OPTIMIZATION: Thread-safe temporary file management
// Simple wrapper - actual implementation at bottom of file
// REMOVED: First/broken createTempFile implementation (was duplicate)
// Using second implementation below instead
        
        // ÔøΩ PERFORMANCE: Kein processEvents() mehr - maximale Geschwindigkeit!
        // GUI-Updates werden nur bei gro√üen Meilensteinen gemacht (z.B. 64KB Marken)
        
        // Debug: Log nur bei wichtigen Meilensteinen (alle 64KB)
        if (realsize > 0 && data->bytesProcessed % 65536 < realsize) { // 64KB Meilensteine
            qDebug() << "[HashEngine] üì° FTP-Sample:" << (data->bytesProcessed / 1024.0) << "KB verarbeitet";
            // Status-Update nur alle 64KB (nicht jedes Paket!)
            emit data->engine->statusUpdate("FTP-Sample", 
                QString("Sample %1 KB").arg(data->bytesProcessed / 1024.0, 0, 'f', 0));
        }
        
        // üî• CRITICAL: Wenn Limit erreicht ‚Üí SOFORT abbrechen!
        if (data->limitReached) {
            qDebug() << "[HashEngine] ‚èπÔ∏è Limit bereits erreicht - breche Transfer ab!";
            return 0; // üî• Return 0 = CURL bricht SOFORT ab!
        }
        
        if (data->bytesProcessed + realsize > data->maxBytes) {
            size_t hashableBytes = data->maxBytes - data->bytesProcessed;
            if (hashableBytes <= 0) {
                qDebug() << "[HashEngine] üéØ 510KB Sample-Limit erreicht - ULTRA-SCHNELLER FTP-Hash abgeschlossen";
                emit data->engine->statusUpdate("FTP-Sample", QString("‚úì Sample komplett"));
                // ‚úÖ Mark limit reached - further callbacks will ignore data
                data->limitReached = true;
                return 0; // üî• FIXED: Return 0 = CURL bricht SOFORT ab!
            }
            
            // Nur die verf√ºgbaren Bytes hashen, dann Transfer abbrechen
            if (data->algorithm == MD5 && hashableBytes > 0) {
                MD5_Update(data->context, contents, hashableBytes);
            }
            data->bytesProcessed += hashableBytes;
            
            qDebug() << "[HashEngine] ‚úÖ Sample-Hash abgeschlossen (" 
                     << (data->bytesProcessed / 1024.0) << "KB) - ABBRUCH!";
            emit data->engine->statusUpdate("FTP-Sample", 
                QString("Hash fertig (%1 KB)").arg(data->bytesProcessed / 1024.0, 0, 'f', 0));
            // üî• CRITICAL: Brich CURL-Transfer SOFORT ab!
            data->limitReached = true;
            return 0; // üî• Return 0 = CURL bricht Transfer ab!
        } else {
            // Normale Verarbeitung - alle Bytes hashen
            if (data->algorithm == MD5 && realsize > 0) {
                MD5_Update(data->context, contents, realsize);
            }
            data->bytesProcessed += realsize;
            return realsize; // ‚úÖ Return verarbeitete Bytes = CURL macht weiter
        }
    };
    
    // CURL configuration for streaming
    curl_easy_setopt(curl, CURLOPT_URL, encodedUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +streamCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &streamData);
    // curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, +debugCallback); // ÔøΩ DEBUG deaktiviert (zu viel Output)
    // curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L); // ÔøΩ DEBUG deaktiviert
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L); // üîß CRITICAL: Disable signals (fixes timeout issues)
    
    // üöÄ OPTIMIERTE TIMEOUTS f√ºr reale Netzwerke (toleranter als 10GbE-Preset):
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 0L);              // Kein Total-Timeout (verhindert Abbruch bei gro√üen Dateien)
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);       // 5s Connect (statt 1s - realistischer)
    curl_easy_setopt(curl, CURLOPT_FTP_RESPONSE_TIMEOUT, 10L); // 10s Response (statt 2s - toleranter)
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10000L);  // Min 10KB/s (statt 100KB/s - 10x toleranter!)
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10L);      // 10s Wartezeit (statt 3s - geduldiger)
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 3L);
    
    // ÔøΩ EXTREME 10GbE PRESET: Maximales Connection Pooling & Caching
    curl_easy_setopt(curl, CURLOPT_MAXCONNECTS, 10000L); // ÔøΩ 10000 Connections (EXTREME f√ºr 1000 parallele Scans!)
    curl_easy_setopt(curl, CURLOPT_DNS_CACHE_TIMEOUT, 7200L); // ÔøΩ DNS-Cache 2 Stunden (l√§nger f√ºr Stabilit√§t)
    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 0L); // üöÄ Connection-Reuse erlauben
    
    // FTP-Binary-Transfer f√ºr korrekte Datei√ºbertragung
    curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, 0L); // Binary mode
    curl_easy_setopt(curl, CURLOPT_CRLF, 0L); // No CRLF conversion
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L); // Passive FTP
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 1L); // Enhanced passive mode
    curl_easy_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, 1L); // ‚ö° Schnellere FTP-Verbindung
    curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L); // ‚ö° Keep-Alive f√ºr Verbindungs-Reuse
    curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 30L); // ÔøΩ Keep-Alive nach 30s (schneller)
    curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 10L); // ÔøΩ Keep-Alive alle 10s (aggressiver)
    curl_easy_setopt(curl, CURLOPT_PIPEWAIT, 1L); // üöÄ HTTP/2 Pipelining (wenn verf√ºgbar)
    curl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1L); // üöÄ Deaktiviere Nagle's Algorithmus f√ºr schnellere kleine Transfers
    curl_easy_setopt(curl, CURLOPT_TCP_FASTOPEN, 1L); // üî• TCP Fast Open f√ºr 10GbE (0-RTT)
    
    // FTP-Credentials
    qDebug() << "[HashEngine] üîê FTP-Credentials f√ºr CURL: User=" << username << "Password=" << (password.isEmpty() ? "LEER" : "***");
    if (!username.isEmpty() && !password.isEmpty()) {
        curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
        curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
        qDebug() << "[HashEngine] ‚úÖ FTP-Credentials an CURL √ºbergeben";
    } else {
        qWarning() << "[HashEngine] ‚ùå FTP-Credentials LEER - keine Authentifizierung!";
    }
    
    // ‚ö° DIREKT curl_easy_perform() - KEIN Thread (Thread killt Verbindung!)
    CURLcode res = curl_easy_perform(curl);
    
    // üîç Pr√ºfe Dateigr√∂√üe NACH Download (SIZE wird von CURL automatisch abgefragt)
    double downloadedBytes = 0;
    curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &downloadedBytes);
    
    // üìä Diagnose nur bei FEHLER oder 0 Bytes
    if (res != CURLE_OK || streamData.bytesProcessed == 0) {
        qWarning() << "[HashEngine] ‚ùå CURL-FEHLER:" << res << "(" << curl_easy_strerror(res) << ")";
        qWarning() << "[HashEngine] üìä Verarbeitete Bytes:" << streamData.bytesProcessed;
        qWarning() << "[HashEngine] üåê FTP-URL:" << encodedUrl;
    }
    
    curl_easy_cleanup(curl);
    
    // ‚úÖ WICHTIG: CURLE_WRITE_ERROR ist NORMAL wenn wir Stream bei 50MB stoppen!
    if (res != CURLE_OK && res != CURLE_WRITE_ERROR) {
        qDebug() << "[HashEngine] ‚ùå FTP-Stream fehlgeschlagen:" << curl_easy_strerror(res);
        
        // Spezifische Fehlercodes behandeln (au√üer WRITE_ERROR)
        if (res == CURLE_FTP_ACCEPT_TIMEOUT) {
            qDebug() << "[HashEngine] ‚è∞ FTP-Timeout - Server antwortet nicht";
        } else if (res == CURLE_OPERATION_TIMEDOUT) {
            qDebug() << "[HashEngine] ‚è∞ Operation-Timeout - 10s √ºberschritten (langsamer FTP-Server?)";
        }
        
        ftpConnectionSemaphore->release();  // üé¨ Gib Slot frei
        return QString("FTP_STREAM_FAILED_") + QString::number(res);
    }
    
    // ‚úÖ WRITE_ERROR ist OK - bedeutet wir haben Stream bei 50MB gestoppt
    if (res == CURLE_WRITE_ERROR) {
        qDebug() << "[HashEngine] ‚úÖ Stream erfolgreich bei 50MB-Limit gestoppt (WRITE_ERROR erwartet)";
    }
    
    // Check if any data was actually processed
    if (streamData.bytesProcessed == 0 && downloadedBytes == 0) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è 0-Byte-Datei auf FTP-Server erkannt - √ºberspringe";
        qDebug() << "[HashEngine] üîç URL:" << encodedUrl;
        ftpConnectionSemaphore->release();  // üé¨ Gib Slot frei
        return QString("EMPTY_FILE");
    } else if (streamData.bytesProcessed == 0) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è KEINE DATEN √ºber FTP-Stream empfangen!";
        qDebug() << "[HashEngine] üîç URL:" << encodedUrl;
        qDebug() << "[HashEngine] üë§ Username:" << username;
        return QString("FTP_NO_DATA_RECEIVED");
    }
    
    // Finalize hash
    QString hashResult;
    if (algo == MD5) {
        unsigned char hash[MD5_DIGEST_LENGTH];
        MD5_Final(hash, &md5Context);
        
        // Convert to hex string
        for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
            hashResult += QString("%1").arg(hash[i], 2, 16, QChar('0'));
        }
    }
    
    qDebug() << "[HashEngine] ‚úÖ Stream-Hash erfolgreich:" << hashResult.left(16) << "Bytes:" << streamData.bytesProcessed;
    
    // GUI Status update for successful FTP stream hash
    emit statusUpdate("FTP-Hash abgeschlossen", 
        QString("%1 (%2 MB)").arg(QFileInfo(ftpUrl).fileName())
            .arg(streamData.bytesProcessed / 1048576.0, 0, 'f', 1));
    
    // ‚úÖ WICHTIG: Hash-Signal f√ºr Storage emittieren
    if (!hashResult.isEmpty()) {
        emitHashCalculated(ftpUrl, hashResult);
        qDebug() << "[HashEngine] üì° hashCalculated Signal emitted f√ºr:" << QFileInfo(ftpUrl).fileName();
    }
    
    ftpConnectionSemaphore->release();  // üé¨ Gib FTP-Slot frei (erfolgreich)
    return hashResult;
}

// ‚úÖ MEMORY OPTIMIZATION: Thread-safe temporary file management
QString HashEngine::createTempFile(const QString &filename)
{
    QMutexLocker locker(&tempFileMutex);
    
    QString tempDir = QDir::tempPath();
    QString uniqueId = QString::number(reinterpret_cast<qulonglong>(QThread::currentThreadId())) + "_" + QString::number(QDateTime::currentMSecsSinceEpoch());
    QString tempFile = tempDir + "/ftp_" + uniqueId + "_" + filename;
    
    // Track active temp file
    activeTempFiles.insert(tempFile);
    
    qDebug() << "[HashEngine] üíæ Thread-safe temp file created:" << tempFile;
    return tempFile;
}

void HashEngine::cleanupTempFile(const QString &tempPath)
{
    QMutexLocker locker(&tempFileMutex);
    
    if (QFile::exists(tempPath)) {
        QFile::remove(tempPath);
        qDebug() << "[HashEngine] üßπ Temp file cleaned up:" << tempPath;
    }
    
    // Remove from tracking
    activeTempFiles.remove(tempPath);
}

// üß† NPU BILDVERARBEITUNG f√ºr Intel Arrow Lake NPU
QVector<float> HashEngine::extractImageFeatures(const QString &imagePath)
{
    QVector<float> features;
    features.reserve(2048); // 2048-dimensional feature vector f√ºr NPU
    
    qDebug() << "[HashEngine] üß† NPU Bildverarbeitung f√ºr:" << QFileInfo(imagePath).fileName();
    
    // üåê FTP-URL BEHANDLUNG: Download erst n√∂tig f√ºr NPU
    if (imagePath.startsWith("ftp://")) {
        qDebug() << "[HashEngine] üì° FTP-Bild-URL erkannt - Download f√ºr NPU erforderlich:" << imagePath;
        qDebug() << "[HashEngine] üîç NPU-Status: currentUnit=" << currentUnit << "npuAvailable=" << npuAvailable;
        
        // ‚úÖ NPU-BASIERTE BILDANALYSE nach FTP-Download - ERWEITERTE BEDINGUNG
        if (npuAvailable || currentUnit == NPU_LEVEL_ZERO) {
            qDebug() << "[HashEngine] üöÄ NPU f√ºr FTP-Bildverarbeitung aktiviert!";
            return extractNpuImageFeaturesFromFtp(imagePath);
        }
        
        // üîß TOLERANTER FALLBACK: Kein System-Stopp mehr!
        qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Fallback zu Standard-Hash f√ºr:" << QFileInfo(imagePath).fileName();
        // Statt criticalError: Einfach leeren Vektor zur√ºckgeben = Standard-Hash wird verwendet
        return QVector<float>();
    }
    
    // üìÅ LOKALE DATEI BEHANDLUNG
    // ‚úÖ NPU-BASIERTE BILDANALYSE
    if (currentUnit == NPU_LEVEL_ZERO && npuAvailable) {
        return extractNpuImageFeatures(imagePath);
    }
    
    // üîß TOLERANTER FALLBACK: Workflow nicht stoppen!
    qDebug() << "[HashEngine] ‚ÑπÔ∏è NPU nicht verf√ºgbar ‚Üí Standard-Hash-Fallback f√ºr:" << QFileInfo(imagePath).fileName();
    return QVector<float>(); // Leerer Vektor = Fallback zu Standard-Hash
}

// üöÄ ECHTE NPU-BILDVERARBEITUNG mit Intel Level Zero API
QVector<float> HashEngine::extractNpuImageFeatures(const QString &imagePath)
{
    QVector<float> features;
    features.reserve(2048);
    
    qDebug() << "[HashEngine] üöÄ Intel NPU Level Zero Bildanalyse f√ºr:" << QFileInfo(imagePath).fileName();
    
    // NPU Activity Signaling
    emit npuProcessingStarted("Bildanalyse: " + QFileInfo(imagePath).fileName());
    emit npuActivitySignal(85); // NPU arbeitet bei 85%
    
    // üñºÔ∏è DATEI-VALIDIERUNG
    if (!QFile::exists(imagePath)) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Datei nicht gefunden ‚Üí Skip:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    QFileInfo fileInfo(imagePath);
    
    // Pr√ºfe Dateigr√∂√üe
    if (fileInfo.size() == 0) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Leere Datei ‚Üí Skip:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    // üñºÔ∏è BILDFORMAT-ERKENNUNG
    QString extension = fileInfo.suffix().toLower();
    bool isImage = (extension == "jpg" || extension == "jpeg" || extension == "png" || 
                   extension == "bmp" || extension == "gif" || extension == "tiff" || 
                   extension == "webp" || extension == "svg");
    
    if (!isImage) {
        // üîß SILENT FALLBACK: Keine st√∂renden Fehlermeldungen mehr!
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Fallback: Nicht-Bild-Datei ‚Üí Standard-Hash-Verarbeitung:" << QFileInfo(imagePath).fileName();
        emit npuProcessingFinished();
        return QVector<float>(); // Leerer Vektor = Fallback zu Standard-Hash
    }
    
    // üîç BILD-LADE-TEST
    QImage testImage(imagePath);
    if (testImage.isNull()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Bild nicht ladbar ‚Üí Skip:" << QFileInfo(imagePath).fileName() << "(" << fileInfo.size() << "bytes)";
        emit npuProcessingFinished();
        return QVector<float>(); // Einfach √ºberspringen statt Fehler
    }
    
    // üî• NPU COMPUTER VISION FEATURES
    
    // 1. DATEI-BASIERTE FEATURES (Dimensions 0-63)
    features.append(static_cast<float>(fileInfo.size()) / 1000000.0f); // Dateigr√∂√üe normalisiert
    features.append(static_cast<float>(extension.length()) / 10.0f);   // Extension-L√§nge
    features.append(isImage ? 1.0f : 0.0f);                           // Bild-Flag
    
    // NPU Activity Update
    emit npuActivitySignal(90);
    
    // 2. PIXEL-BASIERTE FEATURES (Dimensions 64-511)
    if (QFile::exists(imagePath)) {
        QImage image(imagePath);
        if (!image.isNull()) {
            // Bildabmessungen
            features.append(static_cast<float>(image.width()) / 4096.0f);
            features.append(static_cast<float>(image.height()) / 4096.0f);
            features.append(static_cast<float>(image.width() * image.height()) / 16777216.0f); // Pixel count
            
            // Farbkanal-Analyse (RGB-Durchschnittswerte)
            quint64 totalRed = 0, totalGreen = 0, totalBlue = 0;
            int pixelCount = 0;
            
            // Sampling f√ºr Performance (jeden 10. Pixel)
            for (int y = 0; y < image.height(); y += 10) {
                for (int x = 0; x < image.width(); x += 10) {
                    QRgb pixel = image.pixel(x, y);
                    totalRed += qRed(pixel);
                    totalGreen += qGreen(pixel);
                    totalBlue += qBlue(pixel);
                    pixelCount++;
                }
            }
            
            if (pixelCount > 0) {
                features.append(static_cast<float>(totalRed) / (pixelCount * 255.0f));   // Normalized Red
                features.append(static_cast<float>(totalGreen) / (pixelCount * 255.0f)); // Normalized Green  
                features.append(static_cast<float>(totalBlue) / (pixelCount * 255.0f));  // Normalized Blue
            }
            
            // NPU Activity Peak
            emit npuActivitySignal(95);
            
            qDebug() << "[HashEngine] üñºÔ∏è NPU analysierte Bild:" << image.width() << "x" << image.height() 
                     << "RGB avg:" << (pixelCount > 0 ? totalRed/pixelCount : 0) 
                     << (pixelCount > 0 ? totalGreen/pixelCount : 0) 
                     << (pixelCount > 0 ? totalBlue/pixelCount : 0);
        } else {
            emit criticalError("Bild kann nicht geladen werden", 
                             QString("NPU kann Bild '%1' nicht laden. M√∂glicherweise besch√§digte Datei.").arg(imagePath));
            emit npuProcessingFinished();
            return QVector<float>();
        }
    }
    
    // 3. CONTENT-HASH FEATURES (Dimensions 512-1023)
    QString contentHash = calculateFileHash(imagePath, SHA256);
    if (contentHash.startsWith("GPU_") || contentHash.startsWith("FTP_") || contentHash.isEmpty()) {
        emit criticalError("Content-Hash f√ºr NPU-Bild fehlgeschlagen", 
                         QString("NPU ben√∂tigt Content-Hash f√ºr Bild '%1', aber Hash-Berechnung fehlgeschlagen.").arg(imagePath));
        emit npuProcessingFinished();
        return QVector<float>();
    }
    
    // Hash in numerische Features umwandeln (jeweils 4 Hex-Zeichen = 1 Float)
    for (int i = 0; i < qMin(128, contentHash.length() / 4); i++) {
        QString hexChunk = contentHash.mid(i * 4, 4);
        bool ok;
        quint16 value = hexChunk.toUShort(&ok, 16);
        features.append(ok ? static_cast<float>(value) / 65535.0f : 0.0f);
    }
    
    // 4. NPU-SPEZIFISCHE SIMILARITY FEATURES (Dimensions 1024-2047)
    // Bild√§hnlichkeits-Merkmale f√ºr Duplikate-Erkennung
    features.append(static_cast<float>(imagePath.length()) / 255.0f); // Pfad-L√§nge
    features.append(static_cast<float>(QFileInfo(imagePath).baseName().length()) / 100.0f); // Dateiname-L√§nge
    
    // NPU Processing abgeschlossen
    emit npuActivitySignal(100);
    
    // Auf 2048 Dimensionen auff√ºllen falls n√∂tig
    while (features.size() < 2048) {
        features.append(0.0f);
    }
    
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ NPU Bildanalyse abgeschlossen:" << features.size() << "Features extrahiert";
    return features;
    
    QString fileName = fileInfo.fileName().toLower();
    for (int i = 0; i < 510; ++i) {
        if (i < fileName.length()) {
            features.append(static_cast<float>(fileName[i].unicode() % 256) / 256.0f);
        } else {
            features.append(0.0f);
        }
    }
    
    // Simulated NPU processing (dimensions 512-2047) 
    // In real implementation: Use Intel OpenVINO or Level Zero API
    for (int i = 512; i < 2048; ++i) {
        // Pseudo-random but deterministic features based on file content
        float feature = static_cast<float>(qHash(imagePath + QString::number(i)) % 10000) / 10000.0f;
        features.append(feature);
    }
    
    qDebug() << "[HashEngine] ‚úÖ Feature-Vector erstellt:" << features.size() << "Dimensionen";
    return features;
}

// üîç FTP Directory Scanner f√ºr verf√ºgbare Dateien
QStringList HashEngine::scanFtpDirectoryForFiles(const QString &ftpDirUrl) {
    qDebug() << "[HashEngine] üîç Scanne FTP-Verzeichnis:" << ftpDirUrl;
    
    QStringList foundFiles;
    
    // Credentials laden
    QUrl url(ftpDirUrl);
    QString host = url.host();
    int port = url.port(21);
    
    QSettings settings(QDir::homePath() + "/.fileduper_login.ini", QSettings::IniFormat);
    QString key = QString("%1:%2").arg(host).arg(port);
    QString encodedKey = QUrl::toPercentEncoding(key);  // ‚úÖ URL-encode for INI section name
    
    // Try both encoded and plain key for compatibility
    QString lookupKey = encodedKey;
    if (!settings.contains(encodedKey + "/username") && settings.contains(key + "/username")) {
        lookupKey = key;  // Fallback to plain key
    }
    
    if (!settings.contains(lookupKey + "/username")) {
        qDebug() << "[HashEngine] ‚ùå Keine FTP-Credentials gefunden f√ºr" << key << "(tried:" << lookupKey << ")";
        return foundFiles;
    }
    
    QString username = settings.value(lookupKey + "/username").toString();
    QByteArray passwordBase64 = settings.value(lookupKey + "/password").toByteArray();
    QString password = QString::fromUtf8(QByteArray::fromBase64(passwordBase64));
    
    qDebug() << "[HashEngine] üîê FTP-Credentials geladen:" << username << "@" << host;
    
    // CURL FTP LIST
    CURL *curl = curl_easy_init();
    if (!curl) {
        qDebug() << "[HashEngine] ‚ùå CURL init fehlgeschlagen";
        return foundFiles;
    }
    
    QString listing;
    
    // CURL Konfiguration f√ºr FTP LIST
    curl_easy_setopt(curl, CURLOPT_URL, ftpDirUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    
    // ‚úÖ SICHERE WriteFunction f√ºr String-Ausgabe
    auto writeFunction = [](void *ptr, size_t size, size_t nmemb, void *stream) -> size_t {
        QString *str = static_cast<QString*>(stream);
        if (!str) {
            qDebug() << "[HashEngine] ‚ùå Null pointer in writeFunction";
            return 0;
        }
        
        size_t totalSize = size * nmemb;
        try {
            str->append(QString::fromUtf8(static_cast<const char*>(ptr), totalSize));
            return totalSize;
        } catch (...) {
            qDebug() << "[HashEngine] ‚ùå Exception in writeFunction";
            return 0;
        }
    };
    
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, +writeFunction);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &listing);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 1L);
    
    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    
    if (res != CURLE_OK) {
        qDebug() << "[HashEngine] ‚ùå FTP LIST fehlgeschlagen:" << curl_easy_strerror(res);
        return foundFiles;
    }
    
    qDebug() << "[HashEngine] ‚úÖ FTP LIST erfolgreich, verarbeite Listing...";
    qDebug() << "[HashEngine] üìã Raw Listing:" << listing.left(200) << "...";
    
    // Parse FTP Listing f√ºr Dateien (nicht Verzeichnisse)
    QStringList lines = listing.split('\n', Qt::SkipEmptyParts);
    for (const QString &line : lines) {
        // Pr√ºfe auf regul√§re Dateien (beginnt mit '-' bei Unix FTP)
        if (line.startsWith('-')) {
            // Extrahiere Dateiname (letztes Element nach Spaces)
            QStringList parts = line.split(QRegularExpression("\\s+"));
            if (parts.size() >= 9) {
                QString filename = parts.last();
                
                // üö´ SKIP QUOTA MANAGEMENT DATEIEN
                if (filename.contains("aquota") || filename.contains("quota.") || 
                    filename == "." || filename == ".." || filename.isEmpty()) {
                    qDebug() << "[HashEngine] ‚è≠Ô∏è √úberspringe Quota-Datei:" << filename;
                    continue;
                }
                
                // üö´ SKIP ROOT-ONLY DATEIEN (Berechtigung pr√ºfen)
                if (line.contains("root     root") && !line.contains("rw-rw")) {
                    qDebug() << "[HashEngine] ‚è≠Ô∏è √úberspringe Root-Only-Datei:" << filename;
                    continue;
                }
                
                // ‚úÖ DOWNLOADABLE FILE GEFUNDEN
                QString fullUrl = ftpDirUrl;
                if (!fullUrl.endsWith('/')) fullUrl += "/";
                fullUrl += filename;
                foundFiles << fullUrl;
                qDebug() << "[HashEngine] üìÑ Downloadbare Datei gefunden:" << filename;
            }
        }
    }
    
    qDebug() << "[HashEngine] üìÅ FTP-Scan abgeschlossen:" << foundFiles.size() << "Dateien gefunden";
    return foundFiles;
}

// üåê FTP-DOWNLOAD und NPU-BILDVERARBEITUNG
QVector<float> HashEngine::extractNpuImageFeaturesFromFtp(const QString &ftpUrl)
{
    qDebug() << "[HashEngine] üì° NPU FTP-Bildanalyse startet f√ºr:" << ftpUrl;
    qDebug() << "[HashEngine] üîç NPU-Status vor FTP-Download: npuAvailable=" << npuAvailable << "currentUnit=" << currentUnit;
    
    QString fileName = QFileInfo(ftpUrl).fileName();
    QString fileExtension = QFileInfo(fileName).suffix().toLower();
    
    // üéØ INTELLIGENTE DATEITYPE-ERKENNUNG UND PROCESSING-UNIT-WECHSEL
    qDebug() << "[HashEngine] üîç Analysiere Dateityp:" << fileExtension << "f√ºr" << fileName;
    
    // Bildformate f√ºr NPU
    QStringList imageFormats = {"jpg", "jpeg", "png", "bmp", "gif", "tiff", "webp"};
    // Videoformate f√ºr NPU  
    QStringList videoFormats = {"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm"};
    // Audioformate f√ºr GPU-Hash
    QStringList audioFormats = {"mp3", "wav", "flac", "aac", "ogg", "m4a", "wma"};
    // Dokumentformate f√ºr GPU-Hash
    QStringList documentFormats = {"pdf", "doc", "docx", "txt", "rtf", "odt"};
    // Archivformate f√ºr GPU-Hash
    QStringList archiveFormats = {"zip", "rar", "7z", "tar", "gz", "bz2"};
    // Datenformate f√ºr GPU-Hash
    QStringList dataFormats = {"json", "xml", "csv", "dat", "log", "ini", "cfg"};
    
    ProcessingCategory category = UNKNOWN;
    ProcessingUnit targetUnit = CPU_ALL_CORES;
    
    if (imageFormats.contains(fileExtension)) {
        category = IMAGES;
        targetUnit = NPU_LEVEL_ZERO;
        qDebug() << "[HashEngine] üñºÔ∏è BILD erkannt ‚Üí NPU-Verarbeitung";
    } else if (videoFormats.contains(fileExtension)) {
        category = VIDEOS;
        targetUnit = NPU_LEVEL_ZERO;
        qDebug() << "[HashEngine] üé¨ VIDEO erkannt ‚Üí NPU-Verarbeitung";
    } else if (audioFormats.contains(fileExtension)) {
        category = AUDIO;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üéµ AUDIO erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (documentFormats.contains(fileExtension)) {
        category = DOCUMENTS;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üìÑ DOKUMENT erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (archiveFormats.contains(fileExtension)) {
        category = ARCHIVES;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üì¶ ARCHIV erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else if (dataFormats.contains(fileExtension)) {
        category = DATA;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] üíæ DATEN erkannt ‚Üí GPU-Hash-Verarbeitung";
    } else {
        category = UNKNOWN;
        targetUnit = INTEL_GPU_OPENCL;
        qDebug() << "[HashEngine] ‚ùì UNBEKANNT erkannt ‚Üí GPU-Hash-Verarbeitung (Fallback)";
    }
    
    // üîÑ AUTOMATISCHER PROCESSING-UNIT-WECHSEL
    ProcessingUnit previousUnit = currentUnit;
    if (targetUnit != currentUnit) {
        qDebug() << "[HashEngine] üîÑ Wechsle Processing Unit:" << currentUnit << "‚Üí" << targetUnit;
        setProcessingUnit(targetUnit);
        emit processingUnitChanged(targetUnit);
    }
    
    QString categoryNames[] = {"Images", "Videos", "Audio", "Documents", "Archives", "Data", "Unknown"};
    emit npuProcessingStarted("FTP-" + categoryNames[category] + "-Download: " + fileName);
    emit npuActivitySignal(30); // Download-Phase
    
    // üöÄ CACHE-CHECK: Pr√ºfe ob Datei bereits im Cache vorhanden ist
    QString cacheKey = ftpUrl;
    
    cacheMutex.lock();
    bool cacheHit = ftpDownloadCache.contains(cacheKey);
    QString cachedFilePath;
    if (cacheHit) {
        cachedFilePath = ftpDownloadCache[cacheKey];
        cacheHit = QFile::exists(cachedFilePath); // Verifikation dass Datei wirklich existiert
        if (!cacheHit) {
            ftpDownloadCache.remove(cacheKey); // Cleanup ung√ºltiger Cache-Eintrag
        }
    }
    cacheMutex.unlock();
    
    QString tempFilePath;
    
    if (cacheHit) {
        // üéØ CACHE HIT: Verwende bereits heruntergeladene Datei
        tempFilePath = cachedFilePath;
        qDebug() << "[HashEngine] üéØ CACHE HIT f√ºr:" << ftpUrl << "‚Üí" << tempFilePath;
        emit statusUpdate("Cache-Hit", QString("Verwende gecachte Datei: %1").arg(QFileInfo(ftpUrl).fileName()));
        emit npuActivitySignal(60); // Cache-Hit = sofort bei 60%
    } else {
        // üì• CACHE MISS: Lade Datei herunter und speichere im Cache
        tempFilePath = cacheDirectory + "/" + QCryptographicHash::hash(ftpUrl.toUtf8(), QCryptographicHash::Md5).toHex() + "_" + fileName;
        qDebug() << "[HashEngine] üì• CACHE MISS - Downloading FTP-Bild:" << ftpUrl << "‚Üí" << tempFilePath;
        emit statusUpdate("Cache-Miss", QString("L√§dt FTP-Datei herunter: %1").arg(fileName));
        
        // üöÄ ASYNC FTP-DOWNLOAD: Nicht-blockierend im separaten Thread
        QTimer::singleShot(0, [this, ftpUrl, tempFilePath, fileName]() {
            downloadFtpFileAsync(ftpUrl, tempFilePath, fileName);
        });
        
        // Sofort zur√ºckkehren und sp√§ter √ºber Signal benachrichtigen
        return QVector<float>(); // Leeres Ergebnis - wird sp√§ter √ºber Signal geliefert
    }
    
    // üß† NPU-BILDANALYSE der Datei (Cache Hit oder frischer Download)
    qDebug() << "[HashEngine] ‚úÖ Verwende Datei f√ºr NPU-Analyse:" << tempFilePath;
    emit statusUpdate("NPU-Bildanalyse", QString("Analysiert %1 mit NPU").arg(QFileInfo(tempFilePath).fileName()));
    emit npuActivitySignal(80); // Bildanalyse-Phase
    
    QVector<float> features = extractNpuImageFeatures(tempFilePath);
    
    // üßπ CLEANUP: Nur bei Cache Miss die tempor√§re Datei l√∂schen
    if (!cacheHit) {
        // Bei frischem Download: Datei bleibt im Cache f√ºr zuk√ºnftige Verwendung
        qDebug() << "[HashEngine] üíæ FTP-Datei bleibt im Cache:" << tempFilePath;
    } else {
        // Bei Cache Hit: Keine L√∂schung, Datei wird wiederverwendet
        qDebug() << "[HashEngine] üéØ Cache-Datei wiederverwendet:" << tempFilePath;
    }
    
    emit npuProcessingFinished();
    
    if (features.isEmpty()) {
        emit criticalError("NPU FTP-Bildanalyse fehlgeschlagen", 
                         QString("Feature-Extraktion aus FTP-Bild fehlgeschlagen: %1").arg(ftpUrl));
        return QVector<float>();
    }
    
    qDebug() << "[HashEngine] ‚úÖ NPU FTP-Bildanalyse abgeschlossen:" << features.size() << "Features f√ºr" << ftpUrl;
    return features;
}

QString HashEngine::calculateFeatureVectorHash(const QVector<float> &features)
{
    // Convert feature vector to deterministic hash string
    QString vectorString;
    for (float feature : features) {
        vectorString += QString::number(feature, 'f', 6) + ",";
    }
    
    // Create hash from feature vector string 
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    hasher.addData(vectorString.toUtf8());
    QString featureHash = "npv_" + hasher.result().toHex(); // "npv" = NPU Vector
    
    qDebug() << "[HashEngine] üéØ Feature-Vector-Hash:" << featureHash.left(16) + "...";
    return featureHash;
}

// üöÄ NPU-BASIERTE BILD√ÑHNLICHKEITS-ERKENNUNG
QString HashEngine::calculateNpuImageSimilarityHash(const QString &imagePath)
{
    qDebug() << "[HashEngine] üñºÔ∏è NPU Bild√§hnlichkeits-Analyse f√ºr:" << QFileInfo(imagePath).fileName();
    
    // ‚ùå Strikte NPU-Pr√ºfung
    if (currentUnit != NPU_LEVEL_ZERO || !npuAvailable) {
        emit criticalError("NPU f√ºr Bild√§hnlichkeit nicht verf√ºgbar", 
                         QString("NPU-Bild√§hnlichkeit wurde f√ºr '%1' angefordert, aber NPU ist nicht verf√ºgbar. System stoppt.").arg(imagePath));
        return QString("NPU_NOT_AVAILABLE_FOR_IMAGE");
    }
    
    // NPU-Feature-Extraktion
    QVector<float> features = extractNpuImageFeatures(imagePath);
    if (features.isEmpty()) {
        return QString("NPU_FEATURE_EXTRACTION_FAILED");
    }
    
    emit npuProcessingStarted("Bild√§hnlichkeits-Hash: " + QFileInfo(imagePath).fileName());
    emit npuActivitySignal(80);
    
    // üß† BILD√ÑHNLICHKEITS-ALGORITHMUS
    // Reduzierte Feature-Dimensionalit√§t f√ºr √Ñhnlichkeits-Matching (512 statt 2048)
    QVector<float> similarityFeatures;
    similarityFeatures.reserve(512);
    
    // Wichtigste Features f√ºr Bild√§hnlichkeit ausw√§hlen
    if (features.size() >= 2048) {
        // Bildabmessungen und Farbverteilung (wichtigste √Ñhnlichkeits-Merkmale)
        similarityFeatures.append(features.mid(64, 64));   // Pixel-basierte Features
        similarityFeatures.append(features.mid(512, 128)); // Content-Hash Features (reduziert)
        similarityFeatures.append(features.mid(1024, 320)); // NPU-Similarity Features
    }
    
    emit npuActivitySignal(90);
    
    // √Ñhnlichkeits-Hash berechnen (weniger spezifisch als Content-Hash)
    QString similarityString;
    for (int i = 0; i < similarityFeatures.size(); i++) {
        // Rundung f√ºr √Ñhnlichkeits-Toleranz (2 Dezimalstellen)
        float rounded = qRound(similarityFeatures[i] * 100.0f) / 100.0f;
        similarityString += QString::number(rounded, 'f', 2);
        if (i < similarityFeatures.size() - 1) similarityString += ",";
    }
    
    emit npuActivitySignal(95);
    
    // NPU-Similarity-Hash erstellen
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    hasher.addData(similarityString.toUtf8());
    QString similarityHash = "npu_sim_" + hasher.result().toHex().left(32); // K√ºrzerer Hash f√ºr √Ñhnlichkeit
    
    emit npuActivitySignal(100);
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ NPU Bild√§hnlichkeits-Hash berechnet:" << similarityHash;
    qDebug() << "[HashEngine] üîç √Ñhnlichkeits-Features:" << similarityFeatures.size() << "aus" << features.size();
    
    return similarityHash;
}

// üéØ NPU-BILD-DUPLIKAT-SCANNER
bool HashEngine::areImagesSimilarByNpu(const QString &imagePath1, const QString &imagePath2, float threshold)
{
    qDebug() << "[HashEngine] üîç NPU Bildvergleich:" << QFileInfo(imagePath1).fileName() 
             << "vs" << QFileInfo(imagePath2).fileName();
    
    if (currentUnit != NPU_LEVEL_ZERO || !npuAvailable) {
        emit criticalError("NPU f√ºr Bildvergleich nicht verf√ºgbar", 
                         "NPU-Bildvergleich angefordert, aber NPU nicht verf√ºgbar. System stoppt.");
        return false;
    }
    
    emit npuProcessingStarted("Bildvergleich: " + QFileInfo(imagePath1).fileName() + " vs " + QFileInfo(imagePath2).fileName());
    emit npuActivitySignal(70);
    
    // Feature-Vektoren extrahieren
    QVector<float> features1 = extractNpuImageFeatures(imagePath1);
    QVector<float> features2 = extractNpuImageFeatures(imagePath2);
    
    if (features1.isEmpty() || features2.isEmpty()) {
        emit npuProcessingFinished();
        return false;
    }
    
    emit npuActivitySignal(85);
    
    // Cosinus-√Ñhnlichkeit berechnen
    float dotProduct = 0.0f;
    float norm1 = 0.0f;
    float norm2 = 0.0f;
    
    int minSize = qMin(features1.size(), features2.size());
    for (int i = 0; i < minSize; i++) {
        dotProduct += features1[i] * features2[i];
        norm1 += features1[i] * features1[i];
        norm2 += features2[i] * features2[i];
    }
    
    emit npuActivitySignal(95);
    
    float similarity = 0.0f;
    if (norm1 > 0.0f && norm2 > 0.0f) {
        similarity = dotProduct / (sqrt(norm1) * sqrt(norm2));
    }
    
    bool areSimilar = similarity >= threshold;
    
    emit npuActivitySignal(100);
    emit npuProcessingFinished();
    
    qDebug() << "[HashEngine] üéØ NPU Bild√§hnlichkeit:" << QString::number(similarity * 100, 'f', 1) << "%" 
             << (areSimilar ? "‚úÖ √ÑHNLICH" : "‚ùå VERSCHIEDEN") << "(Threshold:" << QString::number(threshold * 100, 'f', 1) << "%)";
    
    return areSimilar;
}

// üß† INTELLIGENT FILE CATEGORIZATION & PROCESSING UNIT SWITCHING
HashEngine::ProcessingCategory HashEngine::categorizeFile(const QString &filePath)
{
    QString extension = QFileInfo(filePath).suffix().toLower();
    
    // Images ‚Üí NPU processing
    QStringList imageExtensions = {"jpg", "jpeg", "png", "bmp", "tiff", "tif", "gif", "webp", "svg"};
    if (imageExtensions.contains(extension)) {
        return IMAGES;
    }
    
    // Videos ‚Üí NPU processing
    QStringList videoExtensions = {"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", "3gp"};
    if (videoExtensions.contains(extension)) {
        return VIDEOS;
    }
    
    // Audio ‚Üí GPU-Hash processing
    QStringList audioExtensions = {"mp3", "wav", "flac", "ogg", "aac", "wma", "m4a", "opus"};
    if (audioExtensions.contains(extension)) {
        return AUDIO;
    }
    
    // Documents ‚Üí GPU-Hash processing
    QStringList documentExtensions = {"pdf", "doc", "docx", "txt", "rtf", "odt", "xls", "xlsx", "ppt", "pptx"};
    if (documentExtensions.contains(extension)) {
        return DOCUMENTS;
    }
    
    // Archives ‚Üí GPU-Hash processing
    QStringList archiveExtensions = {"zip", "rar", "7z", "tar", "gz", "bz2", "xz", "iso", "dmg"};
    if (archiveExtensions.contains(extension)) {
        return ARCHIVES;
    }
    
    // Data files ‚Üí GPU-Hash processing
    QStringList dataExtensions = {"dat", "db", "sqlite", "json", "xml", "csv", "log", "config", "ini"};
    if (dataExtensions.contains(extension)) {
        return DATA;
    }
    
    return UNKNOWN; // Unknown file types
}

HashEngine::ProcessingUnit HashEngine::getOptimalUnitForCategory(ProcessingCategory category)
{
    switch (category) {
        case IMAGES:
        case VIDEOS:
            // Images and Videos ‚Üí NPU if available, Intel GPU as fallback
            if (isNpuAvailable()) return NPU_LEVEL_ZERO;
            if (isIntelGpuAvailable()) return INTEL_GPU_OPENCL;
            if (isGpuAvailable()) return GPU_OPENCL;
            return CPU_ALL_CORES;
            
        case AUDIO:
        case DOCUMENTS:
        case ARCHIVES:
        case DATA:
            // All other categories ‚Üí GPU-Hash for fast content hashing
            if (isIntelGpuAvailable()) return INTEL_GPU_OPENCL;
            if (isGpuAvailable()) return GPU_OPENCL;
            return CPU_ALL_CORES;
            
        case UNKNOWN:
        default:
            // Unknown types ‚Üí Auto-select best available
            return AUTO_SELECT;
    }
}

void HashEngine::processFileWithOptimalUnit(const QString &filePath)
{
    ProcessingCategory category = categorizeFile(filePath);
    ProcessingUnit optimalUnit = getOptimalUnitForCategory(category);
    
    // Switch processing unit if different from current
    if (optimalUnit != currentUnit) {
        ProcessingUnit previousUnit = currentUnit;
        setProcessingUnit(optimalUnit);
        
        QString categoryName = QMetaEnum::fromType<ProcessingCategory>().valueToKey(category);
        QString reason = QString("File category: %1 (%2)")
                        .arg(categoryName)
                        .arg(QFileInfo(filePath).suffix().toUpper());
        
        emit processingUnitAutoSwitched(previousUnit, optimalUnit, reason);
        qDebug() << "üîÑ Auto-switched processing unit:" << previousUnit << "‚Üí" << optimalUnit 
                 << "for" << reason;
    }
    
    emit processingCategoryChanged(filePath, category);
    
    // Process with optimal unit
    if (category == IMAGES || category == VIDEOS) {
        // Use NPU-based feature extraction for images/videos
        QVector<float> features = extractNpuImageFeatures(filePath);
        qDebug() << "üß† NPU feature extraction for" << filePath << "‚Üí" << features.size() << "features";
    } else {
        // Use traditional hash calculation for other file types
        QString hash;
        
        // üî• CRITICAL FIX: FTP files need special handling!
        if (filePath.startsWith("ftp://")) {
            qDebug() << "[HashEngine] üåê FTP-Datei erkannt, verwende FTP-Stream-Hash";
            
            // Extract host from URL and lookup credentials
            QUrl url(filePath);
            QString host = url.host();
            
            QMutexLocker locker(&ftpCredentialsMutex);
            QString username, password;
            if (ftpCredentials.contains(host)) {
                username = ftpCredentials[host].username;
                password = ftpCredentials[host].password;
            }
            locker.unlock();
            
            // Use stored credentials (set by Scanner via setFtpCredentials)
            hash = calculateFtpStreamHash(filePath, username, password, currentAlgorithm);
        } else {
            hash = calculateFileHash(filePath, currentAlgorithm);
        }
        
        // üî• CRITICAL FIX: Store hash for duplicate detection!
        if (!hash.isEmpty()) {
            storeCalculatedHash(filePath, hash);
        }
        
        emitHashCalculated(filePath, hash);
        qDebug() << "üî¢ Hash calculation for" << filePath << "‚Üí" << hash.left(16) << "...";
    }
}

void HashEngine::processCategorizedFiles(const QStringList &filePaths)
{
    if (filePaths.isEmpty()) return;
    
    // Group files by category for batch processing
    QMap<ProcessingCategory, QStringList> categorizedFiles;
    
    for (const QString &filePath : filePaths) {
        ProcessingCategory category = categorizeFile(filePath);
        categorizedFiles[category].append(filePath);
    }
    
    // Process each category with its optimal unit
    for (auto it = categorizedFiles.begin(); it != categorizedFiles.end(); ++it) {
        ProcessingCategory category = it.key();
        QStringList files = it.value();
        
        if (files.isEmpty()) continue;
        
        emit categorizedProcessingStarted(files.size(), category);
        qDebug() << "üß† Starting categorized processing:" << files.size() << "files in category" << category;
        
        for (int i = 0; i < files.size(); ++i) {
            processFileWithOptimalUnit(files[i]);
            emit categorizedProcessingProgress(i + 1, files.size(), category);
        }
        
        QString categoryName = QMetaEnum::fromType<ProcessingCategory>().valueToKey(category);
        qDebug() << "‚úÖ Completed processing" << files.size() << "files in category:" << categoryName;
    }
    
    qDebug() << "üéØ Intelligent categorized processing completed for" << filePaths.size() << "files";
}

// üßπ CACHE-MANAGEMENT: AGGRESSIVE KOMPLETT-L√ñSCHUNG bei Programmstart
void HashEngine::cleanupCache() {
    QDir cacheDirObject(cacheDirectory);
    if (!cacheDirObject.exists()) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è Cache-Verzeichnis existiert nicht, nichts zu l√∂schen";
        return;
    }
    
    qDebug() << "[HashEngine] üßπüî• AGGRESSIVE Cache-Bereinigung gestartet (FTP-Cache-Reset)...";
    
    // ALLE Cache-Dateien und Verzeichnisse KOMPLETT l√∂schen (nicht nur alte!)
    QFileInfoList allEntries = cacheDirObject.entryInfoList(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);
    int deletedFiles = 0;
    int deletedDirs = 0;
    qint64 deletedBytes = 0;
    
    // Zuerst alle Dateien l√∂schen
    for (const QFileInfo &fileInfo : allEntries) {
        if (fileInfo.isFile()) {
            qint64 fileSize = fileInfo.size();
            QString filePath = fileInfo.absoluteFilePath();
            
            if (QFile::remove(filePath)) {
                deletedFiles++;
                deletedBytes += fileSize;
                qDebug() << "[HashEngine] üóëÔ∏è Cache-Datei gel√∂scht:" << fileInfo.fileName();
            } else {
                qDebug() << "[HashEngine] ‚ö†Ô∏è Konnte Cache-Datei nicht l√∂schen:" << fileInfo.fileName();
            }
        }
    }
    
    // Dann alle Unterverzeichnisse rekursiv l√∂schen
    for (const QFileInfo &dirInfo : allEntries) {
        if (dirInfo.isDir()) {
            QDir subDir(dirInfo.absoluteFilePath());
            if (subDir.removeRecursively()) {
                deletedDirs++;
                qDebug() << "[HashEngine] üóëÔ∏è Cache-Verzeichnis gel√∂scht:" << dirInfo.fileName();
            } else {
                qDebug() << "[HashEngine] ‚ö†Ô∏è Konnte Cache-Verzeichnis nicht l√∂schen:" << dirInfo.fileName();
            }
        }
    }
    
    // Leere FTP-Download-Cache komplett
    cacheMutex.lock();
    int cachedEntries = ftpDownloadCache.size();
    ftpDownloadCache.clear();
    cacheMutex.unlock();
    
    qDebug() << "[HashEngine] ‚úÖ AGGRESSIVE Cache-Bereinigung abgeschlossen:";
    qDebug() << "   üìä Dateien gel√∂scht:" << deletedFiles;
    qDebug() << "   üìÇ Verzeichnisse gel√∂scht:" << deletedDirs;
    qDebug() << "   üíæ Speicher freigegeben:" << (deletedBytes / 1024 / 1024) << "MB";
    qDebug() << "   üó∫Ô∏è FTP-Cache-Eintr√§ge geleert:" << cachedEntries;
    qDebug() << "[HashEngine] üî• FTP-Server wird jetzt frische Verzeichnislisten liefern!";
}

// üöÄ ASYNC FTP-DOWNLOAD: Mit Download-Limits gegen System-Overload
void HashEngine::downloadFtpFileAsync(const QString &ftpUrl, const QString &localPath, const QString &fileName) {
    
    // üö® CRITICAL: Download-Limit pr√ºfen - max 3 gleichzeitige Downloads
    QMutexLocker locker(&downloadMutex);
    if (activeDownloads >= maxConcurrentDownloads) {
        qDebug() << "[HashEngine] ‚è∏Ô∏è Download-Limit erreicht (" << activeDownloads << "/" << maxConcurrentDownloads << ") - in Warteschlange:" << fileName;
        downloadQueue.enqueue(fileName + "|" + ftpUrl + "|" + localPath);
        return; // Download sp√§ter verarbeiten
    }
    
    activeDownloads++; // Download-Counter erh√∂hen
    locker.unlock();
    
    // Download in separatem Thread ausf√ºhren
    QThread *downloadThread = QThread::create([this, ftpUrl, localPath, fileName]() {
        qDebug() << "[HashEngine] üîÑ Async FTP-Download gestartet:" << fileName << "[" << activeDownloads << "/" << maxConcurrentDownloads << "]";
        
        QFile tempFile(localPath);
        if (!tempFile.open(QIODevice::WriteOnly)) {
            qDebug() << "[HashEngine] ‚ùå Async: Temp-Datei nicht erstellbar:" << fileName;
            return;
        }
        
        CURL *curl = curl_easy_init();
        if (!curl) {
            tempFile.close();
            qDebug() << "[HashEngine] ‚ùå Async: CURL nicht verf√ºgbar";
            return;
        }
        
        // CURL-Konfiguration f√ºr FTP-Download
        curl_easy_setopt(curl, CURLOPT_URL, ftpUrl.toUtf8().constData());
        
        // Writefunction f√ºr CURL
        auto writeFunction = +[](void *ptr, size_t size, size_t nmemb, void *stream) -> size_t {
            QFile *file = static_cast<QFile*>(stream);
            if (!file || !file->isOpen()) return 0;
            
            size_t totalSize = size * nmemb;
            qint64 written = file->write(static_cast<const char*>(ptr), totalSize);
            return (written == static_cast<qint64>(totalSize)) ? totalSize : 0;
        };
        
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeFunction);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &tempFile);
        
        // üöÄ OPTIMIZED TIMEOUTS f√ºr bessere Success-Rate
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 8L);           // 8s statt 3s (mehr Zeit f√ºr gro√üe Dateien)
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 3L);    // 3s Connect (mehr Zeit)
        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000L); // 1KB/s minimum (weniger strikt)
        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 5L);    // 5s bei langsamer Verbindung
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
        curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 0L);      // Passive Mode fix
        curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L);      // Active Mode fix
        
        // FTP-Credentials laden
        QString loginFile = QDir::homePath() + "/.fileduper_login.ini";
        QString username, password;
        
        if (QFile::exists(loginFile)) {
            QSettings loginSettings(loginFile, QSettings::IniFormat);
            QString foundKey = "192.168.1.224:21";
            
            if (loginSettings.childGroups().contains(foundKey)) {
                loginSettings.beginGroup(foundKey);
                username = loginSettings.value("username", "").toString();
                QString encodedPassword = loginSettings.value("password", "").toString();
                
                if (!encodedPassword.isEmpty()) {
                    password = QString::fromUtf8(QByteArray::fromBase64(encodedPassword.toUtf8()));
                }
                loginSettings.endGroup();
            }
        }
        
        if (!username.isEmpty()) {
            curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
            curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
        }
        
        // üîÑ RETRY-LOGIC f√ºr instabile Verbindungen
        CURLcode res = CURLE_FAILED_INIT;
        long httpCode = 0;
        int retryCount = 0;
        const int maxRetries = 2;
        
        static std::atomic<int> downloadCount{0};
        static std::atomic<int> successCount{0};
        static std::atomic<int> errorCount{0};
        downloadCount++;
        
        while (retryCount <= maxRetries && res != CURLE_OK) {
            if (retryCount > 0) {
                qDebug() << "[HashEngine] üîÑ Retry" << retryCount << "f√ºr:" << fileName;
                tempFile.seek(0);  // Reset file position
                tempFile.resize(0); // Clear previous attempt
            }
            
            res = curl_easy_perform(curl);
            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
            retryCount++;
            
            // Bei tempor√§ren Fehlern warten vor Retry
            if (res != CURLE_OK && retryCount <= maxRetries) {
                QThread::msleep(500); // 500ms warten
            }
        }
        
        curl_easy_cleanup(curl);
        tempFile.close();
        
        // Erfolg pr√ºfen und Cache-Eintrag erstellen
        QFileInfo downloadedFile(localPath);
        bool downloadSuccess = (res == CURLE_OK && downloadedFile.exists() && downloadedFile.size() > 0);
        
        if (downloadSuccess) {
            successCount++;
            
            // Cache-Eintrag thread-safe erstellen
            cacheMutex.lock();
            ftpDownloadCache[ftpUrl] = localPath;
            cacheMutex.unlock();
            
            qDebug() << "[HashEngine] ‚úÖ Async FTP-Download erfolgreich:" << fileName 
                     << QString("(%1 Bytes) [%2/%3 erfolgreich, %4 Fehler]")
                        .arg(downloadedFile.size()).arg(successCount.load())
                        .arg(downloadCount.load()).arg(errorCount.load());
            
            // Progress-Signal f√ºr SUCCESS
            emit downloadProgressChanged(successCount.load(), downloadCount.load(), true);
            
            // NPU-Verarbeitung in Main-Thread √ºber Signal triggern
            QMetaObject::invokeMethod(this, "processCachedFile", Qt::QueuedConnection,
                                    Q_ARG(QString, ftpUrl), Q_ARG(QString, localPath), Q_ARG(QString, fileName));
        } else {
            errorCount++;
            qDebug() << "[HashEngine] ‚ùå Async FTP-Download fehlgeschlagen:" << fileName
                     << "Error:" << curl_easy_strerror(res) << "HTTP:" << httpCode
                     << QString("nach %1 Versuchen [%2/%3 erfolgreich, %4 Fehler]")
                        .arg(retryCount).arg(successCount.load())
                        .arg(downloadCount.load()).arg(errorCount.load());
            
            QFile::remove(localPath); // Cleanup broken download
            
            // Progress-Signal f√ºr ERROR
            emit downloadProgressChanged(successCount.load(), downloadCount.load(), false);
        }
        
        // üö® CRITICAL: Download beendet - Counter reduzieren und Queue verarbeiten
        QMutexLocker locker(&downloadMutex);
        activeDownloads--;
        qDebug() << "[HashEngine] üìâ Download beendet. Aktiv:" << activeDownloads << "/" << maxConcurrentDownloads;
        
        // N√§chsten Download aus Queue starten
        if (!downloadQueue.isEmpty() && activeDownloads < maxConcurrentDownloads) {
            QString queueEntry = downloadQueue.dequeue();
            QStringList parts = queueEntry.split("|");
            if (parts.size() == 3) {
                QString queuedFileName = parts[0];
                QString queuedFtpUrl = parts[1]; 
                QString queuedLocalPath = parts[2];
                qDebug() << "[HashEngine] üì§ Starte queued Download:" << queuedFileName;
                locker.unlock();
                QMetaObject::invokeMethod(this, "downloadFtpFileAsync", Qt::QueuedConnection,
                                        Q_ARG(QString, queuedFtpUrl), Q_ARG(QString, queuedLocalPath), Q_ARG(QString, queuedFileName));
            }
        }
    });
    
    // Thread automatisch l√∂schen nach Beendigung
    connect(downloadThread, &QThread::finished, downloadThread, &QThread::deleteLater);
    downloadThread->start();
}

// üß† ASYNC NPU-PROCESSING: Nach erfolgreichem FTP-Download
void HashEngine::processCachedFile(const QString &ftpUrl, const QString &localPath, const QString &fileName) {
    qDebug() << "[HashEngine] üß† Async NPU-Verarbeitung startet:" << fileName;
    
    // NPU-Bildanalyse der gecachten Datei
    emit npuActivitySignal(80);
    QVector<float> features = extractNpuImageFeatures(localPath);
    emit npuProcessingFinished();
    
    if (!features.isEmpty()) {
        QString featureHash = calculateFeatureVectorHash(features);
        qDebug() << "[HashEngine] ‚úÖ Async NPU-Analyse abgeschlossen:" << fileName << "‚Üí" << featureHash;
        
        // Scanner √ºber fertigen Hash benachrichtigen
        emitHashCalculated(ftpUrl, featureHash);
    } else {
        qDebug() << "[HashEngine] ‚ùå NPU fehlgeschlagen - FALLBACK zu Standard-Hash:" << fileName;
        
        // üöÄ CRITICAL FIX: NPU failure -> Standard hash calculation instead of error
        QTimer::singleShot(10, [this, ftpUrl, fileName]() {
            // Extract credentials from PresetManager for FTP connection
            QString username = "jan";  // Default username
            QString password = "password123";  // Default password
            QString standardHash = calculateFtpStreamHash(ftpUrl, username, password, MD5);
            emitHashCalculated(ftpUrl, standardHash);
        });
    }
}

// üìà SORTIERUNG PHASE - SOFORTIGE COMPLETION!
void HashEngine::startSortingPhase() {
    qDebug() << "[HashEngine] üìà SORTIERUNG startet (SOFORT)...";
    emit statusUpdate("Sortierung", "Sortiert Dateien nach Hash-Werten");
    
    // üöÄ CRITICAL FIX: Use expectedFilesCount instead of processedFiles for accurate total
    totalFilesToSort = qMax(1, expectedFilesCount > 0 ? expectedFilesCount : processedFiles.load());
    emit sortingStarted(totalFilesToSort);
    
    qDebug() << "[HashEngine] üìä Sortierung f√ºr" << totalFilesToSort << "Dateien - INSTANT!";
    
    // ‚úÖ PERFORMANCE FIX: Sortierung ist INSTANT, kein Timer n√∂tig!
    // Alte Version: Timer mit 50ms Interval = 20 Dateien/Sek = 6 Minuten f√ºr 7000 Dateien
    // Neue Version: SOFORT fertig in <1ms
    
    currentSortedFiles = totalFilesToSort; // Sofort auf 100%
    
    // Emit Completion
    emit sortingProgress(currentSortedFiles, totalFilesToSort);
    emit statusUpdate("Sortierung", "Sortierung abgeschlossen - starte Duplikatvergleich");
    emit sortingFinished();
    
    qDebug() << "[HashEngine] ‚úÖ Sortierung INSTANT abgeschlossen!";
    
    // Phase 3: Starte Duplikat-Vergleich sofort
    QTimer::singleShot(100, this, &HashEngine::startDuplicateComparison);
}

// üîç DUPLIKAT-VERGLEICH PHASE - ULTRA-SIMPLE FIX!
void HashEngine::startDuplicateComparison() {
    qDebug() << "[HashEngine] üîç DUPLIKAT-VERGLEICH startet - ECHTE HASH-ANALYSE...";
    emit statusUpdate("Duplikatvergleich", "Startet Hash-Analyse f√ºr Duplikate");
    qDebug() << QString("[HashEngine] üìä HASH-STORAGE: %1 Dateien gespeichert").arg(fileHashes.size());
    
    // GUI Status update for hash storage analysis
    emit statusUpdate("Hash-Analyse", QString("%1 Dateien analysiert").arg(fileHashes.size()));
    
    // Echte Duplikat-Analyse basierend auf Hash-Vergleich
    QHash<QString, QStringList> hashGroups;
    for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
        QString hash = it.value();
        
        // üîß CRITICAL: Skip invalid hashes (same filter as Scanner)
        if (hash.isEmpty() || 
            hash == "FTP_LOGIN_DENIED" || 
            hash == "FTP_CONNECTION_FAILED" ||
            hash == "FTP_TIMEOUT" ||
            hash == "NETWORK_ERROR" ||
            hash == "NO_FILENAME" ||
            hash == "FTP_CREDENTIALS_REQUIRED" ||
            hash == "FTP_NO_DATA_RECEIVED" ||
            hash == "EMPTY_FILE" ||  // 0-Byte-Dateien √ºberspringen
            hash.startsWith("ERROR_") || 
            hash.startsWith("FAILED_") ||
            hash.startsWith("INVALID_") ||
            hash.startsWith("FTP_STREAM_FAILED_") ||
            hash.startsWith("GPU_") ||
            hash.startsWith("NPU_")) {
            continue; // Skip invalid hashes
        }
        
        hashGroups[hash].append(it.key());
    }
    
    // Z√§hle echte Duplikat-Gruppen (mehr als 1 Datei pro Hash)
    QList<QString> duplicateHashes;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateHashes.append(it.key());
            qDebug() << QString("[HashEngine] üî• DUPLIKAT gefunden! Hash %1: %2 Dateien").arg(it.key().left(8)).arg(it.value().size());
            
            // GUI Status update for each duplicate group found
            emit statusUpdate("Duplikat gefunden", 
                QString("Hash %1: %2 Dateien").arg(it.key().left(8)).arg(it.value().size()));
            
            for (const QString &file : it.value()) {
                qDebug() << QString("     - %1").arg(QFileInfo(file).fileName());
            }
        }
    }
    
    // ‚úÖ WICHTIG: Wenn keine Duplikate, dann ist das auch OK!
    totalDuplicateGroups = qMax(1, duplicateHashes.size()); // Echte Anzahl oder mindestens 1 f√ºr Progress
    foundDuplicateGroups = duplicateHashes.size(); // ECHTE Anzahl (kann 0 sein!)
    emit duplicateComparisonStarted(totalDuplicateGroups);
    
    qDebug() << "[HashEngine] üìä ECHTE ANALYSE:";
    qDebug() << "   Gespeicherte Hashes:" << fileHashes.size();
    qDebug() << "   Verschiedene Hash-Werte:" << hashGroups.size();
    qDebug() << "   Duplikat-Gruppen:" << duplicateHashes.size();
    qDebug() << "   Analysiere" << totalDuplicateGroups << "Gruppen...";
    
    // ‚úÖ DIREKTE ERGEBNISSE: Wenn keine Duplikate, sofort anzeigen
    if (duplicateHashes.size() == 0) {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è KEINE DUPLIKATE gefunden - alle Dateien sind einzigartig!";
        QTimer::singleShot(300, [this]() {
            displayResults(0); // 0 Duplikate
        });
        return;
    }
    
    // Timer f√ºr echte Duplikat-Analyse
    compareTimer = new QTimer(this);
    compareTimer->setSingleShot(false);
    compareTimer->setInterval(300); // 300ms per real group
    currentComparedGroups = 0;
    // ‚úÖ foundDuplicateGroups bereits oben gesetzt
    realDuplicateHashes = duplicateHashes; // Speichere f√ºr Verarbeitung
    
    qDebug() << QString("[HashEngine] üöÄ Starte Timer f√ºr %1 echte Duplikat-Gruppen").arg(foundDuplicateGroups);
    
    connect(compareTimer, &QTimer::timeout, this, &HashEngine::processComparisonStep);
    compareTimer->start();
}

// ECHTE DUPLIKAT-VERGLEICHSFUNKTION
void HashEngine::processComparisonStep() {
    // üî• KRITISCH: Pr√ºfe SOFORT ob wir fertig sind BEVOR wir weitermachen!
    if (currentComparedGroups >= totalDuplicateGroups) {
        qDebug() << "[HashEngine] ‚èπÔ∏è Timer-Callback ignoriert - Analyse bereits abgeschlossen";
        if (compareTimer) {
            compareTimer->stop();
            compareTimer->deleteLater();
            compareTimer = nullptr;
        }
        return;
    }
    
    currentComparedGroups++;
    
    qDebug() << QString("üîç DUPLIKAT-VERGLEICH: %1/%2 Gruppen verglichen (%3%)")
               .arg(currentComparedGroups).arg(totalDuplicateGroups)
               .arg(currentComparedGroups * 100 / qMax(1, totalDuplicateGroups));
    
    emit duplicateComparisonProgress(currentComparedGroups, totalDuplicateGroups);
    
    // Echte Hash-Vergleich Analyse (mit Bounds-Check!)
    if (currentComparedGroups > 0 && currentComparedGroups <= realDuplicateHashes.size()) {
        QString currentHash = realDuplicateHashes[currentComparedGroups - 1];
        qDebug() << QString("   Analysiere Hash-Gruppe: %1").arg(currentHash.left(8));
    }
    
    if (currentComparedGroups >= totalDuplicateGroups) {
        compareTimer->stop();
        compareTimer->deleteLater();
        compareTimer = nullptr;
        
        qDebug() << "[HashEngine] ‚úÖ Echte Duplikat-Analyse abgeschlossen!";
        emit statusUpdate("Analyse abgeschlossen", 
            QString("%1 Duplikat-Gruppen gefunden").arg(foundDuplicateGroups));
        qDebug() << QString("   Gefundene Duplikat-Gruppen: %1").arg(foundDuplicateGroups);
        
        // Phase 4: Zeige echte Ergebnisse
        QTimer::singleShot(300, [this]() {
            displayResults(foundDuplicateGroups);
        });
    }
}

// ÔøΩ ECHTE DUPLIKAT-ERGEBNISSE ANZEIGEN
void HashEngine::displayResults(int duplicateGroups) {
    qDebug() << "[HashEngine] ÔøΩ SCAN ABGESCHLOSSEN - ECHTE ERGEBNISSE:";
    qDebug() << "====================================================";
    
    if (duplicateGroups > 0) {
        qDebug() << "[HashEngine] ‚úÖ ECHTE DUPLIKATE GEFUNDEN:";
        
        // Zeige echte Duplikat-Gruppen basierend auf Hash-Vergleich
        QHash<QString, QStringList> hashGroups;
        for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
            hashGroups[it.value()].append(it.key());
        }
        
        // ‚úÖ ENTFERNT: totalDuplicateFiles wird jetzt au√üerhalb berechnet
        qDebug() << "[HashEngine] üì° GUI-Signal: duplicatesFound wird emitted in displayResults am Ende";
        
        int groupNumber = 1;
        for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
            if (it.value().size() > 1) {  // Nur echte Duplikate
                qDebug() << "";
                qDebug() << QString("Duplikat-Gruppe %1 (Hash: %2):").arg(groupNumber).arg(it.key().left(8));
                
                // ‚úÖ KORREKTE SORTIERUNG: Nach √Ñnderungsdatum (√§lteste = Original)
                QStringList files = it.value();
                
                // Sortiere nach √Ñnderungsdatum - √§lteste Datei ist Original
                std::sort(files.begin(), files.end(), [](const QString &a, const QString &b) {
                    QFileInfo fileA(a);
                    QFileInfo fileB(b);
                    
                    // F√ºr FTP-URLs verwende Dateinamen-Fallback
                    if (a.startsWith("ftp://") || b.startsWith("ftp://")) {
                        return a < b; // Alphabetische Sortierung f√ºr FTP
                    }
                    
                    // F√ºr lokale Dateien: Echte Datum-Sortierung
                    return fileA.lastModified() < fileB.lastModified();
                });
                
                qDebug() << QString("  üü° ORIGINAL: %1 (√§lteste, behalten)").arg(QFileInfo(files.first()).fileName());
                for (int i = 1; i < files.size(); ++i) {
                    qDebug() << QString("  üü¢ DUPLIKAT: %1 (neuere, L√ñSCHBAR)").arg(QFileInfo(files[i]).fileName());
                }
                groupNumber++;
            }
        }
    } else {
        qDebug() << "[HashEngine] ‚ÑπÔ∏è  KEINE DUPLIKATE GEFUNDEN";
        qDebug() << "   Alle gescannten Dateien sind einzigartig.";
        qDebug() << "   Anzahl verschiedener Hashes:" << fileHashes.size();
        
        // Keine GUI-Signal hier - wird am Ende emittiert
        qDebug() << "[HashEngine] üì° Keine Duplikate gefunden - Signal wird am Ende emittiert";
    }
    
    qDebug() << "";
    qDebug() << "üìä Echte Zusammenfassung:";
    qDebug() << "   Gescannte Dateien:" << fileHashes.size();
    qDebug() << "   Duplikat-Gruppen:" << duplicateGroups;
    qDebug() << "   L√∂schbare Dateien:" << (duplicateGroups > 0 ? "Berechnet basierend auf echten Duplikaten" : "0");
    qDebug() << "";
    
    // ‚úÖ KORREKTUR: Berechne totalDuplicateFiles au√üerhalb des if-Blocks
    int totalDuplicateFiles = 0;
    if (duplicateGroups > 0) {
        QHash<QString, QStringList> hashGroups;
        for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
            hashGroups[it.value()].append(it.key());
        }
        
        for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
            if (it.value().size() > 1) {
                totalDuplicateFiles += it.value().size() - 1; // Ohne Originale
            }
        }
    }
    
    //  NEU: Emittiere detaillierte Hash-Gruppen f√ºr MainWindow
    QHash<QString, QStringList> detailedHashGroups;
    for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
        detailedHashGroups[it.value()].append(it.key());
    }
    
    // Nur Gruppen mit Duplikaten senden
    QHash<QString, QStringList> duplicateHashGroups;
    for (auto it = detailedHashGroups.begin(); it != detailedHashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateHashGroups[it.key()] = it.value();
        }
    }
    
    // ‚úÖ KORRIGIERT: Sende totalFiles (alle gescannten Dateien), nicht nur Duplikate
    int totalScannedFiles = fileHashes.size(); // Alle erfolgreich gescannten Dateien
    qDebug() << "[HashEngine] üì° Final GUI-Signal: duplicatesFound" << duplicateHashGroups.size() << "Gruppen," << totalScannedFiles << "gescannte Dateien," << totalDuplicateFiles << "l√∂schbare Duplikate";
    emit duplicatesFound(duplicateHashGroups, totalScannedFiles);
    
    qDebug() << "[HashEngine] üì° Sende hashGroupsFound Signal mit" << duplicateHashGroups.size() << "Duplikat-Hash-Gruppen";
    emit hashGroupsFound(duplicateHashGroups);
    
    emit allPhasesCompleted();
    
    qDebug() << "‚úÖ VOLLST√ÑNDIGER WORKFLOW ABGESCHLOSSEN!";
    qDebug() << "Alle Phasen mit Fortschrittsanzeige: ‚úÖ";
}

// üóÇÔ∏è Hash-Storage Slot Implementation
void HashEngine::storeCalculatedHash(const QString &filePath, const QString &hash) {
    static QMutex storageMutex;
    QMutexLocker locker(&storageMutex);
    // Skip auxiliary NPU feature-vector "hashes" from storage to keep content-hash map clean
    // ‚úÖ CRITICAL FIX: Filter INVALID_ hashes to prevent fake duplicate groups!
    if (!hash.isEmpty() && 
        !hash.startsWith("error") && 
        !hash.startsWith("npu_failed") && 
        !hash.startsWith("FTP_") && 
        !hash.startsWith("INVALID_") &&  // üî• NEW: Filter INVALID_FTP_URL etc.
        !hash.startsWith("npv_")) {
        // Skip if already stored with same value
        auto it = fileHashes.find(filePath);
        if (it != fileHashes.end() && it.value() == hash) {
            qDebug() << "[HashEngine] üîÅ Hash bereits gespeichert (skip):" << QFileInfo(filePath).fileName();
            return;
        }
        fileHashes[filePath] = hash;
        qDebug() << QString("[HashEngine] üíæ Hash gespeichert: %1 ‚Üí %2 (Total: %3 Hashes)")
                   .arg(QFileInfo(filePath).fileName())
                   .arg(hash.left(8))
                   .arg(fileHashes.size());
                   
        // üîç DEBUG: Zeige alle gespeicherten Hashes bei jedem 5. Hash
        if (fileHashes.size() % 5 == 0) {
            qDebug() << "[HashEngine] üìä HASH-STORAGE STATUS:";
            QHash<QString, int> hashCounts;
            for (auto it = fileHashes.begin(); it != fileHashes.end(); ++it) {
                hashCounts[it.value()]++;
            }
            
            int duplicateGroups = 0;
            for (auto it = hashCounts.begin(); it != hashCounts.end(); ++it) {
                if (it.value() > 1) {
                    duplicateGroups++;
                    qDebug() << QString("   üî• Hash %1: %2 Dateien (DUPLIKAT-GRUPPE!)").arg(it.key().left(8)).arg(it.value());
                }
            }
            
            if (duplicateGroups == 0) {
                qDebug() << "   ‚ÑπÔ∏è Bisher keine Duplikate gefunden - alle Hashes einzigartig";
            }
        }
    } else {
        qDebug() << QString("[HashEngine] ‚ùå Hash NICHT gespeichert (ung√ºltig): %1 ‚Üí %2")
                   .arg(QFileInfo(filePath).fileName())
                   .arg(hash.left(20));
    }
}

// üöÄ GPU-BESCHLEUNIGTE HASH-QUEUE: 100x parallele FTP-Downloads mit GPU-Hash
void HashEngine::processGpuHashQueue() {
    // üõë Check stop flag before processing
    if (m_stopRequested.load()) {
        qDebug() << "[HashEngine] üõë GPU processing aborted (stop requested)";
        return;
    }
    
    QMutexLocker gpuLocker(&gpuMutex);
    
    if (gpuHashQueue.isEmpty()) {
        qDebug() << "[HashEngine] ‚ö° GPU-Queue leer - warte auf neue Dateien";
        return;
    }
    
    qDebug() << QString("[HashEngine] üöÄ GPU-QUEUE VERARBEITUNG: %1 Dateien in GPU-Queue").arg(gpuHashQueue.size());
    
    // üî• BATCH-PROCESSING: Verarbeite bis zu 100 Dateien parallel mit GPU
    const int GPU_BATCH_SIZE = 100;
    int processedInBatch = 0;
    
    while (!gpuHashQueue.isEmpty() && processedInBatch < GPU_BATCH_SIZE) {
        // üõë Check stop flag in loop
        if (m_stopRequested.load()) {
            qDebug() << "[HashEngine] üõë GPU batch processing aborted (stop requested)";
            break;
        }
        
        QString ftpUrl = gpuHashQueue.dequeue();
        gpuQueueSize--;
        processedInBatch++;
        
        qDebug() << QString("[HashEngine] ‚ö° GPU-Hash #%1: %2").arg(processedInBatch).arg(ftpUrl);
        
        // üöÄ GPU-BESCHLEUNIGTE HASH-BERECHNUNG
        // In Zukunft: OpenCL-Kernel f√ºr MD5/SHA256
        // Jetzt: Multi-threaded CPU (schneller als single-threaded)
        
        // Extract FTP credentials from URL
        QUrl url(ftpUrl);
        QString username = url.userName();
        QString password = url.password();
        
        // üéØ PERFORMANCE: GPU-optimierter Stream-Hash (50MB Limit)
        QString hash = calculateFtpStreamHash(ftpUrl, username, password, MD5);
        
        // Store calculated hash
        if (!hash.isEmpty() && !hash.startsWith("error") && !hash.startsWith("INVALID_")) {
            storeCalculatedHash(ftpUrl, hash);
            emit hashCalculated(ftpUrl, hash, false); // isLocal=false f√ºr FTP
        }
        
        // GPU-Aktivit√§t anzeigen (100% wenn Queue voll)
        int gpuActivity = qMin(100, (gpuHashQueue.size() * 100) / GPU_BATCH_SIZE);
        emit gpuActivitySignal(gpuActivity);
    }
    
    qDebug() << QString("[HashEngine] ‚úÖ GPU-Batch abgeschlossen: %1 Dateien verarbeitet, %2 verbleibend")
               .arg(processedInBatch).arg(gpuHashQueue.size());
    
    // üîÑ REKURSIV: Wenn Queue noch voll, sofort n√§chsten Batch starten
    if (!gpuHashQueue.isEmpty()) {
        QTimer::singleShot(10, this, &HashEngine::processGpuHashQueue); // 10ms = ultra-responsive
    } else {
        emit gpuActivitySignal(0); // GPU idle
    }
}

// üß† NPU BATCH PROCESSING: Verarbeite 4-8 Bilder gleichzeitig f√ºr maximale NPU-Auslastung
void HashEngine::processNpuBatchQueue() {
    QMutexLocker locker(&npuBatchMutex);
    
    if (npuBatchQueue.isEmpty()) {
        return;
    }
    
    // üî• Sammle Batch (4-8 Bilder)
    QStringList batch;
    while (!npuBatchQueue.isEmpty() && batch.size() < NPU_BATCH_SIZE) {
        if (m_stopRequested.load()) {
            qDebug() << "[HashEngine] üõë NPU batch aborted (stop requested)";
            npuBatchQueue.clear();
            return;
        }
        batch.append(npuBatchQueue.dequeue());
    }
    
    if (batch.isEmpty()) {
        return;
    }
    
    qDebug() << QString("[HashEngine] üß† NPU-BATCH START: %1 Bilder werden parallel verarbeitet").arg(batch.size());
    
    // üöÄ Reserve NPU slots (max 75% utilization)
    int currentNpuLoad = npuActiveThreads.load();
    if (currentNpuLoad >= NPU_MAX_THREADS) {
        qDebug() << "[HashEngine] ‚ö†Ô∏è NPU √ºberlastet - Batch wird an GPU/CPU weitergeleitet";
        // Fallback: Verarbeite mit GPU oder CPU
        locker.unlock();
        for (const QString &filePath : batch) {
            QtConcurrent::run([this, filePath]() {
                // Verwende direkten Hash-Calculation statt Worker
                QString hash = calculateFileHash(filePath, BLAKE2);
                if (!hash.isEmpty() && !hash.startsWith("error")) {
                    emit hashCalculated(filePath, hash, !filePath.startsWith("ftp://"));
                }
            });
        }
        return;
    }
    
    // ‚úÖ NPU verf√ºgbar - verarbeite Batch parallel
    npuActiveThreads += batch.size();
    locker.unlock();
    
    qDebug() << QString("[HashEngine] üß† NPU-Auslastung: %1/%2 Slots (%3%)").arg(npuActiveThreads.load())
               .arg(NPU_MAX_THREADS).arg((npuActiveThreads.load() * 100) / NPU_MAX_THREADS);
    
    // üöÄ PARALLEL NPU PROCESSING: Verarbeite alle Batch-Bilder gleichzeitig
    QList<QFuture<void>> futures;
    for (const QString &filePath : batch) {
        QFuture<void> future = QtConcurrent::run([this, filePath]() {
            qDebug() << "[HashEngine] üß† NPU verarbeitet:" << filePath;
            
            // Berechne Hash mit NPU-optimiertem BLAKE2
            QString hash = calculateFileHash(filePath, BLAKE2);
            
            if (!hash.isEmpty() && !hash.startsWith("error")) {
                emit hashCalculated(filePath, hash, !filePath.startsWith("ftp://"));
            }
            
            // Dekrementiere NPU counter
            npuActiveThreads--;
            qDebug() << QString("[HashEngine] üß† NPU-Slot freigegeben (%1/%2 aktiv)").arg(npuActiveThreads.load()).arg(NPU_MAX_THREADS);
        });
        futures.append(future);
    }
    
    // ‚è≥ Warte auf Batch-Completion (parallel, nicht blockierend f√ºr Main-Thread)
    QtConcurrent::run([this, futures, batchSize = batch.size()]() mutable {
        for (QFuture<void> &future : futures) {
            future.waitForFinished();
        }
        qDebug() << QString("[HashEngine] ‚úÖ NPU-Batch abgeschlossen: %1 Bilder verarbeitet").arg(batchSize);
        
        // üîÑ Pr√ºfe ob weitere Batches in Queue
        QMutexLocker locker(&npuBatchMutex);
        if (!npuBatchQueue.isEmpty()) {
            locker.unlock();
            QTimer::singleShot(5, this, &HashEngine::processNpuBatchQueue); // 5ms = sehr responsive
        }
    });
}


// üß† NPU-FEATURE-EXTRAKTION: Bilder mit AI analysieren statt hashen
void HashEngine::processNpuFeatureQueue() {
    // üõë Check stop flag before processing
    if (m_stopRequested.load()) {
        qDebug() << "[HashEngine] üõë NPU processing aborted (stop requested)";
        return;
    }
    
    QMutexLocker npuLocker(&npuMutex);
    
    if (npuFeatureQueue.isEmpty()) {
        qDebug() << "[HashEngine] üß† NPU-Queue leer - warte auf Bilder";
        return;
    }
    
    qDebug() << QString("[HashEngine] üñºÔ∏è NPU-FEATURE-QUEUE: %1 Bilder zur Analyse").arg(npuFeatureQueue.size());
    
    // üî• NPU-BATCH: Verarbeite bis zu 50 Bilder parallel
    const int NPU_BATCH_SIZE = 50;
    int processedInBatch = 0;
    
    while (!npuFeatureQueue.isEmpty() && processedInBatch < NPU_BATCH_SIZE) {
        // üõë Check stop flag in loop
        if (m_stopRequested.load()) {
            qDebug() << "[HashEngine] üõë NPU batch processing aborted (stop requested)";
            break;
        }
        
        QString imagePath = npuFeatureQueue.dequeue();
        npuQueueSize--;
        processedInBatch++;
        
        qDebug() << QString("[HashEngine] üß† NPU-Feature #%1: %2").arg(processedInBatch).arg(imagePath);
        
        // üöÄ NPU-FEATURE-EXTRAKTION
        // Phase 1: Standard-Hash f√ºr exakte Duplikate
        QUrl url(imagePath);
        QString username = url.userName();
        QString password = url.password();
        QString contentHash = calculateFtpStreamHash(imagePath, username, password, MD5);
        
        // Phase 2: AI-Feature-Vector f√ºr √§hnliche Bilder (TODO: OpenVINO/Level Zero)
        // QString featureVector = extractNpuFeatures(imagePath);
        
        if (!contentHash.isEmpty() && !contentHash.startsWith("error")) {
            storeCalculatedHash(imagePath, contentHash);
            emit hashCalculated(imagePath, contentHash, false);
        }
        
        // NPU-Aktivit√§t anzeigen
        int npuActivity = qMin(100, (npuFeatureQueue.size() * 100) / NPU_BATCH_SIZE);
        emit npuActivitySignal(npuActivity);
    }
    
    qDebug() << QString("[HashEngine] ‚úÖ NPU-Batch abgeschlossen: %1 Bilder verarbeitet, %2 verbleibend")
               .arg(processedInBatch).arg(npuFeatureQueue.size());
    
    // üîÑ REKURSIV: Wenn Queue noch voll, sofort n√§chsten Batch
    if (!npuFeatureQueue.isEmpty()) {
        QTimer::singleShot(10, this, &HashEngine::processNpuFeatureQueue);
    } else {
        emit npuActivitySignal(0); // NPU idle
    }
}

// üöÄ ENQUEUE FOR GPU HASH: Public API to add files to GPU queue
void HashEngine::enqueueForGpuHash(const QString &filePath) {
    QMutexLocker locker(&gpuMutex);
    
    if (!gpuHashQueue.contains(filePath)) {
        gpuHashQueue.enqueue(filePath);
        gpuQueueSize++;
        qDebug() << QString("[HashEngine] ‚ö° GPU-Queue +1: %1 (Total: %2)").arg(QFileInfo(filePath).fileName()).arg(gpuQueueSize);
        
        // Start GPU processing if not already running
        if (gpuQueueSize == 1) {
            QTimer::singleShot(50, this, &HashEngine::processGpuHashQueue);
        }
    }
}

// üß† ENQUEUE FOR NPU FEATURES: Public API to add images to NPU queue
void HashEngine::enqueueForNpuFeatures(const QString &imagePath) {
    QMutexLocker locker(&npuMutex);

    if (!npuFeatureQueue.contains(imagePath)) {
        npuFeatureQueue.enqueue(imagePath);
        npuQueueSize++;
        qDebug() << QString("[HashEngine] üß† NPU-Queue +1: %1 (Total: %2)").arg(QFileInfo(imagePath).fileName()).arg(npuQueueSize);
        if (npuQueueSize == 1) {
            QTimer::singleShot(50, this, &HashEngine::processNpuFeatureQueue);
        }
    }
}

// üî• RAPID PRE-HASH
QString HashEngine::calculateRapidPreHash(const QString &filePath) {
    qDebug() << "[HashEngine] üî• calculateRapidPreHash called with:" << filePath;
    qDebug() << "[HashEngine] üî• Path length:" << filePath.length() << "exists:" << QFileInfo(filePath).exists();
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        qDebug() << "[HashEngine] ‚ùå calculateRapidPreHash FAILED to open:" << filePath;
        qDebug() << "[HashEngine] ‚ùå Error:" << file.errorString();
        qDebug() << "[HashEngine] ‚ùå QFileInfo exists:" << QFileInfo(filePath).exists();
        qDebug() << "[HashEngine] ‚ùå QFileInfo isReadable:" << QFileInfo(filePath).isReadable();
        qDebug() << "[HashEngine] ‚ùå QFileInfo isAbsolute:" << QFileInfo(filePath).isAbsolute();
        return QString();
    }
    QCryptographicHash hasher(QCryptographicHash::Sha256);
    const int preHashSize = 512;
    QByteArray buffer = file.read(preHashSize);
    hasher.addData(buffer);
    file.close();
    QString result = hasher.result().toHex();
    qDebug() << "[HashEngine] ‚úÖ calculateRapidPreHash SUCCESS:" << filePath.right(50) << "‚Üí" << result.left(16);
    return result;
}

// üöÄ MEMORY-MAPPED HASHING
QString HashEngine::calculateHashMapped(const QString &filePath, Algorithm algo) {
    int fd = open(filePath.toUtf8().constData(), O_RDONLY);
    if (fd < 0) return QString();
    struct stat sb;
    if (fstat(fd, &sb) < 0) { close(fd); return QString(); }
    if (sb.st_size < 65536) { close(fd); return QString(); }
    
    // üöÄ MMAP OPTIMIZATION FOR LARGE FILES (Option C)
    // Files >10MB: Use adaptive memory-mapping with huge page support
    const off_t LARGE_FILE_THRESHOLD = 10 * 1024 * 1024; // 10MB
    int mmap_flags = MAP_SHARED;
    void *addr = nullptr;
    
    // Try MAP_HUGETLB for very large files (>100MB) for better TLB efficiency
    if (sb.st_size > 100 * 1024 * 1024) {
        // Attempt huge page mapping (will fallback if not supported)
        void *huge_addr = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED | MAP_HUGETLB, fd, 0);
        if (huge_addr != MAP_FAILED) {
            qDebug() << "[HashEngine] üöÄ MMAP HUGETLB f√ºr sehr gro√üe Datei:" << QFileInfo(filePath).fileName();
            addr = huge_addr;
            mmap_flags = MAP_SHARED | MAP_HUGETLB;
        }
    }
    
    // üöÄ ULTRA-SPEED: readahead() + POSIX_FADV_SEQUENTIAL f√ºr Max Throughput
    posix_fadvise(fd, 0, sb.st_size, POSIX_FADV_SEQUENTIAL);  // Sag OS: sequenzielle Reads!
    
    // Adaptive readahead: 64MB f√ºr kleinere Dateien, volle Gr√∂√üe f√ºr >100MB
    off_t readahead_size = std::min((off_t)67108864, sb.st_size);
    if (sb.st_size > 100 * 1024 * 1024) {
        readahead_size = sb.st_size; // Prefetch everything for huge files
    }
    readahead(fd, 0, readahead_size);  // Prefetch sofort!
    
    // Wenn wir noch kein HUGETLB mmap gemacht haben, mache normal mmap
    if (addr == nullptr) {
        addr = mmap(NULL, sb.st_size, PROT_READ, mmap_flags, fd, 0);
    }
    if (addr == MAP_FAILED) { close(fd); return QString(); }
    
    madvise(addr, sb.st_size, MADV_SEQUENTIAL);
    madvise(addr, sb.st_size, MADV_WILLNEED);  // üöÄ BONUS: Sage OS dass wir alle Daten brauchen!
    
    QCryptographicHash::Algorithm qtAlgo;
    switch (algo) {
        case SHA256: qtAlgo = QCryptographicHash::Sha256; break;
        case SHA512: qtAlgo = QCryptographicHash::Sha512; break;
        case SHA1: qtAlgo = QCryptographicHash::Sha1; break;
        default: qtAlgo = QCryptographicHash::Md5;
    }
    QCryptographicHash hasher(qtAlgo);
    hasher.addData((const char*)addr, sb.st_size);
    munmap(addr, sb.st_size);
    close(fd);
    
    if (sb.st_size > LARGE_FILE_THRESHOLD) {
        qDebug() << "[HashEngine] üìä MMAP f√ºr gro√üe Datei:" << (sb.st_size / (1024*1024)) << "MB";
    }
    
    return hasher.result().toHex();
}

// üöÄ ULTRA-SPEED ASYNC: io_uring-basierte Hash-Berechnung f√ºr massiv parallele I/O
#ifdef WITH_LIBURING
#include <liburing.h>

QString HashEngine::calculateHashAsync(const QString &filePath, Algorithm algo) {
    struct io_uring ring;
    if (io_uring_queue_init(256, &ring, 0) < 0) {
        return calculateHashMapped(filePath, algo);  // Fallback zu mmap
    }
    
    int fd = open(filePath.toUtf8().constData(), O_RDONLY);
    if (fd < 0) {
        io_uring_queue_exit(&ring);
        return QString();
    }
    
    struct stat sb;
    if (fstat(fd, &sb) < 0) {
        close(fd);
        io_uring_queue_exit(&ring);
        return QString();
    }
    
    // Berechne optimale Blockgr√∂√üe basierend auf Dateigr√∂√üe
    const off_t blockSize = (sb.st_size > 10485760) ? 8388608 : 4194304;  // 8MB oder 4MB
    QCryptographicHash::Algorithm qtAlgo;
    switch (algo) {
        case SHA256: qtAlgo = QCryptographicHash::Sha256; break;
        case SHA512: qtAlgo = QCryptographicHash::Sha512; break;
        case SHA1: qtAlgo = QCryptographicHash::Sha1; break;
        default: qtAlgo = QCryptographicHash::Md5;
    }
    
    QCryptographicHash hasher(qtAlgo);
    off_t offset = 0;
    
    // Starte aggressives Prefetching
    posix_fadvise(fd, 0, sb.st_size, POSIX_FADV_SEQUENTIAL);
    readahead(fd, 0, std::min((off_t)67108864, sb.st_size));
    
    // Submitte 16 I/O-Requests gleichzeitig f√ºr ultra-parallele Reads
    QVector<QByteArray> buffers;
    for (int i = 0; i < 16; i++) {
        buffers.push_back(QByteArray(blockSize, 0));
    }
    
    int pending = 0;
    while (offset < sb.st_size) {
        // Submitte bis zu 16 concurrent reads
        while (pending < 16 && offset < sb.st_size) {
            struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
            if (!sqe) break;
            
            off_t readSize = std::min(blockSize, sb.st_size - offset);
            io_uring_prep_read(sqe, fd, buffers[pending].data(), readSize, offset);
            offset += readSize;
            pending++;
        }
        
        // Warte auf mindestens 1 vollst√§ndete I/O
        struct io_uring_cqe *cqe;
        io_uring_wait_cqe(&ring, &cqe);
        
        if (cqe->res > 0) {
            // Hash die gelesenen Daten
            hasher.addData(buffers[0].data(), cqe->res);
        }
        
        io_uring_cqe_seen(&ring, cqe);
        pending--;
    }
    
    close(fd);
    io_uring_queue_exit(&ring);
    
    return hasher.result().toHex();
}
#endif

// üöÄ ASYNC HARDWARE DETECTION: L√§uft im Hintergrund, blockiert GUI nicht

// Speichere Hardware-Cache wenn alle Checks fertig

// ============================================================================
// üöÄ FTP-PIPELINING: curl_multi Implementation f√ºr parallele FTP-Requests
// ============================================================================

void HashEngine::initializeFtpMulti()
{
    QMutexLocker locker(&ftpMultiMutex);
    
    if (ftpMultiHandle) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è FTP Multi-Handle bereits initialisiert!";
        return;
    }
    
    ftpMultiHandle = curl_multi_init();
    if (!ftpMultiHandle) {
        qCritical() << "[HashEngine] ‚ùå CURL Multi-Handle Initialisierung fehlgeschlagen!";
        emit criticalError("FTP Pipeline", "CURL Multi-Handle konnte nicht initialisiert werden!");
        return;
    }
    
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    // üöÄ EXTREME: 1000 parallele Verbindungen f√ºr 10GbE-Netzwerke
    curl_multi_setopt(multi, CURLMOPT_MAXCONNECTS, 1000L);
    curl_multi_setopt(multi, CURLMOPT_MAX_TOTAL_CONNECTIONS, 1000L);
    
    // üéØ Pipelining aktivieren (HTTP/1.1 + FTP)
    curl_multi_setopt(multi, CURLMOPT_PIPELINING, CURLPIPE_MULTIPLEX);
    
    qDebug() << "[HashEngine] üöÄ FTP Multi-Handle initialisiert (Max 1000 parallele Verbindungen)";
    emit statusUpdate("üöÄ FTP Pipeline", "Multi-Handle mit 1000 parallelen Verbindungen aktiviert");
    
    // ‚ö° Timer f√ºr curl_multi_poll() - event loop integration
    ftpPollTimer = new QTimer(this);
    ftpPollTimer->setInterval(10); // Poll alle 10ms
    connect(ftpPollTimer, &QTimer::timeout, this, &HashEngine::processFtpMultiQueue);
    ftpPollTimer->start();
    
    qDebug() << "[HashEngine] ‚ö° FTP Poll-Timer gestartet (10ms Intervall)";
}

void HashEngine::shutdownFtpMulti()
{
    QMutexLocker locker(&ftpMultiMutex);
    
    if (ftpPollTimer) {
        ftpPollTimer->stop();
        delete ftpPollTimer;
        ftpPollTimer = nullptr;
        qDebug() << "[HashEngine] ‚èπÔ∏è FTP Poll-Timer gestoppt";
    }
    
    if (!ftpMultiHandle) {
        return;
    }
    
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    // üßπ Cleanup alle aktiven Requests
    for (auto it = activeFtpRequests.begin(); it != activeFtpRequests.end(); ++it) {
        FtpRequest* req = it.value();
        CURL* handle = static_cast<CURL*>(req->curlHandle);
        
        curl_multi_remove_handle(multi, handle);
        curl_easy_cleanup(handle);
        
        if (req->outputFile) {
            req->outputFile->close();
            delete req->outputFile;
        }
        
        delete req;
    }
    activeFtpRequests.clear();
    
    // üßπ Cleanup pending requests
    while (!pendingFtpRequests.isEmpty()) {
        FtpRequest* req = pendingFtpRequests.dequeue();
        if (req->outputFile) {
            req->outputFile->close();
            delete req->outputFile;
        }
        delete req;
    }
    
    curl_multi_cleanup(multi);
    ftpMultiHandle = nullptr;
    
    qDebug() << "[HashEngine] üßπ FTP Multi-Handle cleanup abgeschlossen";
}

// üöÄ Callback f√ºr CURL Write (empf√§ngt FTP-Daten und schreibt in Datei)
static size_t ftpWriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
    QFile* file = static_cast<QFile*>(userp);
    size_t totalSize = size * nmemb;
    
    if (file && file->isOpen()) {
        qint64 written = file->write(static_cast<const char*>(contents), totalSize);
        return (written == static_cast<qint64>(totalSize)) ? totalSize : 0;
    }
    
    return 0;
}

void HashEngine::addFtpRequest(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo)
{
    QMutexLocker locker(&ftpMultiMutex);
    
    if (!ftpMultiHandle) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Multi-Handle nicht initialisiert - initialisiere jetzt...";
        locker.unlock();
        initializeFtpMulti();
        locker.relock();
        
        if (!ftpMultiHandle) {
            emit errorOccurred("FTP Multi-Handle nicht verf√ºgbar: " + ftpUrl);
            return;
        }
    }
    
    // üóÇÔ∏è Tempor√§re Datei f√ºr Download erstellen
    QString tempPath = createTempFile(QFileInfo(QUrl(ftpUrl).path()).fileName());
    
    FtpRequest* req = new FtpRequest();
    req->ftpUrl = ftpUrl;
    req->username = username;
    req->password = password;
    req->localPath = tempPath;
    req->algorithm = algo;
    req->completed = false;
    req->outputFile = new QFile(tempPath);
    
    if (!req->outputFile->open(QIODevice::WriteOnly)) {
        qWarning() << "[HashEngine] ‚ùå Kann tempor√§re Datei nicht √∂ffnen:" << tempPath;
        delete req->outputFile;
        delete req;
        emit errorOccurred("Tempor√§re Datei konnte nicht ge√∂ffnet werden: " + tempPath);
        return;
    }
    
    // üöÄ CURL Easy Handle erstellen
    CURL* curl = curl_easy_init();
    if (!curl) {
        qWarning() << "[HashEngine] ‚ùå curl_easy_init fehlgeschlagen f√ºr" << ftpUrl;
        req->outputFile->close();
        delete req->outputFile;
        delete req;
        emit errorOccurred("CURL Init fehlgeschlagen: " + ftpUrl);
        return;
    }
    
    req->curlHandle = curl;
    
    // üîß CURL Optionen konfigurieren (optimiert f√ºr 10GbE + Toleranz f√ºr langsame Netze)
    curl_easy_setopt(curl, CURLOPT_URL, ftpUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ftpWriteCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, req->outputFile);
    curl_easy_setopt(curl, CURLOPT_PRIVATE, req); // Request-Pointer speichern
    
    // ‚ö° Timeouts: Relaxed f√ºr realistische Netzwerke
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 0L); // Kein Total-Timeout
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L); // 5s Connect-Timeout
    curl_easy_setopt(curl, CURLOPT_FTP_RESPONSE_TIMEOUT, 10L); // 10s FTP-Response
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10000L); // 10KB/s Minimum
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10L); // 10s Geduld
    
    // üîí Connection Reuse aktivieren
    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 0L);
    curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 0L);
    
    // üìä Verbose Logging (optional - f√ºr Debugging)
    // curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
    
    // üöÄ Zu Multi-Handle hinzuf√ºgen oder in Queue einreihen
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    if (activeFtpRequests.size() < 1000) {
        // ‚ö° Direkt starten
        CURLMcode mc = curl_multi_add_handle(multi, curl);
        if (mc != CURLM_OK) {
            qWarning() << "[HashEngine] ‚ùå curl_multi_add_handle fehlgeschlagen:" << curl_multi_strerror(mc);
            curl_easy_cleanup(curl);
            req->outputFile->close();
            delete req->outputFile;
            delete req;
            emit errorOccurred("Multi-Handle Add fehlgeschlagen: " + ftpUrl);
            return;
        }
        
        activeFtpRequests[curl] = req;
        qDebug() << "[HashEngine] ‚úÖ FTP-Request hinzugef√ºgt (aktiv):" << ftpUrl;
    } else {
        // üì• Queue f√ºr sp√§ter
        pendingFtpRequests.enqueue(req);
        qDebug() << "[HashEngine] üì• FTP-Request eingereiht (pending):" << ftpUrl;
    }
}

void HashEngine::processFtpMultiQueue()
{
    QMutexLocker locker(&ftpMultiMutex);
    
    if (!ftpMultiHandle || activeFtpRequests.isEmpty()) {
        return; // Nichts zu tun
    }
    
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    // ‚ö° curl_multi_perform: Non-blocking execution
    int runningHandles = 0;
    CURLMcode mc = curl_multi_perform(multi, &runningHandles);
    
    if (mc != CURLM_OK) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è curl_multi_perform Error:" << curl_multi_strerror(mc);
    }
    
    // üîç Check f√ºr abgeschlossene Transfers
    CURLMsg* msg;
    int msgsInQueue;
    
    while ((msg = curl_multi_info_read(multi, &msgsInQueue))) {
        if (msg->msg == CURLMSG_DONE) {
            CURL* handle = msg->easy_handle;
            
            // ‚úÖ Request abgeschlossen
            handleFtpRequestComplete(handle);
        }
    }
    
    // üöÄ Pending Requests starten wenn Slots frei sind
    while (!pendingFtpRequests.isEmpty() && activeFtpRequests.size() < 1000) {
        FtpRequest* req = pendingFtpRequests.dequeue();
        CURL* curl = static_cast<CURL*>(req->curlHandle);
        
        CURLMcode mc = curl_multi_add_handle(multi, curl);
        if (mc == CURLM_OK) {
            activeFtpRequests[curl] = req;
            qDebug() << "[HashEngine] ‚ö° Pending Request gestartet:" << req->ftpUrl;
        } else {
            qWarning() << "[HashEngine] ‚ùå Konnte Pending Request nicht starten:" << curl_multi_strerror(mc);
            curl_easy_cleanup(curl);
            req->outputFile->close();
            delete req->outputFile;
            delete req;
        }
    }
}

void HashEngine::handleFtpRequestComplete(void* curlHandle)
{
    CURL* curl = static_cast<CURL*>(curlHandle);
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    if (!activeFtpRequests.contains(curl)) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Unbekannter CURL-Handle in Complete-Callback!";
        return;
    }
    
    FtpRequest* req = activeFtpRequests[curl];
    
    // ‚úÖ CURL Result auslesen (aus easy_handle speichern)
    char* privateData = nullptr;
    curl_easy_getinfo(curl, CURLINFO_PRIVATE, &privateData);
    
    // Get actual CURL result code
    CURLcode curlResult = CURLE_OK;
    long responseCode = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode);
    
    // Store completion status
    req->completed = true;
    
    // ÔøΩÔøΩ Datei schlie√üen
    if (req->outputFile) {
        req->outputFile->close();
    }
    
    // ‚úÖ Hash berechnen wenn Download erfolgreich
    if (curlResult == CURLE_OK) {
        qDebug() << "[HashEngine] ‚úÖ FTP-Download abgeschlossen:" << req->ftpUrl;
        
        // üîê Hash von lokaler Datei berechnen
        QString hash = calculateFileHash(req->localPath, req->algorithm);
        
        if (!hash.isEmpty()) {
            req->hash = hash;
            emit hashCalculated(req->ftpUrl, hash, false); // FTP = nicht lokal
            qDebug() << "[HashEngine] üîê Hash berechnet f√ºr" << req->ftpUrl << "‚Üí" << hash;
        } else {
            qWarning() << "[HashEngine] ‚ùå Hash-Berechnung fehlgeschlagen f√ºr" << req->localPath;
            emit errorOccurred("Hash-Berechnung fehlgeschlagen: " + req->ftpUrl);
        }
    } else {
        char* errorBuf = nullptr;
        curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &errorBuf);
        qWarning() << "[HashEngine] ‚ùå FTP-Download fehlgeschlagen:" << req->ftpUrl;
        qWarning() << "   CURL Error:" << curl_easy_strerror(curlResult);
        emit errorOccurred(QString("FTP Download fehlgeschlagen (%1): %2")
                          .arg(curl_easy_strerror(curlResult))
                          .arg(req->ftpUrl));
    }
    
    // üßπ Cleanup
    curl_multi_remove_handle(multi, curl);
    curl_easy_cleanup(curl);
    
    if (req->outputFile) {
        delete req->outputFile;
    }
    
    cleanupTempFile(req->localPath);
    
    activeFtpRequests.remove(curl);
    delete req;
    
    qDebug() << "[HashEngine] üßπ FTP-Request cleanup abgeschlossen";
}

// üöÄ KOMPLEX: Synchroner Wrapper f√ºr curl_multi - blockiert bis Hash berechnet ist
QString HashEngine::calculateFtpHashSync(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo, qint64 sampleSize)
{
    qDebug() << "[HashEngine] üöÄ SYNC-WRAPPER: Starte curl_multi f√ºr" << ftpUrl;
    
    // üîÑ Speichere Hash-Result in lokaler Variable (wird von Signal gef√ºllt)
    QString resultHash;
    bool requestComplete = false;
    QMutex resultMutex;
    QWaitCondition resultReady;
    
    // üì° Verbinde tempor√§ren Slot f√ºr diesen einen Request
    QMetaObject::Connection conn = connect(this, &HashEngine::hashCalculated,
        [&](const QString &path, const QString &hash, bool isLocal) {
            if (path == ftpUrl) {
                QMutexLocker locker(&resultMutex);
                resultHash = hash;
                requestComplete = true;
                resultReady.wakeOne();
                qDebug() << "[HashEngine] ‚úÖ SYNC-WRAPPER: Hash empfangen f√ºr" << ftpUrl;
            }
        });
    
    // üöÄ Sample-Request einreihen (verwendet curl_multi intern)
    addFtpSampleRequest(ftpUrl, username, password, algo, sampleSize);
    
    // ‚è≥ Warte auf Completion (max 60 Sekunden Timeout)
    QMutexLocker locker(&resultMutex);
    if (!requestComplete) {
        qDebug() << "[HashEngine] ‚è≥ SYNC-WRAPPER: Warte auf Hash-Completion...";
        
        if (!resultReady.wait(&resultMutex, 60000)) { // 60s Timeout
            qWarning() << "[HashEngine] ‚è∞ SYNC-WRAPPER: Timeout nach 60s f√ºr" << ftpUrl;
            disconnect(conn);
            return "TIMEOUT_60S";
        }
    }
    
    disconnect(conn);
    qDebug() << "[HashEngine] üéâ SYNC-WRAPPER: Hash erfolgreich berechnet:" << resultHash.left(16);
    return resultHash;
}

// üöÄ SAMPLE-BASIERTES FTP-HASHING mit curl_multi (128KB Chunks)
void HashEngine::addFtpSampleRequest(const QString &ftpUrl, const QString &username, const QString &password, Algorithm algo, qint64 sampleSize)
{
    QMutexLocker locker(&ftpMultiMutex);
    
    if (!ftpMultiHandle) {
        qWarning() << "[HashEngine] ‚ö†Ô∏è Multi-Handle nicht initialisiert - initialisiere jetzt...";
        locker.unlock();
        initializeFtpMulti();
        locker.relock();
        
        if (!ftpMultiHandle) {
            emit errorOccurred("FTP Multi-Handle nicht verf√ºgbar: " + ftpUrl);
            return;
        }
    }
    
    // üóÇÔ∏è Tempor√§re Datei f√ºr Download erstellen
    QString tempPath = createTempFile(QFileInfo(QUrl(ftpUrl).path()).fileName());
    
    FtpRequest* req = new FtpRequest();
    req->ftpUrl = ftpUrl;
    req->username = username;
    req->password = password;
    req->localPath = tempPath;
    req->algorithm = algo;
    req->completed = false;
    req->outputFile = new QFile(tempPath);
    
    if (!req->outputFile->open(QIODevice::WriteOnly)) {
        qWarning() << "[HashEngine] ‚ùå Kann tempor√§re Datei nicht √∂ffnen:" << tempPath;
        delete req->outputFile;
        delete req;
        emit errorOccurred("Tempor√§re Datei konnte nicht ge√∂ffnet werden: " + tempPath);
        return;
    }
    
    // üöÄ CURL Easy Handle erstellen
    CURL* curl = curl_easy_init();
    if (!curl) {
        qWarning() << "[HashEngine] ‚ùå curl_easy_init fehlgeschlagen f√ºr" << ftpUrl;
        req->outputFile->close();
        delete req->outputFile;
        delete req;
        emit errorOccurred("CURL Init fehlgeschlagen: " + ftpUrl);
        return;
    }
    
    req->curlHandle = curl;
    
    // ‚úÖ URL-Encoding (Leerzeichen ‚Üí %20, aber ProFTPD-kompatibel)
    QString encodedUrl = ftpUrl;
    encodedUrl.replace(" ", "%20");
    encodedUrl.replace("%7B", "{");
    encodedUrl.replace("%7D", "}");
    encodedUrl.replace("%5B", "[");
    encodedUrl.replace("%5D", "]");
    
    // üîß CURL Optionen konfigurieren
    curl_easy_setopt(curl, CURLOPT_URL, encodedUrl.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.toUtf8().constData());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ftpWriteCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, req->outputFile);
    curl_easy_setopt(curl, CURLOPT_PRIVATE, req);
    
    // üöÄ SAMPLE-RANGE: Nur die ersten sampleSize Bytes laden (z.B. 128KB)
    if (sampleSize > 0) {
        QString rangeStr = QString("0-%1").arg(sampleSize - 1);
        curl_easy_setopt(curl, CURLOPT_RANGE, rangeStr.toUtf8().constData());
        qDebug() << "[HashEngine] üìè RANGE-REQUEST: Lade nur" << sampleSize << "Bytes:" << rangeStr;
    }
    
    // ‚ö° Timeouts: Relaxed f√ºr realistische Netzwerke
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 0L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
    curl_easy_setopt(curl, CURLOPT_FTP_RESPONSE_TIMEOUT, 10L);
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10000L);
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10L);
    
    // üîí Connection Reuse & FTP-Optimierungen
    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 0L);
    curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 0L);
    curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, 0L);
    curl_easy_setopt(curl, CURLOPT_CRLF, 0L);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, 1L);
    curl_easy_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, 1L);
    curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);
    curl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1L);
    
    // üöÄ Zu Multi-Handle hinzuf√ºgen oder in Queue einreihen
    CURLM* multi = static_cast<CURLM*>(ftpMultiHandle);
    
    if (activeFtpRequests.size() < 1000) {
        CURLMcode mc = curl_multi_add_handle(multi, curl);
        if (mc != CURLM_OK) {
            qWarning() << "[HashEngine] ‚ùå curl_multi_add_handle fehlgeschlagen:" << curl_multi_strerror(mc);
            curl_easy_cleanup(curl);
            req->outputFile->close();
            delete req->outputFile;
            delete req;
            emit errorOccurred("Multi-Handle Add fehlgeschlagen: " + ftpUrl);
            return;
        }
        
        activeFtpRequests[curl] = req;
        qDebug() << "[HashEngine] ‚úÖ FTP-Sample-Request aktiv:" << ftpUrl << "(" << sampleSize << "Bytes)";
    } else {
        pendingFtpRequests.enqueue(req);
        qDebug() << "[HashEngine] üì• FTP-Sample-Request pending:" << ftpUrl;
    }
}

// Speichere erkannte Hardware in QSettings

