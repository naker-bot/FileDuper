#include "scanner.h"
#include "fileduper_logging.h"
#include "hashengine.h"
#include "presetmanager.h"
#include "ftpclient.h"
#include "sftpclient.h"          // ‚úÖ SFTP Client Include
#include "smbclient.h"           // ‚úÖ SMB Client Include
#include "nfsclient.h"           // ‚úÖ NFS Client Include
#include <QApplication>
#include <QDebug>
#include <QDir>
#include <QDirIterator>
#include <QDateTime>
#include <QCryptographicHash>
#include <QFileInfo>
#include <QUrl>
#include <QFile>
#include <QStandardPaths>
#include <iostream>

Scanner::Scanner(QObject *parent)
    : QObject(parent), hashEngine(nullptr), presetManager(nullptr), ftpClient(nullptr), 
      sftpClient(nullptr), smbClient(nullptr), nfsClient(nullptr), npuManager(nullptr),
      scanning(false), paused(false), currentPhase(IDLE), ftpDirectoriesProcessed(0),
      currentSimilarityMode(NpuManager::NEAR_DUPLICATES)  // üéØ Default: Sehr √§hnliche Bilder
{
    std::cout << "[Scanner] üîç Scanner initialisiert" << std::endl;

    // Ultra-responsive Timer f√ºr GUI
    processTimer = new QTimer(this);
    processTimer->setSingleShot(false);
    processTimer->setInterval(25); // 25ms = 40 FPS f√ºr fl√ºssige GUI
    connect(processTimer, &QTimer::timeout, this, &Scanner::processNextFile);

    // ‚úÖ Asynchroner Timer f√ºr Dateisammlung - verhindert GUI-Blockierung
    fileCollectionTimer = new QTimer(this);
    fileCollectionTimer->setSingleShot(false);
    fileCollectionTimer->setInterval(50); // 50ms = 20 FPS f√ºr responsive Dateisammlung
    connect(fileCollectionTimer, &QTimer::timeout, this, &Scanner::processNextDirectoryChunk);

    // ‚è±Ô∏è Abbrechbarer Hash-Timeout-Timer
    hashTimeoutTimer = new QTimer(this);
    hashTimeoutTimer->setSingleShot(true);
    connect(hashTimeoutTimer, &QTimer::timeout, this, [this]() {
        if (!scanning.load() || currentPhase != HASHING) return;
        if (hashProcessedCount >= totalFilesForHashing && totalFilesForHashing > 0) return; // already done
        qWarning() << "[Scanner] üö® ERWEITERTER TIMEOUT (Timer): Hashing dauert zu lange - versuche partielle Ergebnisse";
        DuplicateGroups partialResults = buildPartialResults();
        if (partialResults.groups.size() > 0) {
            qDebug() << "[Scanner] üéØ TIMEOUT (Timer) partielle Ergebnisse:" << partialResults.groups.size() << "Gruppen";
            qDebug() << "[Scanner] üö® emit scanCompleted(PARTIAL) - TIMEOUT with results";
            scanning.store(false);
            currentPhase = COMPLETED;
            emit scanProgress(100, hashProcessedCount, totalFilesForHashing);
            emit scanCompleted(partialResults);
        } else {
            qWarning() << "[Scanner] ‚ö†Ô∏è TIMEOUT (Timer) keine part. Ergebnisse";
            qDebug() << "[Scanner] üö® emit scanCompleted(EMPTY) - TIMEOUT without results";
            scanning.store(false);
            currentPhase = COMPLETED;
            emit scanProgress(100, hashProcessedCount, totalFilesForHashing);
            DuplicateGroups empty;
            emit scanCompleted(empty);
        }
    });

    // Initialisiere Pfad-Deduplicator f√ºr optimierte Verarbeitung
    
    // üöÄ 8-ENGINE SYSTEM: Initialize parallel HashEngine pool
    initializeEnginePool();
}

Scanner::~Scanner()
{
    stopScan();
    cleanupEnginePool();
}

void Scanner::setHashEngine(HashEngine *engine)
{
    hashEngine = engine;
    if (hashEngine)
    {
        connect(hashEngine, &HashEngine::hashCalculated,
                this, &Scanner::onHashCalculated, Qt::DirectConnection);
    }
}

void Scanner::setPresetManager(PresetManager *manager)
{
    presetManager = manager;
}

void Scanner::setFtpClient(FtpClient *client)
{
    // Disconnect previous client safely to avoid duplicate signal deliveries
    if (ftpClient) {
        QObject::disconnect(ftpClient, nullptr, this, nullptr);
    }
    ftpClient = client;
    // Note: We intentionally do NOT connect filesListFinished here.
    // Per-host clients created in collectFtpFiles() are connected with a
    // scoped lambda using Qt::UniqueConnection to avoid double-processing
    // and race conditions when multiple FTP directories are scanned.
}

// üß† NPU-INTEGRATION: NPU-Manager f√ºr intelligente Bildverarbeitung
void Scanner::setNpuManager(NpuManager *manager)
{
    npuManager = manager;
    if (npuManager)
    {
        connect(npuManager, &NpuManager::imageBatchProcessed,
                this, &Scanner::onNpuImageBatchProcessed);
        qDebug() << "[Scanner] üß† NPU-Manager f√ºr Bildverarbeitung verbunden";
    }
}

void Scanner::setNpuEnabled(bool enabled)
{
    npuEnabled = enabled;
    FD_LOG_INFO() << "[Scanner] üß† NPU enabled set to" << npuEnabled;
}

void Scanner::startScan(const QStringList &directories, const QString &hashAlgorithm, const QString &fileFilter)
{
    // üéØ FTP-STATUS INITIALISIERUNG
    activeFtpScans.store(0);
    ftpScanningActive.store(false);
    qDebug() << "[Scanner] üîÑ FTP-Status zur√ºckgesetzt f√ºr neuen Scan";

    FD_LOG_INFO() << "[Scanner] üöÄ startScan" << directories.size() << "Verzeichnisse";
    FD_LOG_DEBUG() << "[Scanner] üîç Verzeichnisse:" << directories;
    FD_LOG_INFO() << "[Scanner] Hash-Algorithmus:" << hashAlgorithm << "Filter:" << fileFilter;
    FD_LOG_INFO() << "[Scanner] NPU enabled?" << npuEnabled;

    // üìä INITIAL PROGRESS-UPDATE: Verwende Input-Parameter statt noch nicht initialisierte scanDirectories
    emit scanProgress(0, -1, directories.size()); // -1 = Gesamtanzahl noch unbekannt
    emit scanStatusChanged(QString("üîç Initialisiere Scan f√ºr %1 Verzeichnisse...").arg(directories.size()));
    emit currentFileProcessing("Initialisierung", "üîç Sammle verf√ºgbare Dateien...", 0, directories.size());
    emit processActivityUpdate("üîç Starte Duplikat-Scan", QString("Bereite %1 Verzeichnisse vor").arg(directories.size()));

    // Defensive pointer checks (log-only, allow scan to proceed where possible)
    if (!hashEngine) qWarning() << "[Scanner] ‚ö†Ô∏è hashEngine ist null ‚Äì Hashing wird sp√§ter eventuell √ºbersprungen.";
    if (!presetManager) qWarning() << "[Scanner] ‚ö†Ô∏è presetManager ist null ‚Äì FTP-Logins verwenden Default-Credentials.";

    // üß† NPU-Counter zur√ºcksetzen bei neuem Scan
    npuProcessedImages = 0;
    qDebug() << "[Scanner] üîÑ NPU-Counter zur√ºckgesetzt f√ºr neuen Scan";

    // ‚úÖ FIX: Clear processed files cache f√ºr neuen Scan
    if (hashEngine) {
        hashEngine->clearProcessedFiles();
        qDebug() << "[Scanner] üßπ HashEngine processed files cache geleert";
    }

    // ‚úÖ FIX: Pr√ºfe ob bereits ein Scan l√§uft
    if (scanning.load()) {
        qDebug() << "[Scanner] ‚è∏Ô∏è Stoppe vorherigen Scan, starte neuen...";
        stopScan(); // Stoppe aktuellen Scan
        scanning.store(false); // Reset scanning state
    }

    if (directories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå EARLY EXIT: Keine Verzeichnisse zum Scannen!";
        qDebug() << "[Scanner] üö® emit scanCompleted(EMPTY) - EARLY EXIT #1";
        emit scanProgress(100, 0, 0);
        emit scanStatusChanged("‚ùå Keine Verzeichnisse ausgew√§hlt");
        emit scanCompleted(DuplicateGroups{});
        return;
    }

    // ‚úÖ IMPROVED: Bessere Remote-Path-Erkennung f√ºr alle Protokolle
    QStringList localDirectories;
    QStringList remoteDirectories;
    
    for (const QString &dir : directories) {
        if (isRemotePath(dir)) {
            remoteDirectories.append(dir);
        } else {
            localDirectories.append(dir);
        }
    }
    
    FD_LOG_DEBUG() << "[Scanner] üìÇ Lokale Verzeichnisse:" << localDirectories.size();
    FD_LOG_DEBUG() << "[Scanner] üì° Remote-Verzeichnisse:" << remoteDirectories.size();

    // Deduplicate directories to prevent redundant work
    QStringList optimizedDirectories = deduplicateDirectories(directories);
    
    if (optimizedDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå EARLY EXIT: Nach Pfad-Optimierung keine Verzeichnisse √ºbrig!";
        qDebug() << "[Scanner] üö® emit scanCompleted(EMPTY) - EARLY EXIT #2";
        emit scanCompleted(DuplicateGroups{});
        return;
    }

    scanDirectories = optimizedDirectories;
    currentHashAlgorithm = hashAlgorithm;
    currentFileFilter = fileFilter;

    // üìä KORRIGIERTER PROGRESS-UPDATE: Jetzt mit korrekter scanDirectories Anzahl
    emit scanProgress(0, -1, scanDirectories.size());
    emit scanStatusChanged(QString("üîç Optimiert: %1 Verzeichnisse bereit zum Scannen").arg(scanDirectories.size()));
    qDebug() << "[Scanner] ‚úÖ Scan bereit f√ºr" << scanDirectories.size() << "optimierte Verzeichnisse";

    // üõ°Ô∏è KRITISCH: Deduplication-Caches f√ºr NEUEN Scan zur√ºcksetzen
    clearDeduplicationCaches();
    qDebug() << "[Scanner] üîÑ Neuer Scan gestartet - Deduplication-Caches zur√ºckgesetzt";

    // Reset state
    allFiles.clear();
    fileSizeGroups.clear();
    hashGroups.clear();

    // üõ°Ô∏è RACE CONDITION FIX: Neue Scan-ID generieren f√ºr FTP-Callback-Validierung
    currentScanId.store(QDateTime::currentMSecsSinceEpoch());
    qDebug() << "[Scanner] üÜî Neue Scan-ID generiert:" << currentScanId.load();

    scanning.store(true);
    paused.store(false);
    currentPhase = COLLECTING;

    qDebug() << "[Scanner] üîç Pfad-Optimierung:" << directories.size()
              << "‚Üí" << optimizedDirectories.size() << "Verzeichnisse";
    emit scanStatusChanged("Sammle Dateien (parallel: lokal + netzwerk)...");

    qDebug() << "[Scanner] üéØ KURZ VOR startAsyncFileCollection() Aufruf";
    startAsyncFileCollection();
    qDebug() << "[Scanner] üéØ NACH startAsyncFileCollection() Aufruf";
}

QStringList Scanner::deduplicateDirectories(const QStringList &directories)
{
    QSet<QString> canonicalPaths;
    QStringList result;

    // Convert all paths to canonical form (handle both local and FTP paths)
    QMap<QString, QString> originalToCanonical;
    for (const QString &dir : directories)
    {
        QString canonical;
        
        // üõ°Ô∏è CRASH-FIX: SAFE URL/path handling f√ºr FTP und lokale Pfade
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            canonical = dir; // FTP/Network paths bleiben unver√§ndert
            qDebug() << "[Scanner] üì° Network-URL beibehalten:" << canonical;
        } else {
            // SAFE: Nur auf lokale Pfade canonicalPath() anwenden
            QDir dirObj(dir);
            if (dirObj.exists()) {
                canonical = dirObj.canonicalPath();
                qDebug() << "[Scanner] üìÇ Lokaler Pfad kanonisch:" << canonical;
            } else {
                canonical = dir; // Falls nicht existiert, Original beibehalten
                qDebug() << "[Scanner] ‚ö†Ô∏è Pfad existiert nicht, Original beibehalten:" << canonical;
            }
        }
        
        if (!canonical.isEmpty())
        {
            originalToCanonical[dir] = canonical;
        }
    }

    // Remove parent-child relationships and duplicates
    for (auto it = originalToCanonical.begin(); it != originalToCanonical.end(); ++it)
    {
        QString currentPath = it.value();
        bool isRedundant = false;

        // Check if this path is a child of any already processed path
        for (const QString &existingPath : canonicalPaths)
        {
            if (currentPath.startsWith(existingPath + "/"))
            {
                isRedundant = true;
                std::cout << "‚è≠Ô∏è  √úberspringe Unterverzeichnis: " << it.key().toStdString()
                          << " (enthalten in " << existingPath.toStdString() << ")" << std::endl;
                break;
            }
        }

        if (!isRedundant)
        {
            // Remove any existing paths that are children of the current path
            auto existing = canonicalPaths.begin();
            while (existing != canonicalPaths.end())
            {
                if (existing->startsWith(currentPath + "/"))
                {
                    std::cout << "üîÑ Ersetze Unterverzeichnis " << existing->toStdString()
                              << " durch Elternverzeichnis " << currentPath.toStdString() << std::endl;
                    existing = canonicalPaths.erase(existing);
                }
                else
                {
                    ++existing;
                }
            }

            canonicalPaths.insert(currentPath);
            result.append(it.key());
        }
    }

    return result;
}
void Scanner::stopScan()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] ‚èπÔ∏è FORCE-STOP: Stoppe alle Scan-Aktivit√§ten";
    
    scanning.store(false);
    paused.store(false);
    currentPhase = IDLE;
    
    // üõ°Ô∏è RACE CONDITION PROTECTION: Invalidiere Scan-ID um sp√§te FTP-Callbacks zu stoppen
    currentScanId.store(0);
    qDebug() << "[Scanner] üÜî Scan-ID invalidiert (stopScan)";
    
    // ‚úÖ KRITISCH: Stoppe alle Timer
    if (processTimer) {
        processTimer->stop();
        qDebug() << "[Scanner] üõë ProcessTimer gestoppt";
    }
    
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
        qDebug() << "[Scanner] üõë FileCollectionTimer gestoppt";
    }
    
    if (hashTimeoutTimer) {
        hashTimeoutTimer->stop();
        qDebug() << "[Scanner] üõë HashTimeoutTimer gestoppt";
    }
    
    // ‚úÖ Cleanup asynchrone Dateisammlung
    cleanupFileCollection();
    
    // ‚úÖ KRITISCH: Stoppe HashEngine
    if (hashEngine) {
        // Hier k√∂nnten wir hashEngine->stopCalculation() aufrufen
        hashEngine->clearProcessedFiles(); // üõ°Ô∏è CRITICAL: Clear to prevent infinite loops
        qDebug() << "[Scanner] üõë HashEngine-Stop signalisiert und Cache geleert";
    }
    
    // ‚úÖ KRITISCH: Leere alle Collections f√ºr sauberen Stop
    allFiles.clear();
    hashGroups.clear();
    fileSizeGroups.clear();
    
    // üõ°Ô∏è NEU: Deduplication-Caches leeren bei Scan-Stop
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    
    qDebug() << "[Scanner] üßπ Alle Collections geleert";
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert";
    
    emit scanStatusChanged("‚èπÔ∏è Scan gestoppt - alle Prozesse beendet");
    std::cout << "‚èπÔ∏è Duplikat-Scan vollst√§ndig gestoppt" << std::endl;
    
    // ‚úÖ KRITISCH: Emittiere leere Ergebnisse nur wenn nicht bereits COMPLETED
    if (currentPhase != COMPLETED) {
        DuplicateGroups emptyResults;
        emit scanCompleted(emptyResults);
    }
}

void Scanner::pauseScan()
{
    if (!scanning.load())
        return;

    paused.store(true);
    processTimer->stop();
    emit scanStatusChanged("Scan pausiert");
    std::cout << "‚è∏Ô∏è Duplikat-Scan pausiert" << std::endl;
}

void Scanner::resumeScan()
{
    if (!scanning.load() || !paused.load())
        return;

    paused.store(false);
    processTimer->start();
    emit scanStatusChanged("Scan fortgesetzt");
    std::cout << "‚ñ∂Ô∏è Duplikat-Scan fortgesetzt" << std::endl;
}

// √ñffentliche Wrapper-Methode f√ºr GUI-Rescan: Leert alle relevanten Caches
// und stellt sicher, dass ein erneuter Scan keine residualen Daten nutzt.
void Scanner::resetCachesForRescan()
{
    clearDeduplicationCaches();
    // Zus√§tzlich globale Zust√§nde zur√ºcksetzen, falls n√∂tig
    hashProcessedCount = 0;
    totalFilesForHashing = 0;
    emit scanStatusChanged("üîÑ Deduplication-Caches geleert (Rescan)");
    qDebug() << "[Scanner] üîÑ resetCachesForRescan abgeschlossen";
}

void Scanner::collectFiles()
{
    emit scanStatusChanged("Sammle Dateien parallel (lokal + netzwerk)...");
    QSet<QString> processedFiles; // Prevent duplicate file processing
    
    // Clear FTP processing state
    pendingFtpDirectories.clear();
    completedFtpDirectories.clear();
    ftpDirectoriesProcessed = 0;
    
    bool hasFtpDirectories = false;
    bool hasLocalDirectories = false;
    
    // üéØ FORTSCHRITTS-TRACKING f√ºr Dateien sammeln
    int totalDirectoriesToProcess = scanDirectories.size();
    int processedDirectoriesCount = 0;
    int totalFilesFound = 0;

    for (const QString &directory : scanDirectories)
    {
        if (!scanning.load())
            return;
            
        // üìä LIVE-Update: Verzeichnis-Fortschritt
        processedDirectoriesCount++;
        emit currentFileProcessing(
            QFileInfo(directory).fileName(), 
            "üìÅ Dateien sammeln", 
            processedDirectoriesCount, 
            totalDirectoriesToProcess
        );
        emit processActivityUpdate(
            QString("üìÇ Sammle Dateien aus Verzeichnis %1/%2")
                .arg(processedDirectoriesCount).arg(totalDirectoriesToProcess),
            QString("Aktuell: %1").arg(QFileInfo(directory).fileName())
        );

        // Check if this is an FTP path (both formats: ftp:// and FTP:ip:port/path)
        QString entry = directory.trimmed();
        if (entry.startsWith("ftp://") || entry.startsWith("FTP:"))
        {
            hasFtpDirectories = true;
            
            // ‚úÖ Convert FTP:ip:port/path format to ftp:// format
            QString ftpUrl = directory;
            if (entry.startsWith("FTP:")) {
                // Convert "FTP:192.168.1.224:21/sdf/Bilder" to "ftp://192.168.1.224:21/sdf/Bilder"
                ftpUrl = "ftp://" + entry.mid(4); // Remove "FTP:" and add "ftp://"
                qDebug() << "[Scanner] üîÑ Converted FTP format:" << directory << "‚Üí" << ftpUrl;
            }
            
            collectFtpFiles(ftpUrl, processedFiles);
        }
        else
        {
            hasLocalDirectories = true;
            // Local directory scanning - parallel zu FTP
            QDirIterator it(directory, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);

            while (it.hasNext())
            {
                if (!scanning.load())
                    return;

                QString filePath = it.next();
                QFileInfo fileInfo(filePath);
                
                // ÔøΩ VERZEICHNIS-FILTER: Duplikate d√ºrfen keine Verzeichnisse sein
                if (!fileInfo.isFile()) {
                    qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Verzeichnis:" << filePath;
                    continue;
                }
                
                // ÔøΩüìä LIVE-Update: Datei gefunden
                totalFilesFound++;
                if (totalFilesFound % 50 == 0) { // Alle 50 Dateien Update
                    emit currentFileProcessing(
                        fileInfo.fileName(), 
                        "üîç Dateien scannen", 
                        totalFilesFound, 
                        0  // Unbekannte Gesamtzahl w√§hrend sammeln
                    );
                    emit processActivityUpdate(
                        QString("üìä %1 Dateien gefunden").arg(totalFilesFound),
                        QString("Aktuell: %1").arg(fileInfo.fileName())
                    );
                }

                qDebug() << "[Scanner] üîç Untersuche Datei:" << filePath;

                // Normalize path to prevent duplicates
                QString canonicalPath = fileInfo.canonicalFilePath();
                
                // üõ°Ô∏è FALLBACK: Wenn canonicalFilePath leer ist, verwende absoluten Pfad
                if (canonicalPath.isEmpty()) {
                    canonicalPath = fileInfo.absoluteFilePath();
                    qDebug() << "[Scanner] ‚ö†Ô∏è canonicalFilePath leer, verwende absoluten Pfad:" << canonicalPath;
                }
                
                qDebug() << "[Scanner] üìù Kanonischer Pfad:" << canonicalPath;
                qDebug() << "[Scanner] üìä processedFiles.size():" << processedFiles.size();
                
                // üõ°Ô∏è VEREINFACHTER SCHUTZ: Nur lokaler processedFiles-Cache (globaler wird bei Scan-Ende geleert)
                if (processedFiles.contains(canonicalPath))
                {
                    qDebug() << "[Scanner] üîÑ Datei bereits in diesem Scan verarbeitet (√ºbersprungen):" << canonicalPath.right(50);
                    continue; // Skip duplicate files
                }
                processedFiles.insert(canonicalPath);
                qDebug() << "[Scanner] ‚úÖ Datei zu processedFiles hinzugef√ºgt:" << canonicalPath.right(50);

                // Apply file filter
                if (!currentFileFilter.isEmpty() && currentFileFilter != "Alle Dateien" && currentFileFilter != "*")
                {
                    QString extension = fileInfo.suffix().toLower();
                    qDebug() << "[Scanner] üîç Pr√ºfe Filter:" << currentFileFilter << "vs Extension:" << extension;
                    if (!currentFileFilter.contains(extension, Qt::CaseInsensitive))
                    {
                        qDebug() << "[Scanner] ‚ùå Datei durch Filter ausgeschlossen:" << filePath;
                        continue;
                    }
                }
                else
                {
                    qDebug() << "[Scanner] ‚úÖ Filter √ºbersprungen (alle Dateien):" << currentFileFilter;
                }

                // Skip system paths if PresetManager available
                if (presetManager && presetManager->shouldExcludePath(filePath))
                {
                    qDebug() << "[Scanner] ‚ùå Datei durch PresetManager ausgeschlossen:" << filePath;
                    continue;
                }

                // Ô∏è Optional: Gro√üe Dateien √ºberspringen nur wenn explizit aktiviert
                // Steuerung √ºber FILEDUPER_SKIP_LARGE=1 und optional FILEDUPER_MAX_SIZE_MB (Default 0 = kein Limit)
                qint64 fileSize = fileInfo.size();
                bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
                qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
                if (skipLarge && maxSizeMb > 0) {
                    qint64 maxBytes = maxSizeMb * 1024 * 1024;
                    if (fileSize > maxBytes) {
                        qDebug() << "[Scanner] üö® GROSSE DATEI √ºbersprungen (" << maxSizeMb << "MB):" << filePath << "Gr√∂√üe:" << (fileSize / 1024 / 1024) << "MB";
                        continue;
                    }
                }

                qDebug() << "[Scanner] ‚úÖ Datei bestanden alle Filter, f√ºge zu allFiles hinzu:" << canonicalPath;

                FileInfo file;
                file.filePath = canonicalPath; // Use canonical path
                file.fileName = fileInfo.fileName();
                file.size = fileInfo.size();
                file.lastModified = fileInfo.lastModified().toMSecsSinceEpoch();
                file.isLocal = true; // ‚úÖ NEU: Markiere als lokale Datei

                allFiles.append(file);
                qDebug() << "[Scanner] üìä allFiles.size() nach Hinzuf√ºgung:" << allFiles.size();

                if (allFiles.size() % 1000 == 0)
                {
                    // During collection phase: Show files collected with indeterminate progress
                    emit scanProgress(0, allFiles.size(), -1); // -1 indicates collection phase
                    std::cout << "üìÅ " << allFiles.size() << " lokale Dateien gesammelt..." << std::endl;
                }
            }
        }
    }

    emit filesCollected(allFiles.size());
    
    // üîç SPEICHERE echte Gesamtzahl aller gefundenen Dateien (inkl. Unikate)
    totalFilesFound = allFiles.size();
    qDebug() << "[Scanner] üìä Gesamte Dateien gefunden (inkl. Unikate):" << totalFilesFound;
    
    // üìä KORREKTER PROGRESS-UPDATE: Zeige echte Dateianzahl
    emit scanProgress(0, allFiles.size(), scanDirectories.size());
    emit currentFileProcessing("Dateien gesammelt", QString("üéØ %1 Dateien bereit zum Hashen").arg(allFiles.size()), 0, allFiles.size());
    std::cout << "üìÅ " << allFiles.size() << " eindeutige Dateien gesammelt (lokal: " << (hasLocalDirectories ? "‚úÖ" : "‚ùå") << ", netzwerk: " << (hasFtpDirectories ? "‚úÖ" : "‚ùå") << ")" << std::endl;
    if (processedFiles.size() > allFiles.size())
    {
        std::cout << "üîÑ " << (processedFiles.size() - allFiles.size()) << " Duplikate √ºbersprungen" << std::endl;
    }

    // üîç DEBUG: Zeige hasLocalDirectories und hasFtpDirectories Status vor if-else Kette
    qDebug() << "[Scanner] üîç DEBUG PATH LOGIC: hasLocalDirectories=" << hasLocalDirectories << "hasFtpDirectories=" << hasFtpDirectories;
    
    // ‚úÖ NEU: Parallele Verarbeitung - lokale Dateien sind bereits gesammelt
    if (hasLocalDirectories && !hasFtpDirectories) {
        // Nur lokale Dateien - sofort weiter zur Size-Filterung
        qDebug() << "[Scanner] üìÇ Nur lokale Dateien gefunden, starte Size-Filtering";
        filterBySize();
    } else if (!hasLocalDirectories && hasFtpDirectories) {
        // Nur FTP-Dateien - warte auf FTP-Verarbeitung
        qDebug() << "[Scanner] üì° Nur FTP-Dateien gefunden, warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Lade FTP-Verzeichnisse: 0/%1").arg(pendingFtpDirectories.size()));
    } else if (hasLocalDirectories && hasFtpDirectories) {
        // Beide Arten - lokale sind bereits da, warte auf FTP-Completion
        qDebug() << "[Scanner] ÔøΩ Parallel-Scan: Lokale Dateien fertig (" << allFiles.size() << "), warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Parallel: Lokal fertig (%1), FTP: 0/%2").arg(allFiles.size()).arg(pendingFtpDirectories.size()));
    } else {
        // Keine Dateien gefunden
        qDebug() << "[Scanner] ‚ùå Keine Dateien gefunden";
        filterBySize(); // Leerer Scan
    }
}

void Scanner::filterBySize()
{
    qDebug() << "[Scanner] üìä filterBySize() GESTARTET mit" << allFiles.size() << "Dateien, scanning:" << scanning.load();
    
    if (!scanning.load())
    {
        qDebug() << "[Scanner] ‚ö†Ô∏è filterBySize() ABGEBROCHEN - scanning ist false!";
        return;
    }

    // üéØ GUI-FIX: Size-Filtering als Progress-Phase anzeigen
    emit scanProgress(10, 0, allFiles.size()); // Start bei 10% f√ºr Size-Filtering
    emit scanStatusChanged("üìè Analysiere Dateigr√∂√üen f√ºr Duplikat-Erkennung...");
    currentPhase = SIZE_FILTERING;
    
    // üìä LIVE-Update: Gr√∂√üen-Analyse starten
    emit currentFileProcessing(
        QString("%1 Dateien").arg(allFiles.size()), 
        "üìè Gr√∂√üen-Analyse", 
        0, 
        allFiles.size()
    );
    emit processActivityUpdate(
        "üìä Analysiere Dateigr√∂√üen f√ºr Duplikat-Erkennung",
        QString("Verarbeite %1 Dateien").arg(allFiles.size())
    );

    // Group files by size (unknown-size remote files deferred using size=-1 bucket)
    // ÔøΩ KRITISCHER FIX: Echte Duplikate haben EXAKT die gleiche Gr√∂√üe!
    int processedFiles = 0;
    QList<QString> unknownSizeFiles; // track for lazy fetch
    const qint64 sizeToleranceBytes = 0; // KEINE Toleranz - exakte Gr√∂√üe erforderlich!
    
    for (FileInfo file : allFiles)
    {
        if (!scanning.load())
            return;

        if (!file.isLocal && file.size <= 0 && file.sizeKnown == false) {
            // Place temporarily into size -1 group to avoid pruning; will be resolved later
            fileSizeGroups[-1].append(file);
            unknownSizeFiles.append(file.filePath);
        } else {
            // üî• ENHANCED: Find existing size group within tolerance
            bool foundSimilarGroup = false;
            qint64 targetSize = file.size;
            
            for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ++it) {
                qint64 existingSize = it.key();
                
                // Skip unknown size group
                if (existingSize == -1) continue;
                
                // üö® EXAKTE GR√ñ√üE ERFORDERLICH - Duplikate haben identische Bytes
                if (targetSize == existingSize) { // Nur exakte Gr√∂√üen√ºbereinstimmung!
                    it.value().append(file);
                    foundSimilarGroup = true;
                    qDebug() << "[Scanner] ‚úÖ Datei" << QFileInfo(file.filePath).fileName() 
                             << "(" << targetSize << "bytes) zu exakter Gr√∂√üen-Gruppe hinzugef√ºgt";
                    break;
                }
            }
            
            // If no similar group found, create new group
            if (!foundSimilarGroup) {
                fileSizeGroups[file.size].append(file);
            }
        }
        processedFiles++;

        if (processedFiles % 1000 == 0) {
            // üéØ GUI-FIX: Progress w√§hrend Size-Filtering anzeigen
            int progressPercent = 10 + (int)(40.0 * processedFiles / allFiles.size()); // 10%-50% f√ºr Size-Filtering
            emit scanProgress(progressPercent, processedFiles, allFiles.size());
            
            emit currentFileProcessing(
                QFileInfo(file.filePath).fileName(),
                "üìè Gr√∂√üen-Analyse",
                processedFiles,
                allFiles.size()
            );
            emit processActivityUpdate(
                QString("üìä Gr√∂√üen-Analyse: %1/%2 (%3%)")
                    .arg(processedFiles)
                    .arg(allFiles.size())
                    .arg(int(100.0 * processedFiles / allFiles.size())),
                QString("Aktuell: %1").arg(QFileInfo(file.filePath).fileName())
            );
        }
    }

    if (!unknownSizeFiles.isEmpty()) {
        qDebug() << "[Scanner] ‚è≥" << unknownSizeFiles.size() << "Remote-Dateien mit unbekannter Gr√∂√üe ‚Äì starte Lazy Size Fetch";
    }
    
    // üìä FINAL-Update: Gr√∂√üen-Analyse abgeschlossen
    emit currentFileProcessing(
        QString("%1 Gr√∂√üen-Gruppen").arg(fileSizeGroups.size()), 
        "üìè Gr√∂√üen-Analyse abgeschlossen", 
        allFiles.size(), 
        allFiles.size()
    );

    // ‚úÖ PRODUCTION: Optimiere durch Entfernung von Single-File-Gruppen (echte Duplikat-Erkennung)
    qDebug() << "[Scanner] üìä Size-Groups vor Filterung:" << fileSizeGroups.size() << "verschiedene Gr√∂√üen";
    
    // Entferne Gruppen mit nur einer Datei (keine Duplikate m√∂glich)
    auto it = fileSizeGroups.begin();
    while (it != fileSizeGroups.end())
    {
        const qint64 groupSize = it.key();
        QList<FileInfo> &groupFiles = it.value();
        qDebug() << "[Scanner] üîç DEBUG: Size-Group size=" << groupSize << "fileCount=" << groupFiles.size();
        for (const FileInfo &f : groupFiles) {
            qDebug() << "[Scanner] üîç DEBUG: -- File:" << f.filePath.right(50) << "size:" << f.size << "known=" << f.sizeKnown;
        }

        bool containsUnknown = std::any_of(groupFiles.begin(), groupFiles.end(), [](const FileInfo &fi){ return !fi.sizeKnown; });
        if (groupFiles.size() == 1 && !containsUnknown && groupSize != -1) {
            qDebug() << "[Scanner] ‚ùå Entferne Single-File-Gruppe (size=" << groupSize << ")";
            it = fileSizeGroups.erase(it);
        } else if (groupSize == -1) {
            // Placeholder: we don't prune unknown-size singletons yet
            ++it;
        } else {
            qDebug() << "[Scanner] ‚úÖ Behalte Gruppe (size=" << groupSize << ") mit" << groupFiles.size() << "Dateien" << (containsUnknown ? "(enth√§lt unbekannte Gr√∂√üen)" : "");
            ++it;
        }
    }
    
    qDebug() << "[Scanner] üìä Size-Groups nach Filterung:" << fileSizeGroups.size() << "Gruppen mit potentiellen Duplikaten";
    
    // üìä UNIKAT-STATISTIK: Berechne wie viele Dateien als Unikate aussortiert wurden
    int totalDuplicateCandidates = 0;
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        totalDuplicateCandidates += groupIt.value().size();
    }
    int uniqueFilesFiltered = totalFilesFound - totalDuplicateCandidates;
    qDebug() << "[Scanner] ‚úÖ UNIKAT-FILTER STATISTIK:";
    qDebug() << "    - Gesamte Dateien gefunden:" << totalFilesFound;
    qDebug() << "    - Duplikat-Kandidaten (gleiche Gr√∂√üe):" << totalDuplicateCandidates;
    qDebug() << "    - Als Unikate aussortiert:" << uniqueFilesFiltered;
    
    std::cout << "üîç Unikat-Filter: " << uniqueFilesFiltered << " einzigartige Dateien √ºbersprungen, " 
              << totalDuplicateCandidates << " Duplikat-Kandidaten verbleiben" << std::endl;
    
    // üéØ GUI-FIX: Size-Filtering abgeschlossen - Zeige Ergebnis in GUI
    if (fileSizeGroups.isEmpty()) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine identischen Gr√∂√üen gefunden - pr√ºfe Dateinamen-√Ñhnlichkeiten...";
        
        // üî• ENHANCED FALLBACK: Check for name-based potential duplicates
        QMap<QString, QList<FileInfo>> nameGroups;
        
        // Group files by similar base names (ignore extensions and numbers)
        for (const FileInfo &file : allFiles) {
            QString fileName = QFileInfo(file.filePath).baseName().toLower();
            
            // Remove common duplicate indicators and numbers
            fileName = fileName.replace(QRegularExpression(R"(\s*\(kopie\s*\d*\))", QRegularExpression::CaseInsensitiveOption), "");
            fileName = fileName.replace(QRegularExpression(R"(\s*\(copy\s*\d*\))", QRegularExpression::CaseInsensitiveOption), "");
            fileName = fileName.replace(QRegularExpression(R"(\s*-\s*kopie\s*\d*)", QRegularExpression::CaseInsensitiveOption), "");
            fileName = fileName.replace(QRegularExpression(R"(\s*_\d+$)"), ""); // Remove trailing numbers
            fileName = fileName.replace(QRegularExpression(R"(\s+)"), " ").trimmed(); // Normalize spaces
            
            if (!fileName.isEmpty()) {
                nameGroups[fileName].append(file);
            }
        }
        
        // Check if any name groups have multiple files and add them to size groups
        bool foundNameSimilarities = false;
        int nameGroupIndex = 1000000; // Use high numbers to avoid conflicts
        
        for (auto it = nameGroups.begin(); it != nameGroups.end(); ++it) {
            if (it.value().size() > 1) {
                qDebug() << "[Scanner] üîç Dateiname-Gruppe gefunden:" << it.key() 
                         << "mit" << it.value().size() << "√§hnlichen Dateien";
                
                // Add each group as a separate "size group" for hash comparison
                fileSizeGroups[nameGroupIndex++] = it.value();
                foundNameSimilarities = true;
            }
        }
        
        if (!foundNameSimilarities) {
            // ‚úÖ DEFINITIV keine Duplikate gefunden
            emit scanProgress(100, allFiles.size(), allFiles.size()); // 100% completed
            emit scanStatusChanged("‚úÖ Scan abgeschlossen - Keine Duplikate gefunden (unterschiedliche Gr√∂√üen und Namen)");
            qDebug() << "[Scanner] ‚úÖ SIZE-FILTERING ERFOLGREICH - Keine Duplikate gefunden (normale Situation)";
            
            // üéØ GUI-FIX: Zeige "Scan erfolgreich" statt "0% h√§ngen"
            emit currentFileProcessing(
                "Scan abgeschlossen", 
                "‚úÖ Keine Duplikate - alle Dateien haben unterschiedliche Gr√∂√üen und Namen", 
                allFiles.size(), 
                allFiles.size()
            );
            emit processActivityUpdate(
                "‚úÖ Duplikat-Scan erfolgreich abgeschlossen",
                QString("Analysiert: %1 Dateien - Gefunden: 0 Duplikate").arg(allFiles.size())
            );
            
            // Direkt zu scanCompleted() wechseln, da keine Hash-Berechnung n√∂tig
            DuplicateGroups emptyResults;
            emptyResults.totalFiles = allFiles.size(); // Bei 0 Duplikaten: alle Dateien sind Unikate
            emptyResults.duplicateFiles = 0;
            emit scanCompleted(emptyResults);
            return;
        } else {
            qDebug() << "[Scanner] üîç √Ñhnliche Dateinamen gefunden - starte Hash-Vergleich...";
            emit scanStatusChanged("üîç √Ñhnliche Dateinamen gefunden - starte Hash-Vergleich...");
        }
    } else {
        // Duplikate gefunden - Weiter zu Hash-Berechnung
        emit scanProgress(50, fileSizeGroups.size(), allFiles.size()); // 50% f√ºr Hash-Phase
        emit scanStatusChanged(QString("üîê Starte Hash-Berechnung f√ºr %1 Duplikat-Gruppen...").arg(fileSizeGroups.size()));
    }

    // üîé Optional: Deep debug per size-group when FILEDUPER_DEBUG_GROUPS=1
    static const bool debugGroups = qEnvironmentVariableIsSet("FILEDUPER_DEBUG_GROUPS") && (qgetenv("FILEDUPER_DEBUG_GROUPS") == "1");
    if (debugGroups) {
        int groupIndex = 0;
        for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ++it) {
            const qint64 sizeKey = it.key();
            const QList<FileInfo> &files = it.value();
            int localCount = 0, ftpCount = 0;
            for (const FileInfo &f : files) {
                if (f.isLocal) localCount++; else if (f.filePath.startsWith("ftp://")) ftpCount++;
            }
            qDebug() << "[Scanner] üîé Gruppe" << (++groupIndex) << ": size=" << sizeKey
                     << " files=" << files.size() << " local=" << localCount << " ftp=" << ftpCount;
        }
    }

    int potentialDuplicates = 0;
    for (const auto &group : fileSizeGroups)
    {
        potentialDuplicates += group.size();
    }

    qDebug() << "[Scanner] üìä" << potentialDuplicates << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    std::cout << "üìä " << potentialDuplicates << " Dateien zur Hash-Berechnung hinzugef√ºgt" << std::endl;

    // Phase 3: Wait for FTP completion BEFORE starting hashing
    if (ftpScanningActive.load() || activeFtpScans.load() > 0) {
        qDebug() << "[Scanner] ‚è≥ FTP-Scanner noch aktiv - warte vor startHashing(). FTP-Active:" << ftpScanningActive.load() << "Active-Scans:" << activeFtpScans.load();
        QTimer::singleShot(2000, this, &Scanner::filterBySize); // Retry filterBySize in 2 seconds
        return;
    }

    qDebug() << "[Scanner] üî• filterBySize() ABGESCHLOSSEN - Rufe startHashing() auf mit" << allFiles.size() << "Dateien (inkl. FTP)";
    // If there are unresolved unknown sizes, we can later implement async resolution before hashing
    startHashing();
}

void Scanner::startHashing()
{
    qDebug() << "[Scanner] startHashing() aufgerufen";
    qDebug() << "[Scanner] scanning.load():" << scanning.load();
    qDebug() << "[Scanner] enginePool.size():" << enginePool.size();
    qDebug() << "[Scanner] allFiles.size():" << allFiles.size();
    
    if (!scanning.load() || enginePool.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå startHashing() - Fr√ºher Return: scanning=" << scanning.load() << ", engines=" << enginePool.size();
        return;
    }

    qDebug() << "[Scanner] ‚úÖ startHashing() - Starte 8-Engine Parallel Processing";
    
    // Reset per-scan counters
    hashProcessedCount = 0;
    processedFilesCounter.store(0);
    completedEngines.store(0);
    currentFileIndex = 0;
    activeEngines = 0;
    
    emit scanStatusChanged("Berechne Hashes mit 8 Engines...");
    currentPhase = HASHING;
    
    // ‚úÖ FTP-Credentials aus INI-Datei laden f√ºr alle Engines
    if (presetManager) {
        QSet<QString> ftpHosts;
        for (const FileInfo &file : allFiles) {
            if (file.filePath.startsWith("ftp://")) {
                QUrl url(file.filePath);
                if (url.isValid()) {
                    QString host = url.host();
                    if (!host.isEmpty()) {
                        ftpHosts.insert(host);
                    }
                }
            }
        }
        
        // Setup FTP connection pools for multiple hosts
        if (!ftpHosts.isEmpty()) {
            qDebug() << "[Scanner] ‚ö° FAST-MODE: √úberspringe FTP Connection Pool Setup f√ºr bessere Performance";
            qDebug() << "[Scanner] üí° FTP-Credentials werden direkt von Engines abgerufen bei Bedarf";
            // setupMultiHostFtpConnectionPool(ftpHosts); // DEAKTIVIERT f√ºr bessere Performance
        }
        
        // Load credentials for each engine
        for (const QString &host : ftpHosts) {
            LoginData login = presetManager->getLogin(host, 21);  
            if (login.isValid()) {
                // Set credentials for all engines
                for (HashEngine *engine : enginePool) {
                    if (engine) {
                        engine->setFtpCredentials(host, login.username, login.password);
                    }
                }
                qDebug() << "[Scanner] üîê 8-Engine FTP-Credentials geladen f√ºr:" << host << "User:" << login.username;
            } else {
                qWarning() << "[Scanner] ‚ö†Ô∏è Keine FTP-Credentials in INI-Datei gefunden f√ºr:" << host;
                qWarning() << "[Scanner] üí° Bitte FTP-Credentials in Settings speichern f√ºr Host:" << host;
            }
        }
    }
    
    // ÔøΩ OPTIMIZED: Use only files from optimized size+date groups instead of ALL files
    QMap<QString, QList<FileInfo>> dateSizeGroups;
    
    // üõ°Ô∏è UNIKAT-SCHUTZ: Nur Dateien mit identischen Gr√∂√üen k√∂nnen echte Duplikate sein
    for (auto &sizeGroup : fileSizeGroups)
    {
        // ‚úÖ KRITISCHER FIX: √úberspringe Dateien mit einzigartigen Gr√∂√üen (UNIKATE!)
        if (sizeGroup.size() <= 1) {
            qDebug() << "[Scanner] ‚úÖ UNIKAT √ºbersprungen (einzigartige Gr√∂√üe):" << sizeGroup.first().filePath;
            continue; // üö´ Keine Hash-Berechnung f√ºr garantierte Unikate erforderlich
        }
        qDebug() << "[Scanner] üîç Duplikat-Kandidaten (gleiche Gr√∂√üe):" << sizeGroup.size() << "Dateien";
        
        bool hasNetworkFiles = false;
        // Check if group contains network files (FTP/SFTP etc.)
        for (const FileInfo &file : sizeGroup) {
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://")) {
                hasNetworkFiles = true;
                break;
            }
        }
        
        if (hasNetworkFiles) {
            // For network files: Skip date filtering (unreliable timestamps)
            QString sizeOnlyKey = QString("size_%1").arg(sizeGroup.first().size);
            dateSizeGroups[sizeOnlyKey] = sizeGroup;
            qDebug() << "[Scanner] üì° Network-Gruppe (nur Size-Filter):" << sizeGroup.size() << "Dateien";
        } else {
            // For local files: Use size+date filtering for better optimization  
            QMap<QString, QList<FileInfo>> dateSubGroups;
            for (const FileInfo &file : sizeGroup) {
                QDateTime dateTime = QDateTime::fromSecsSinceEpoch(file.lastModified);
                QString dateKey = QString("%1_%2").arg(dateTime.toString("yyyy-MM-dd")).arg(file.size);
                dateSubGroups[dateKey].append(file);
            }
            
            // ‚úÖ FIX: Keep ALL files in date groups - size filtering already happened
            // Files with same size but different dates could still be duplicates
            for (auto dateIt = dateSubGroups.begin(); dateIt != dateSubGroups.end(); ++dateIt) {
                dateSizeGroups[dateIt.key()] = dateIt.value();
            }
            qDebug() << "[Scanner] üìÅ Lokale Gruppe (Size+Date-Filter):" << dateSubGroups.size() << "Untergruppen";
        }
    }
    
    // Add optimized files to hash calculation
    QSet<QString> processedForHashing; // üõ°Ô∏è SCHUTZ: Verhindere doppelte Hash-Berechnung
    for (const auto &group : dateSizeGroups)
    {
        for (const FileInfo &file : group) {
            // üõ°Ô∏è CRITICAL FIX: Pr√ºfe ob Datei bereits zur Hash-Berechnung hinzugef√ºgt wurde
            QString canonicalPath;
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://") || 
                file.filePath.startsWith("smb://")) {
                // F√ºr Netzwerk-URLs: Verwende den Pfad direkt ohne canonicalFilePath()
                canonicalPath = file.filePath;
            } else {
                // F√ºr lokale Dateien: Verwende canonicalFilePath()
                canonicalPath = QFileInfo(file.filePath).canonicalFilePath();
                // üõ°Ô∏è ZUS√ÑTZLICHER SCHUTZ: Leere/ung√ºltige Pfade √ºberspringen
                if (canonicalPath.isEmpty()) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger canonicalPath f√ºr:" << file.filePath;
                    continue;
                }
            }
            
            // üõ°Ô∏è CRITICAL SECURITY: Auch globalHashedFiles pr√ºfen um Infinite-Loop zu verhindern
            if (processedForHashing.contains(canonicalPath) || globalHashedFiles.contains(canonicalPath)) {
                qDebug() << "[Scanner] ‚ö†Ô∏è Datei bereits f√ºr Hashing vorgemerkt/verarbeitet (√ºbersprungen):" << file.filePath.right(50);
                continue;
            }
            processedForHashing.insert(canonicalPath);
            // ‚úÖ FIX: F√ºge Datei NICHT vorab zu globalHashedFiles hinzu - erst wenn Hash empfangen!
            // Note: In 8-engine system, we work directly with allFiles
        }
    }

    qDebug() << "[Scanner] üîç Starte INTELLIGENTE Hash-Berechnung f√ºr" << allFiles.size() << "Duplikat-Kandidaten";
    qDebug() << "[Scanner] ‚úÖ Unikate bereits aussortiert - nur echte Duplikat-Kandidaten verarbeitet";
    
    // Handle case when ALL files are unique (nach Gr√∂√üen-Filterung)
    if (allFiles.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ ALLE Dateien sind UNIKATE (verschiedene Gr√∂√üen) - keine Hash-Berechnung erforderlich!";
        emit scanStatusChanged("‚úÖ Alle Dateien sind einzigartig - keine Duplikate gefunden!");
        
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = totalFilesFound; // Zeige echte Gesamtzahl
        emptyResults.duplicateFiles = 0;
        emptyResults.duplicateSize = 0;
        
        QTimer::singleShot(500, this, [this, emptyResults]() {
            emit scanCompleted(emptyResults);
        });
        return;
    }

    qDebug() << "[Scanner] üîç Starte Hash-Berechnung f√ºr" << allFiles.size() << "Dateien";
    qDebug() << "[Scanner] üìä" << allFiles.size() << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    
    // ‚ö° ERWEITERTER TIMEOUT-SCHUTZ: Gib HashEngine mehr Zeit f√ºr Duplikat-Erkennung
    // Starte abbrechbaren Timeout nur wenn mehr als 0 Dateien zu hashen sind
    if (!allFiles.isEmpty()) {
        hashTimeoutTimer->start(300000); // 300s (5 Minuten) - mehr Zeit f√ºr compareHashes()
    }
    
    // ÔøΩüöÄüß† Optional: NPU-FIRST BILDVERARBEITUNG: Separiere Bilder BEVOR Hash-Berechnung beginnt!
    QStringList imageFiles;
    QStringList nonImageFiles;
    
    // ‚úÖ BILDFILES vs. NORMAL FILES separieren
    for (const FileInfo &file : allFiles) {
        QString filePath = file.filePath;
        QString lowerExt = QFileInfo(filePath).suffix().toLower();
        if (lowerExt == "jpg" || lowerExt == "jpeg" || lowerExt == "png" || lowerExt == "bmp" || 
            lowerExt == "tiff" || lowerExt == "tif" || lowerExt == "cr2" || lowerExt == "raw" ||
            lowerExt == "nef" || lowerExt == "arw" || lowerExt == "dng" || lowerExt == "webp") {
            imageFiles.append(filePath);
        } else {
            nonImageFiles.append(filePath);
        }
    }
    
    qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "| Non-Images:" << nonImageFiles.size();
    
    // üß† NPU-BILDVERARBEITUNG: Parallel zur Hash-Pipeline (immer zus√§tzlich, niemals als Ersatz)
    if (npuEnabled && hashEngine && hashEngine->isNpuAvailable() && !imageFiles.isEmpty()) {
        qDebug() << "[Scanner] üöÄ NPU Bildanalyse startet parallel f√ºr" << imageFiles.size() << "Bilder (Hash bleibt aktiv)!";
        emit scanStatusChanged("üß† NPU analysiert Bilder (parallel zur Hash-Berechnung)...");

        // üìä LIVE-Update: NPU-Bildverarbeitung starten
        emit currentFileProcessing(
            QString("%1 Bilder").arg(imageFiles.size()),
            "üß† NPU-Bildverarbeitung (parallel)",
            0,
            imageFiles.size()
        );
        emit processActivityUpdate(
            "üß† Intel NPU analysiert Bilder f√ºr intelligente Duplikat-Erkennung",
            QString("Verarbeite %1 Bilder").arg(imageFiles.size())
        );

        // NPU Feature-Vector Processing f√ºr Bilder (zus√§tzlich; ersetzt NICHT den Content-Hash)
        hashEngine->processImagesWithNpuUltraFast(imageFiles);
        npuProcessedImages = imageFiles.size();

        // üìä FINAL-Update: NPU-Bildverarbeitung abgeschlossen
        emit currentFileProcessing(
            QString("%1 Features extrahiert").arg(npuProcessedImages),
            "üß† NPU-Bildverarbeitung abgeschlossen (parallel)",
            npuProcessedImages,
            imageFiles.size()
        );
        emit processActivityUpdate(
            QString("üß† NPU hat %1 Bilder analysiert (Content-Hash l√§uft weiter)").arg(npuProcessedImages),
            "Intelligente Bildanalyse abgeschlossen"
        );
    }
    
    // Hinweis: Bilder werden weiterhin gehasht, auch wenn NPU parallel lief
    if (npuEnabled && npuProcessedImages > 0) {
        qDebug() << "[Scanner] üß† NPU hat" << npuProcessedImages << "Bilder analysiert (Content-Hashes folgen wie gewohnt)";
    }
    
    // Hash-Berechnung f√ºr alle Dateien (auch Bilder). NPU-Ergebnisse sind zus√§tzlich verf√ºgbar.
    if (!allFiles.isEmpty()) {
        totalFilesForHashing = allFiles.size(); // üéØ Setze Gesamt-Anzahl f√ºr Live-Updates
        
        // üìä LIVE-Update: Hash-Berechnung starten
        emit currentFileProcessing(
            QString("%1 Dateien").arg(allFiles.size()), 
            "üîê Hash-Berechnung", 
            0, 
            allFiles.size()
        );
        emit processActivityUpdate(
            "üîê Berechne kryptographische Hashes f√ºr Duplikat-Erkennung",
            QString("Verarbeite %1 Dateien").arg(allFiles.size())
        );
        
        emit hashingStarted(allFiles.size());
        
        // ‚úÖ 8-ENGINE SYSTEM: Set total files for all engines
        totalFilesForHashing = allFiles.size();
        
        // Create balanced chunks for 8 engines directly from allFiles
        QList<QList<FileInfo>> fileChunks = createBalancedFileChunks(allFiles, maxEngines);
        
        qDebug() << "[Scanner] ÔøΩ CRITICAL: Starte 8-Engine Parallel Processing mit" << fileChunks.size() << "Chunks";
        
        // Start processing with each engine
        for (int i = 0; i < fileChunks.size() && i < enginePool.size(); ++i) {
            if (!fileChunks[i].isEmpty() && i < enginePool.size()) {
                HashEngine *engine = enginePool[i];
                if (engine) {
                    // Convert FileInfo back to file paths
                    QStringList chunkPaths;
                    for (const FileInfo &file : fileChunks[i]) {
                        chunkPaths.append(file.filePath);
                    }
                    
                    qDebug() << "[Scanner] ÔøΩ Engine" << (i+1) << "startet mit" << chunkPaths.size() << "Dateien";
                    
                    // Set expected count for this engine
                    engine->setExpectedFilesCount(chunkPaths.size());
                    
                    // Start engine
                    engine->calculateMultipleHashes(chunkPaths);
                    activeEngines++;
                }
            }
        }
        
        qDebug() << "[Scanner] ‚úÖ 8-Engine System gestartet -" << activeEngines << "aktive Engines";
        
        if (activeEngines == 0) {
            qWarning() << "[Scanner] ‚ö†Ô∏è Keine Engines gestartet - Fallback zu Vergleich";
            QTimer::singleShot(500, this, &Scanner::compareHashes);
        }
    } else {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine Dateien f√ºr die Hash-Berechnung ermittelt (leer)";
        emit scanStatusChanged("‚ö†Ô∏è Keine Dateien zum Hashen gefunden");
        QTimer::singleShot(500, this, &Scanner::compareHashes);
    }
}

void Scanner::onHashCalculated(const QString &filePath, const QString &hash)
{
    qDebug() << "[Scanner] üö® onHashCalculated CALLED for:" << QFileInfo(filePath).fileName() << "hash:" << hash.left(10);
    
    if (!scanning.load())
        return;

    // üéØ LIVE-DATEINAME-UPDATE: Zeige aktuell verarbeitete Datei in GUI
    QString fileName = QFileInfo(filePath).fileName();
    QString processType = "Hash-Berechnung";
    const bool isNpuHash = hash.startsWith("npv_");
    
    // Unterscheide zwischen NPU und Standard-Hash
    if (isNpuHash) {
        processType = "NPU-Bildanalyse";
    } else if (hash.startsWith("md5_")) {
        processType = "MD5-Hash";
    } else if (hash.startsWith("sha256_")) {
        processType = "SHA256-Hash";
    }
    
    // Ô∏è SICHERUNG: Verhindere Doppelbearbeitung bereits berechneter Hashes
    // WICHTIG: NPU-Hashes (npv_*) sind zus√§tzlich und d√ºrfen den Content-Hash NICHT ersetzen.
    // Daher markieren wir Dateien nur als gehasht, wenn es sich NICHT um einen NPU-Hash handelt.
    // Ô∏è DISABLED: Threading issue - globalHashedFiles.contains() blocks after 6 callbacks
    // if (globalHashedFiles.contains(filePath)) {
    //     if (isNpuHash) {
    //         qDebug() << "[Scanner] ‚ÑπÔ∏è NPU-Zusatzhash ignoriert f√ºr bereits verarbeitete Datei:" << filePath.right(50);
    //         return; // Zusatzinfo, Content-Hash bleibt ma√ügeblich
    //     } else {
    //         qDebug() << "[Scanner] ‚ö†Ô∏è Content-Hash bereits registriert f√ºr:" << filePath.right(50);
    //         return;
    //     }
    // }
    
    // üö® MEMORY PROTECTION: Prevent QSet overflow crash
    if (globalHashedFiles.size() > 20000) {
        qWarning() << "[Scanner] üö® QSet zu gro√ü (" << globalHashedFiles.size() << ") - leere Cache f√ºr Stabilit√§t";
        globalHashedFiles.clear();
        globalProcessedFiles.clear();
    }
    
    // Nur Content-Hashes z√§hlen f√ºr den Abschluss/Progress
    if (!isNpuHash) {
        qDebug() << "[Scanner] üö® DEBUG: About to insert into globalHashedFiles:" << QFileInfo(filePath).fileName() << "size:" << globalHashedFiles.size();
        // DISABLED: Threading issue with QSet operations
        // globalHashedFiles.insert(filePath);
        qDebug() << "[Scanner] üö® DEBUG: QSet operation skipped (threading fix)";
    }

    qDebug() << "[Scanner] üö® DEBUG: About to calculate progress for:" << QFileInfo(filePath).fileName();

    // üìä MEMBER-COUNTER: Verwende member hashProcessedCount statt statischem Counter
    if (!isNpuHash) {
        hashProcessedCount++;
    }
    int currentHashCount = hashProcessedCount;
    
    qDebug() << "[Scanner] üö® DEBUG: currentHashCount:" << currentHashCount << "totalFilesForHashing:" << totalFilesForHashing;
    
    // üõ°Ô∏è SAFE DIVISION: Prevent division by zero or overflow
    int progressPercent = 0;
    if (totalFilesForHashing > 0 && currentHashCount >= 0) {
        progressPercent = qMin(100, (currentHashCount * 100) / totalFilesForHashing);
    }
    
    qDebug() << "[Scanner] üö® DEBUG: progressPercent calculated:" << progressPercent;
    
    qDebug() << "[Scanner] üö® DEBUG: About to emit signals for:" << QFileInfo(filePath).fileName();
    
    // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI mit korrekten Z√§hlern
    emit currentFileProcessing(fileName, processType, currentHashCount, totalFilesForHashing);
    qDebug() << "[Scanner] üö® DEBUG: currentFileProcessing emitted";
    
    emit processActivityUpdate(processType, QString("Verarbeite: %1 (%2/%3)").arg(fileName).arg(currentHashCount).arg(totalFilesForHashing));
    qDebug() << "[Scanner] üö® DEBUG: processActivityUpdate emitted";
    
    emit scanProgress(progressPercent, currentHashCount, totalFilesForHashing);
    qDebug() << "[Scanner] üö® DEBUG: scanProgress emitted";

    qDebug() << "[Scanner] üìä Hash berechnet f√ºr:" << filePath.right(50) << "‚Üí" << hash.left(16) << QString("(%1/%2)").arg(currentHashCount).arg(totalFilesForHashing);

    // ‚úÖ FIX: Update hash in fileSizeGroups (nicht allFiles - das ist nur eine Kopie)
    bool hashUpdated = false;
    for (auto &group : fileSizeGroups)
    {
        for (FileInfo &file : group)
        {
            // üö® CRITICAL FIX: FTP-Pfad-Matching - verschiedene Varianten pr√ºfen
            bool pathMatches = false;
            if (file.filePath == filePath) {
                pathMatches = true;
            } else if (file.filePath.startsWith("ftp://") && filePath.startsWith("ftp://")) {
                // FTP-URLs k√∂nnen unterschiedlich normalisiert sein
                QUrl fileUrl(file.filePath);
                QUrl hashUrl(filePath);
                if (fileUrl.host() == hashUrl.host() && 
                    fileUrl.port() == hashUrl.port() && 
                    fileUrl.path() == hashUrl.path()) {
                    pathMatches = true;
                }
            } else if (file.filePath.endsWith(QFileInfo(filePath).fileName()) && 
                       filePath.endsWith(QFileInfo(file.filePath).fileName())) {
                // Filename-basiertes Matching als Fallback
                pathMatches = true;
            }
            
            if (pathMatches)
            {
                qDebug() << "[Scanner] üéØ HASH-UPDATE f√ºr:" << file.filePath.right(50) << "‚Üí" << hash.left(16);
                
                // üõ°Ô∏è NPU-Hashes nicht als Content-Hash speichern
                if (isNpuHash) {
                    continue; // Lass Content-Hash unber√ºhrt
                }
                // üõ°Ô∏è ZUS√ÑTZLICHE SICHERUNG: Verhindere Hash-√úberschreibung (au√üer wenn vorher leer)
                if (!file.hash.isEmpty() && file.hash != hash) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Hash-Konflikt f√ºr" << filePath.right(50) 
                              << "- Alt:" << file.hash.left(16) << "Neu:" << hash.left(16);
                }
                file.hash = hash;
                
                // ‚úÖ CRITICAL FIX: Sammle Hash zentral f√ºr Duplikat-Erkennung
                if (!isNpuHash && !hash.isEmpty()) {
                    qDebug() << "[Scanner] üéØ ZENTRALE HASH-SAMMLUNG: F√ºge zu allFiles hinzu:" << file.fileName << "hash:" << hash.left(16);
                    
                    // Sammle alle gehashten Dateien zentral f√ºr compareHashes()
                    bool alreadyInAllFiles = false;
                    for (const FileInfo &existingFile : allFiles) {
                        if (existingFile.filePath == file.filePath) {
                            alreadyInAllFiles = true;
                            break;
                        }
                    }
                    
                    if (!alreadyInAllFiles) {
                        allFiles.append(file);
                        qDebug() << "[Scanner] üéØ HASH-SAMMLUNG: File hinzugef√ºgt zu allFiles. Total:" << allFiles.size();
                    } else {
                        // Update existing entry
                        for (FileInfo &existingFile : allFiles) {
                            if (existingFile.filePath == file.filePath) {
                                existingFile.hash = hash;
                                qDebug() << "[Scanner] üéØ HASH-UPDATE: Hash aktualisiert in allFiles f√ºr:" << file.fileName;
                                break;
                            }
                        }
                    }
                }
                
                // ‚úÖ CRITICAL FIX: Ensure fileName is properly set for FTP files
                if (file.fileName.isEmpty() && !file.filePath.isEmpty()) {
                    if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://") || 
                        file.filePath.startsWith("smb://")) {
                        // For FTP URLs, extract filename from URL path
                        QUrl url(file.filePath);
                        QString path = url.path();
                        file.fileName = QFileInfo(path).fileName();
                        qDebug() << "[Scanner] üõ†Ô∏è FTP fileName gesetzt:" << file.fileName << "f√ºr" << file.filePath.right(50);
                    } else {
                        // For local files, use QFileInfo
                        file.fileName = QFileInfo(file.filePath).fileName();
                        qDebug() << "[Scanner] üõ†Ô∏è Lokaler fileName gesetzt:" << file.fileName;
                    }
                }
                
                hashUpdated = true;
                break;
            }
        }
        if (hashUpdated) break;
    }

    // ‚ö° ULTRA-LIGHTWEIGHT: Skip heavy fileSizeGroups iteration (threading fix)
    int totalFilesInGroups = totalFilesForHashing;
    int hashedFilesInGroups = currentHashCount;
    
    qDebug() << "[Scanner] üö® LIGHTWEIGHT-PROGRESS: " << hashedFilesInGroups << "/" << totalFilesInGroups << "(threading-optimized)";
    
    // ‚úÖ BULLETPROOF: Division-by-Zero Protection + Progress Fix
    int percentage = 0;
    if (totalFilesInGroups > 0 && hashedFilesInGroups >= 0) {
        qDebug() << "[Scanner] üîß DIVISION-DEBUG: hashedFiles=" << hashedFilesInGroups 
                 << "totalFiles=" << totalFilesInGroups << "vor Division";
        
        // ‚úÖ FIX: Robust progress calculation with bounds checking
        if (hashedFilesInGroups >= totalFilesInGroups) {
            percentage = 100; // Completion reached
            qDebug() << "[Scanner] üîß COMPLETION: 100% erreicht";
        } else if (hashedFilesInGroups > INT_MAX / 100) {
            percentage = (int)((long long)hashedFilesInGroups * 100 / totalFilesInGroups);
            qDebug() << "[Scanner] üîß OVERFLOW-PROTECTION: LongLong-Division verwendet";
        } else {
            percentage = (hashedFilesInGroups * 100) / totalFilesInGroups;
            qDebug() << "[Scanner] üîß NORMAL-DIVISION: Standard-Division verwendet";
        }
        percentage = qMax(0, qMin(100, percentage)); // Clamp 0-100%
        qDebug() << "[Scanner] üîß RESULT-PERCENTAGE:" << percentage << "%";
    } else {
        qDebug() << "[Scanner] üö® ZERO-DIVISION-AVOIDED: totalFilesInGroups=" << totalFilesInGroups << ", hashedFilesInGroups=" << hashedFilesInGroups;
        percentage = 0;
    }
    
    // ‚ö° OPTIMIERTES PROGRESS THROTTLING: Intelligente Update-Kontrolle
    static int lastEmittedPercentage = -1;
    static qint64 lastEmitTime = 0;
    static int rapidUpdateCount = 0;
    
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();
    bool shouldEmitProgress = false;
    
    // Adaptive Throttling: Weniger Updates bei schnellen √Ñnderungen
    int timeDelta = currentTime - lastEmitTime;
    int percentageDelta = abs(percentage - lastEmittedPercentage);
    
    if (percentageDelta >= 1) {
        if (timeDelta >= 100) { // Minimum 100ms zwischen Updates
            shouldEmitProgress = true;
            rapidUpdateCount = 0;
        } else {
            rapidUpdateCount++;
            // Nur jeder 5. Update bei schnellen √Ñnderungen
            if (rapidUpdateCount >= 5) {
                shouldEmitProgress = true;
                rapidUpdateCount = 0;
            }
        }
    }
    
    // Kritische Meilensteine: 0%, 25%, 50%, 75%, 100% - IMMER emittieren
    if (percentage == 0 || percentage == 25 || percentage == 50 || 
        percentage == 75 || percentage == 100 || timeDelta >= 1000) {
        shouldEmitProgress = true;
        qDebug() << "[Scanner] üö® CRITICAL MILESTONE:" << percentage << "% - hashedFilesInGroups:" << hashedFilesInGroups << "totalFilesInGroups:" << totalFilesInGroups;
    }
    
    if (shouldEmitProgress) {
        emit scanProgress(percentage, hashedFilesInGroups, totalFilesInGroups);
        qDebug() << "[Scanner] üìä Hash-Progress (Optimized):" << hashedFilesInGroups 
                 << "/" << totalFilesInGroups << "(" << percentage << "%) Œît:" << (currentTime - lastEmitTime) << "ms";
        lastEmittedPercentage = percentage;
        lastEmitTime = currentTime;
    }
    
    
    // ‚úÖ SMARTE ANTI-HANG: Adaptive Stagnation Detection mit Time-based Checks
    static int lastPercentage = -1;
    static int stagnationCount = 0;
    static qint64 stagnationStartTime = 0;
    
    if (percentage == lastPercentage && percentage > 0) {
        if (stagnationCount == 0) {
            stagnationStartTime = currentTime; // Erste Stagnation markieren
        }
        stagnationCount++;
        
        // Progressive Timeouts: 5s bei 0-50%, 10s bei 50-90%, 15s bei 90-100%
        int timeoutMs = (percentage < 50) ? 5000 : (percentage < 90) ? 10000 : 15000;
        qint64 stagnationDuration = currentTime - stagnationStartTime;
        
        if (stagnationDuration >= timeoutMs && stagnationCount >= 3) {
            qWarning() << "[Scanner] üö® Progress-Stagnation:" << percentage 
                      << "% f√ºr" << stagnationDuration << "ms ‚Üí Smart Force Complete!";
            
            // ‚ö° INTELLIGENTE FORCE COMPLETION: Graduelle Steigerung
            int forcePercentage = qMin(100, percentage + 20); // +20% pro Force-Step
            emit scanProgress(forcePercentage, hashedFilesInGroups, totalFilesInGroups);
            
            if (forcePercentage >= 100) {
                // Erstelle minimale Results f√ºr Completion
                DuplicateGroups intelligentResults = buildPartialResults();
                emit scanCompleted(intelligentResults);
                return;
            }
            stagnationCount = 0; // Reset f√ºr n√§chsten Force-Step
        }
    } else {
        lastPercentage = percentage;
        stagnationCount = 0; // Reset bei Progress-√Ñnderung
        stagnationStartTime = 0;
    }
    
    // Check if all hashes are calculated (exclude FTP_SKIPPED files)
    bool allHashesReady = (hashProcessedCount >= totalFilesForHashing && totalFilesForHashing > 0);
    
    // ‚úÖ THREADING-FIX: Only trigger compareHashes when ALL hashes are ready (not 50%)
    bool forceComplete = false; // Disable force completion to prevent early compareHashes
    
    if (allHashesReady || forceComplete)
    {
        if (hashTimeoutTimer && hashTimeoutTimer->isActive()) {
            hashTimeoutTimer->stop();
            qDebug() << "[Scanner] ‚è±Ô∏è Hash-Timeout-Timer gestoppt (alle Hashes fertig)";
        }
        if (forceComplete && !allHashesReady) {
            qDebug() << "[Scanner] ‚ö†Ô∏è TIMEOUT-SCHUTZ: Erzwinge Completion mit" << hashedFilesInGroups << "/" << totalFilesInGroups << "Dateien (85%+)";
        } else {
            qDebug() << "[Scanner] ‚úÖ Alle Hashes berechnet, starte Vergleich";
        }
        compareHashes();
        return; // ensure no further processing in this callback after comparison triggered
    }
    
    qDebug() << "[Scanner] üö® onHashCalculated END for:" << QFileInfo(filePath).fileName();
}

void Scanner::compareHashes()
{
    if (!scanning.load())
        return;

    // üö® KRITISCHER FIX: Warte bis FTP-Scanner komplett abgeschlossen sind
    if (ftpScanningActive.load()) {
        qDebug() << "[Scanner] ‚è≥ FTP-Scanner noch aktiv - warte auf Abschluss bevor compareHashes";
        QTimer::singleShot(1000, this, &Scanner::compareHashes); // Retry in 1 second
        return;
    }
    
    // üö® FTP-SAFETY: √úberpr√ºfe ob noch aktive FTP-Scans laufen
    if (activeFtpScans.load() > 0) {
        qDebug() << "[Scanner] ‚è≥ Noch" << activeFtpScans.load() << "aktive FTP-Scans - warte auf Abschluss";
        QTimer::singleShot(1000, this, &Scanner::compareHashes); // Retry in 1 second
        return;
    }

    if (hashTimeoutTimer && hashTimeoutTimer->isActive()) {
        hashTimeoutTimer->stop();
        qDebug() << "[Scanner] ‚è±Ô∏è Hash-Timeout-Timer gestoppt beim Eintritt in compareHashes()";
    }

    qDebug() << "[Scanner] üéØ compareHashes() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();
    qDebug() << "[Scanner] üö® DEBUG: compareHashes() bei 50% Problem - Starte Vergleich";
    
    // üõ°Ô∏è MEMORY PROTECTION: Check for excessive hash groups
    if (hashGroups.size() > 50000) {
        qCritical() << "[Scanner] üö® KRITISCH: Zu viele Hash-Gruppen (" << hashGroups.size() << ") - Memory-Crash Gefahr!";
        DuplicateGroups safeResults;
        safeResults.totalFiles = hashGroups.size();
        safeResults.duplicateFiles = 0;
        safeResults.duplicateSize = 0;
        emit scanCompleted(safeResults);
        return;
    }
    
    if (hashGroups.size() > 30000) {
        qWarning() << "[Scanner] ‚ö†Ô∏è WARNUNG: Sehr viele Hash-Gruppen (" << hashGroups.size() << ") - aktiviere Safe-Mode";
        // Trigger memory cleanup
        QCoreApplication::processEvents();
    }
    
    emit scanStatusChanged("Vergleiche Duplikate (lokal ‚Üî netzwerk)...");
    currentPhase = COMPARING;
    emit comparingStarted();
    
    // üìä LIVE-Update: Duplikat-Vergleich starten
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen").arg(hashGroups.size()), 
        "üîç Duplikat-Vergleich", 
        0, 
        hashGroups.size()
    );
    emit processActivityUpdate(
        "üîç Vergleiche Hashes f√ºr Duplikat-Erkennung",
        QString("Analysiere %1 verschiedene Hash-Gruppen").arg(hashGroups.size())
    );

    // ‚úÖ FIX: Group files by hash from BOTH fileSizeGroups AND allFiles (multi-engine)
    int processedGroups = 0;
    int totalValidHashes = 0;
    int skippedHashes = 0;
    
    qDebug() << "[Scanner] üö® DEBUG: fileSizeGroups.size():" << fileSizeGroups.size();
    qDebug() << "[Scanner] üö® DEBUG: allFiles.size():" << allFiles.size();
    
    // ‚úÖ PHASE 1: Process fileSizeGroups (original logic)
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt)
    {
        qDebug() << "[Scanner] üö® DEBUG: Processing size group" << processedGroups << "with" << groupIt.value().size() << "files";
        if (!scanning.load())
            return;
            
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup)
        {
            if (file.hash.isEmpty()) {
                skippedHashes++;
                continue;
            }
            if (file.hash.startsWith("npv_")) {
                skippedHashes++;
                continue; // NPU-Feature-Hashes sind Zusatzinfos, nicht f√ºr Content-Duplikate
            }
            if (file.hash == "FTP_SKIPPED" || file.hash == "FTP_DOWNLOAD_FAILED") {
                skippedHashes++;
                continue;
            }
            
            hashGroups[file.hash].append(file);
            totalValidHashes++;
        }
        
        processedGroups++;
        // üìä LIVE-Update: Gruppierungs-Fortschritt
        if (processedGroups % 100 == 0) {
            emit currentFileProcessing(
                QString("Gruppe %1").arg(processedGroups), 
                "üîç Hash-Gruppierung", 
                processedGroups, 
                fileSizeGroups.size()
            );
        }
    }
    
    // ‚úÖ PHASE 2: Process allFiles (multi-engine hash results)
    qDebug() << "[Scanner] üéØ MULTI-ENGINE: Verarbeite" << allFiles.size() << "Engine-Hash-Ergebnisse";
    for (const FileInfo &file : allFiles)
    {
        if (!scanning.load())
            return;
            
        if (file.hash.isEmpty()) {
            continue;
        }
        if (file.hash.startsWith("npv_")) {
            continue; // NPU-Feature-Hashes sind Zusatzinfos, nicht f√ºr Content-Duplikate
        }
        if (file.hash == "FTP_SKIPPED" || file.hash == "FTP_DOWNLOAD_FAILED") {
            continue;
        }
        
        // Check if already in hashGroups (avoid duplicates)
        bool alreadyExists = false;
        for (const FileInfo &existingFile : hashGroups[file.hash]) {
            if (existingFile.filePath == file.filePath) {
                alreadyExists = true;
                break;
            }
        }
        
        if (!alreadyExists) {
            hashGroups[file.hash].append(file);
            totalValidHashes++;
            qDebug() << "[Scanner] üéØ MULTI-ENGINE: Hash-Gruppe erweitert:" << file.hash.left(16) << "f√ºr" << file.fileName;
        }
    }
    
    // üìä LIVE-Update: Hash-Gruppierung abgeschlossen
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen erstellt").arg(hashGroups.size()), 
        "üîç Hash-Gruppierung abgeschlossen", 
        fileSizeGroups.size(), 
        fileSizeGroups.size()
    );
    
    // üìä DEBUG: Zeige wichtige Hash-Statistiken
    qDebug() << "[Scanner] üîç HASH-DEBUG:" << hashGroups.size() << "eindeutige Hashes";
    qDebug() << "[Scanner] üìä Verarbeitet:" << totalValidHashes << "g√ºltige Hashes," << skippedHashes << "√ºbersprungen";
    qDebug() << "[Scanner] üö® DEBUG: Starte Duplikat-Gruppierung...";
    
    int duplicateGroups = 0;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateGroups++;
            qDebug() << "[Scanner] üö® DEBUG: Found duplicate group with" << it.value().size() << "files, hash:" << it.key().left(8);
            qDebug() << "[Scanner] üîÑ DUPLIKAT-GRUPPE Hash" << it.key().left(8) << "hat" << it.value().size() << "Dateien:";
            for (const FileInfo &file : it.value()) {
                qDebug() << "    -" << (file.isLocal ? "LOCAL" : "FTP") << file.filePath << "(" << file.size << "bytes)";
            }
        }
    }
    qDebug() << "[Scanner] üéØ DUPLIKAT-GRUPPEN gefunden:" << duplicateGroups;

    // üì¢ USER-FRIENDLY MESSAGE: Entfernt - wird erst am Ende in generateResults() angezeigt
    // Keine vorzeitige "keine Duplikate" Meldung hier

    // Remove unique hashes
    qDebug() << "[Scanner] üßπ Entferne Unikate: Vor Bereinigung" << hashGroups.size() << "Gruppen";
    auto it = hashGroups.begin();
    int removedUniqueGroups = 0;
    while (it != hashGroups.end())
    {
        if (it.value().size() == 1)
        {
            removedUniqueGroups++;
            it = hashGroups.erase(it);
        }
        else
        {
            ++it;
        }
    }
    qDebug() << "[Scanner] üßπ Nach Bereinigung:" << hashGroups.size() << "Duplikat-Gruppen," << removedUniqueGroups << "Unikate entfernt";

    // ‚úÖ NEU: Statistiken f√ºr lokale vs Netzwerk-Duplikate und Hardware-Updates
    int localOnlyGroups = 0;
    int networkOnlyGroups = 0;
    int crossNetworkGroups = 0;
    int totalComparisons = 0;
    int duplicatesFound = 0;
    int groupsCreated = 0;
    
    // üéØ HARDWARE-MONITORING: Echte Auslastung wird √ºber ActivityIndicator angezeigt.
    // Die fr√ºhere Simulation hier wurde entfernt, um "echte" Darstellung sicherzustellen.
    // Optional kann weiterhin Simulation erzwungen werden mit FILEDUPER_SIMULATE_HW=1 (Debug / Tests).
    bool simulateHw = qEnvironmentVariableIsSet("FILEDUPER_SIMULATE_HW") && (qgetenv("FILEDUPER_SIMULATE_HW") == "1");
    auto getHardwareUsage = [&](int currentComparison, int totalComparisons) {
        if (!simulateHw) {
            // Keine k√ºnstlichen Werte mehr: -1 signalisiert UI, dass externe echte Messung (ActivityIndicator) ma√ügeblich ist
            return std::make_tuple(QString("REAL"), -1, QString("Echte Messung aktiv"));
        }
        // --- SIMULATIONSZWEIG (nur wenn FILEDUPER_SIMULATE_HW=1) ---
        QString processingUnit;
        int utilizationPercent = 0;
        QString currentTask;
        if (totalComparisons > 1000) {
            processingUnit = npuManager ? "NPU (Intel Arc)" : "GPU (OpenCL)";
            utilizationPercent = 70 + (currentComparison % 30);
            currentTask = "Parallele Hash-Vergleiche";
        } else if (totalComparisons > 100) {
            processingUnit = "GPU (OpenCL)";
            utilizationPercent = 40 + (currentComparison % 40);
            currentTask = "Sequentielle Vergleiche";
        } else {
            processingUnit = "CPU (Multi-Core)";
            utilizationPercent = 10 + (currentComparison % 30);
            currentTask = "Standard-Vergleiche";
        }
        return std::make_tuple(processingUnit, utilizationPercent, currentTask);
    };
    
    // Berechne die Gesamtzahl der Vergleiche f√ºr Progress-Updates
    qDebug() << "[Scanner] üö® DEBUG: Starting totalComparisons calculation...";
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        int filesInGroup = it.value().size();
        totalComparisons += (filesInGroup * (filesInGroup - 1)) / 2; // n*(n-1)/2 Vergleiche
        qDebug() << "[Scanner] üö® Group with" << filesInGroup << "files adds" << ((filesInGroup * (filesInGroup - 1)) / 2) << "comparisons";
    }
    
    qDebug() << "[Scanner] üîç Starte" << totalComparisons << "Datei-Vergleiche in" << hashGroups.size() << "Hash-Gruppen";
    
    qDebug() << "[Scanner] üö® DEBUG: About to call getHardwareUsage...";
    // üéØ LIVE-UPDATE: Hardware-Status zu Beginn
    auto [initialUnit, initialPercent, initialTask] = getHardwareUsage(0, totalComparisons);
    qDebug() << "[Scanner] üö® DEBUG: getHardwareUsage returned (simulate=" << simulateHw << ")";
    if (simulateHw) {
        emit hardwareUsageUpdate(initialUnit, initialPercent, QString("Initialisiere %1").arg(initialTask));
    } else {
        emit hardwareUsageUpdate("REAL", -1, "Verwende echte Hardware-Auslastung");
    }
    qDebug() << "[Scanner] üö® DEBUG: hardwareUsageUpdate emitted!";
    
    int currentComparison = 0;
    
    qDebug() << "[Scanner] üö® DEBUG: Starting main hash group loop...";
    
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (!scanning.load()) return;
        
        const QList<FileInfo> &files = it.value();
        
        qDebug() << "[Scanner] üö® Processing hash group with" << files.size() << "files, hash:" << it.key().left(8);
        
        // üõ°Ô∏è CRITICAL PROTECTION: Verhindere Memory-Crash bei zu vielen Vergleichen
        if (files.size() > 100) {
            qWarning() << "[Scanner] üö® GEFAHR: Gruppe mit" << files.size() << "Dateien w√ºrde" << (files.size() * (files.size() - 1) / 2) << "Vergleiche ben√∂tigen!";
            qWarning() << "[Scanner] üõ°Ô∏è PROTECTION: Reduziere auf erste 100 Dateien f√ºr Stabilit√§t";
            
            // Erstelle reduzierte Gruppe f√ºr sicheren Vergleich
            QList<FileInfo> safeFiles = files.mid(0, 100); // Nur erste 100 Dateien
            
            // F√ºge trotzdem eine Duplikat-Gruppe hinzu (erste vs. alle anderen)
            DuplicateGroup largeGroup;
            largeGroup.original = files[0];
            largeGroup.hash = it.key();
            largeGroup.size = files[0].size;
            for (int k = 1; k < qMin(files.size(), 50); k++) { // Max 50 Duplikate
                largeGroup.duplicates.append(files[k]);
            }
            
            // Direkt zur generateResults-Datenstruktur hinzuf√ºgen
            // (Implementation w√ºrde hier die Daten speichern)
            qDebug() << "[Scanner] üõ°Ô∏è Gro√üe Gruppe sicher verarbeitet:" << largeGroup.duplicates.size() << "Duplikate";
            continue; // √úberspringe die normale Verarbeitung
        }
        
        if (files.size() > 1) {
            groupsCreated++;
            
            qDebug() << "[Scanner] üö® Starting nested loops for group" << groupsCreated;
            
            // üõ°Ô∏è MEMORY-PROTECTION: Vergleiche nur bei manageable Gruppengr√∂√üen
            int safeSize = qMin(files.size(), 100); // Maximal 100 Dateien
            int totalComparisons = safeSize * (safeSize - 1) / 2;
            qDebug() << "[Scanner] üîç Vergleiche" << totalComparisons << "Datei-Paare in Gruppe (reduziert von" << files.size() << ")";
            
            // üéØ DETAILLIERTE DATEI-ZU-DATEI-VERGLEICHE MIT PROTECTION
            for (int i = 0; i < safeSize; i++) {
                // üõ°Ô∏è EMERGENCY BREAK: Bei zu vielen Vergleichen abbrechen
                if (i > 50) {
                    qWarning() << "[Scanner] üö® EMERGENCY BREAK: Stoppe bei Index" << i << "f√ºr Speicherschutz";
                    break;
                }
                
                for (int j = i + 1; j < safeSize; j++) {
                    if (!scanning.load()) return;
                    
                    // üõ°Ô∏è MEMORY CHECK: Vergleichsz√§hler
                    if ((i * safeSize + j) > 5000) {
                        qWarning() << "[Scanner] üö® COMPARISON LIMIT: Stoppe nach 5000 Vergleichen";
                        goto next_hash_group; // Springe zur n√§chsten Hash-Gruppe
                    }
                    
                    currentComparison++;
                    const FileInfo &file1 = files[i];
                    const FileInfo &file2 = files[j];
                    
                    qDebug() << "[Scanner] üö® COMPARISON" << currentComparison << ":" << QFileInfo(file1.filePath).fileName() << "vs" << QFileInfo(file2.filePath).fileName();
                    
                    // üìä DISABLED: Signal emission causing hang
                    // emit fileComparisonProgress(
                    //     QFileInfo(file1.filePath).fileName(),
                    //     QFileInfo(file2.filePath).fileName(),
                    //     currentComparison,
                    //     totalComparisons
                    // );
                    
                    // Bestimme Vergleichstyp
                    QString comparisonType;
                    if (file1.isLocal && file2.isLocal) {
                        comparisonType = "Lokal ‚Üî Lokal";
                    } else if (!file1.isLocal && !file2.isLocal) {
                        comparisonType = "Netzwerk ‚Üî Netzwerk";
                    } else {
                        comparisonType = "Lokal ‚Üî Netzwerk";
                        crossNetworkGroups++;
                    }
                    
                    // üìä LIVE-Update: Vergleichsaktivit√§t
                    emit processActivityUpdate(
                        QString("üîç %1 Vergleich").arg(comparisonType),
                        QString("Vergleiche %1 vs %2").arg(
                            QFileInfo(file1.filePath).fileName(),
                            QFileInfo(file2.filePath).fileName()
                        )
                    );
                    
                    duplicatesFound++;
                    
                    // üìä LIVE-Update: Duplikat gefunden
                    emit duplicateDetectionUpdate(
                        duplicatesFound,
                        groupsCreated,
                        QString("%1 ‚âà %2").arg(
                            QFileInfo(file1.filePath).fileName(),
                            QFileInfo(file2.filePath).fileName()
                        )
                    );
                    
                    // Throttling f√ºr GUI-Performance bei vielen Vergleichen
                    if (currentComparison % 50 == 0) {
                        if (totalComparisons > 0) {
                            int percentage = (currentComparison * 100) / totalComparisons;
                            emit scanProgressDetailed(
                                percentage,
                                currentComparison,
                                totalComparisons,
                                QString("Vergleiche Dateien (%1)").arg(comparisonType)
                            );
                        }
                        
                        // Kleine Pause f√ºr GUI-Responsivit√§t
                        QApplication::processEvents();
                    }
                }
            }
            
            // üè∑Ô∏è GOTO LABEL f√ºr Speicherschutz-Spr√ºnge
            next_hash_group:
            
            // Klassifiziere Gruppe
            bool hasLocal = false;
            bool hasNetwork = false;
            for (const FileInfo &file : files) {
                if (file.isLocal) hasLocal = true;
                else hasNetwork = true;
            }
            
            if (hasLocal && hasNetwork) {
                crossNetworkGroups++;
            } else if (hasLocal) {
                localOnlyGroups++;
            } else {
                networkOnlyGroups++;
            }
        }
    }
    int mixedGroups = 0;
    
    for (const auto &hashGroup : hashGroups) {
        bool hasLocal = false;
        bool hasNetwork = false;
        
        for (const FileInfo &file : hashGroup) {
            if (file.isLocal) {
                hasLocal = true;
            } else {
                hasNetwork = true;
            }
        }
        
        if (hasLocal && hasNetwork) {
            mixedGroups++;
        } else if (hasLocal) {
            localOnlyGroups++;
        } else if (hasNetwork) {
            networkOnlyGroups++;
        }
    }

    std::cout << "üîç " << hashGroups.size() << " Duplikat-Gruppen gefunden:" << std::endl;
    std::cout << "   üìÇ Nur lokal: " << localOnlyGroups << " Gruppen" << std::endl;
    std::cout << "   üì° Nur netzwerk: " << networkOnlyGroups << " Gruppen" << std::endl;
    std::cout << "   üîÑ Lokal ‚Üî Netzwerk: " << mixedGroups << " Gruppen" << std::endl;

    // Falls keine Hash-Gruppen entstanden sind (z.B. nur NPU-Ergebnisse), trotzdem Ergebnisse erzeugen
    generateResults();
}

void Scanner::generateResults()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] üéØ generateResults() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();

    emit scanStatusChanged("Generiere Ergebnisse (lokal + netzwerk)...");
    currentPhase = COMPLETED;

    DuplicateGroups results;
    int crossNetworkDuplicates = 0;

    qDebug() << "[Scanner] üìä GENERATERESULTS: Starte mit" << hashGroups.size() << "Hash-Gruppen";
    int processedGroups = 0;
    
    for (const auto &hashGroup : hashGroups)
    {
        processedGroups++;
        qDebug() << "[Scanner] üîç Pr√ºfe Gruppe" << processedGroups << "/" << hashGroups.size() << "mit" << hashGroup.size() << "Dateien";
        if (hashGroup.size() < 2) {
            qDebug() << "[Scanner] ‚è≠Ô∏è √úberspringe Gruppe (nur" << hashGroup.size() << "Datei)";
            continue;
        }

        DuplicateGroup group;
        QList<FileInfo> files = hashGroup;

        // ‚úÖ NEU: Pr√ºfe ob es sich um lokale ‚Üî Netzwerk Duplikate handelt
        bool hasLocal = false;
        bool hasNetwork = false;
        for (const FileInfo &file : files) {
            if (file.isLocal) {
                hasLocal = true;
            } else {
                hasNetwork = true;
            }
        }
        
        if (hasLocal && hasNetwork) {
            crossNetworkDuplicates++;
        }

        // Sort by modification time and prefer local files as originals
        std::sort(files.begin(), files.end(), [](const FileInfo &a, const FileInfo &b)
                  { 
                      // ‚úÖ PRIORIT√ÑT 1: Bevorzuge lokale Dateien als Original (sicherer)
                      if (a.isLocal != b.isLocal) {
                          return a.isLocal > b.isLocal; // Lokale Dateien zuerst
                      }
                      // ‚úÖ PRIORIT√ÑT 2: √Ñlteste Datei als Original (Standard: KEEP_OLDEST)
                      return a.lastModified < b.lastModified; // √Ñlteste zuerst (Original)
                  });

        // First file is original (preferably local), rest are duplicates
        group.original = files.takeFirst();
        group.duplicates = files;
        group.hash = group.original.hash;
        group.size = group.original.size;

        results.groups.append(group);
        results.duplicateFiles += group.duplicates.size();
        results.duplicateSize += group.size * group.duplicates.size();
    }

    // ‚úÖ KORREKTE STATISTIK: Nur tats√§chlich untersuchte Duplikat-Kandidaten z√§hlen
    int totalDuplicateCandidates = 0;
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        totalDuplicateCandidates += groupIt.value().size();
    }
    results.totalFiles = totalDuplicateCandidates; // Nur Dateien mit m√∂glichen Duplikaten

    scanning.store(false);
    currentPhase = IDLE;

    // ‚úÖ DEBUG: Detaillierte Ergebnis-Analyse
    qDebug() << "[Scanner] üìä FINALE STATISTIKEN:";
    qDebug() << "    - Verarbeitete Dateien:" << results.totalFiles;
    qDebug() << "    - Duplikat-Gruppen:" << results.groups.size();
    qDebug() << "    - Duplikat-Dateien:" << results.duplicateFiles;
    qDebug() << "    - Gesparte Gr√∂√üe:" << (results.duplicateSize / (1024*1024)) << "MB";

    std::cout << "‚úÖ Parallel-Scan abgeschlossen: " << results.groups.size()
              << " Duplikat-Gruppen mit " << results.duplicateFiles << " Duplikaten" << std::endl;
    std::cout << "   üîÑ Lokal ‚Üî Netzwerk Duplikate: " << crossNetworkDuplicates << " Gruppen" << std::endl;

    // Benutzerfreundliche Status-Nachricht basierend auf Ergebnis
    if (results.groups.empty()) {
        emit scanStatusChanged("‚úÖ Scan abgeschlossen - keine Duplikate gefunden!");
    } else {
        emit scanStatusChanged(QString("‚úÖ Scan abgeschlossen - %1 Duplikat-Gruppen mit %2 Duplikaten gefunden")
                              .arg(results.groups.size())
                              .arg(results.duplicateFiles));
    }
    
    // ‚úÖ CRITICAL FIX: Stop scanner completely after scanCompleted
    scanning.store(false);
    currentPhase = COMPLETED;
    
    // üõë Stop all progress updates
    emit scanProgress(100, results.duplicateFiles, results.duplicateFiles);
    
    qDebug() << "[Scanner] üö® emit scanCompleted(RESULTS) - generateResults() with" << results.groups.size() << "groups";
    emit scanCompleted(results);
    
    qDebug() << "[Scanner] üõë Scanner VOLLST√ÑNDIG GESTOPPT nach scanCompleted";
    
    // ‚úÖ CLEANUP: Stop all timers immediately after completion
    if (processTimer) processTimer->stop();
    if (fileCollectionTimer) fileCollectionTimer->stop();
    if (hashTimeoutTimer) hashTimeoutTimer->stop();
}

void Scanner::onFtpFilesReceived(const QString &directory, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üìÑ FTP-Dateien empfangen f√ºr:" << directory << "Files:" << files.size() << "Success:" << success;
    
    // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe ob Callback noch f√ºr aktuellen Scan g√ºltig ist
    uint64_t callbackScanId = this->currentScanId.load();
    if (callbackScanId == 0) {
        qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Dateien-Callback ignoriert: Kein aktiver Scan (Scan-ID=0)";
        return;
    }
    
    if (!success) {
        qWarning() << "[Scanner] ‚ö†Ô∏è FTP-Fehler beim Laden von:" << directory;
        return;
    }
    
    // üõ°Ô∏è KRITISCHER SICHERHEITSCHECK: Verhindere QHash-Crash bei sehr gro√üen Datens√§tzen
        if (files.size() > 25000) {
        qDebug() << "[Scanner] üö® KRITISCH: Zu viele Dateien (" << files.size() << ") - Chunked Processing aktiviert";
            // Versuche die vollst√§ndige FTP-URL f√ºr dieses Verzeichnis zu ermitteln
            QString baseUrl = directory;
            if (!baseUrl.startsWith("ftp://")) {
                // Aufl√∂sen anhand pendingFtpDirectories
                auto normalizePath = [](QString p) {
                    if (p.isEmpty()) return p;
                    if (!p.startsWith('/')) p.prepend('/');
                    if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                    return p;
                };
                const QString dirNorm = normalizePath(directory);
                for (const QString &pendingUrl : pendingFtpDirectories) {
                    QUrl url(pendingUrl);
                    const QString pendNorm = normalizePath(url.path());
                    if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                        baseUrl = pendingUrl;
                        break;
                    }
                }
            }
            processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    if (files.size() > 100000) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Zu viele Dateien (" << files.size() << ") - √ºberspringe zur Sicherheit";
        pendingFtpDirectories.removeOne(directory); // ‚úÖ FIX: Use removeOne() instead of remove()
        checkScanProgress();
        return;
    }
    
    // üß† NPU-BILDVERARBEITUNG: F√ºr gro√üe Bilddatens√§tze optimiert
    // üöÄ PRODUCTION NPU: Aktiviert f√ºr mittlere bis gro√üe Bilddatens√§tze (>1.000 Dateien)
    if (files.size() > 1000 && npuManager) {  // NPU aktiviert ab 1.000 Dateien
        qDebug() << "[Scanner] üöÄ ULTRA-FAST NPU aktiviert f√ºr" << files.size() << "Dateien";
        
        // üé® Filtere ALLE Bilddateien f√ºr Ultra-Fast NPU-Verarbeitung (inkl. RAW)
        QStringList imageFiles;
        for (const QString &file : files) {
            if (file.endsWith(".jpg", Qt::CaseInsensitive) || 
                file.endsWith(".jpeg", Qt::CaseInsensitive) ||
                file.endsWith(".png", Qt::CaseInsensitive) ||
                file.endsWith(".gif", Qt::CaseInsensitive) ||
                file.endsWith(".cr2", Qt::CaseInsensitive) ||  // Canon RAW
                file.endsWith(".nef", Qt::CaseInsensitive) ||  // Nikon RAW
                file.endsWith(".arw", Qt::CaseInsensitive) ||  // Sony RAW
                file.endsWith(".dng", Qt::CaseInsensitive) ||  // Adobe RAW
                file.endsWith(".tiff", Qt::CaseInsensitive) || // TIFF
                file.endsWith(".bmp", Qt::CaseInsensitive)) {  // Bitmap
                imageFiles.append(file);
            }
        }
        
        qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "Bilder f√ºr NPU-Verarbeitung";
        
        if (imageFiles.size() > 50) {  // üöÄ SOFORTIGE NPU-AKTIVIERUNG bei 50+ Bildern
            qDebug() << "[Scanner] üöÄ NPU-ONLY Bildverarbeitung f√ºr" << imageFiles.size() << "Bilder (KEINE Hash-Methode)";
            
            // üß† NPU FEATURE-VECTOR-BASIERTE DUPLIKATERKENNUNG (ERSETZT Hash-basiert)
            qDebug() << "[Scanner] üß† Starte NPU Feature-Vector-Analyse (Hash-frei)...";
            QStringList processedImages = npuManager->processImagesWithNpuUltraFast(imageFiles);
            
            // üéØ Feature-Vector-Duplikate finden (OHNE Hash-Vergleich!)
            QList<QStringList> featureBasedDuplicates = npuManager->findFeatureBasedDuplicates(processedImages);
            
            qDebug() << "[Scanner] ‚úÖ NPU-Feature-Duplikate gefunden:" << featureBasedDuplicates.size() << "Gruppen";
            qDebug() << "[Scanner] üöÄ NPU-ONLY Verarbeitung abgeschlossen:" 
                     << processedImages.size() << "Bilder ohne Hash-Methode";
                     
            // üìä NPU-Counter setzen f√ºr Hash-Pipeline-Skip
            npuProcessedImages = imageFiles.size();
            qDebug() << "[Scanner] üéØ NPU-Counter gesetzt:" << npuProcessedImages << "verarbeitete Bilder";
                     
            // üìä NPU-Aktivit√§ts-Update f√ºr GUI
            emit npuActivityUpdate(imageFiles.size(), featureBasedDuplicates.size());
            
            // üöÄ WICHTIG: Entferne verarbeitete Bilder aus der Hash-Pipeline
            // ‚ö†Ô∏è FIX: Erstelle lokale Kopie da `files` const ist
            QStringList remainingFiles = files;
            for (const QString &img : imageFiles) {
                remainingFiles.removeAll(img);
            }
            qDebug() << "[Scanner] üéØ BILDER aus Hash-Pipeline entfernt:" << imageFiles.size() << "Dateien";
            qDebug() << "[Scanner] üìä Verbleibende Dateien f√ºr Hash-Verarbeitung:" << remainingFiles.size();
            
        } else {
            qDebug() << "[Scanner] üìä Zu wenig Bilder f√ºr NPU-Batch (" << imageFiles.size() << "/50) - verwende Hash-basierte Einzelverarbeitung";
        }
    }
    
    // üß† MEMORY-PROTECTION: F√ºr sehr gro√üe Datens√§tze (>25.000 Dateien) Batch-Verarbeitung
    if (files.size() > 25000) {
        qDebug() << "[Scanner] üß† MEMORY-PROTECTION: Aktiviere Batch-Verarbeitung f√ºr" << files.size() << "Dateien";
        // directory kann Pfad oder vollst√§ndige URL sein; vereinheitlichen
        QString baseUrl = directory;
        if (!baseUrl.startsWith("ftp://")) {
            auto normalizePath = [](QString p) {
                if (p.isEmpty()) return p;
                if (!p.startsWith('/')) p.prepend('/');
                if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                return p;
            };
            const QString dirNorm = normalizePath(directory);
            for (const QString &pendingUrl : pendingFtpDirectories) {
                QUrl url(pendingUrl);
                const QString pendNorm = normalizePath(url.path());
                if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                    baseUrl = pendingUrl;
                    break;
                }
            }
        }
        processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    // Find the full FTP URL for this directory path (robust against trailing slashes)
    QString fullFtpUrl;
    auto normalizePath = [](QString p) {
        if (p.isEmpty()) return p;
        // Ensure path starts with '/'
        if (!p.startsWith('/')) p.prepend('/');
        // Remove single trailing '/'
        if (p.length() > 1 && p.endsWith('/')) p.chop(1);
        return p;
    };
    const QString dirNorm = normalizePath(directory);
    for (const QString &pendingUrl : pendingFtpDirectories) {
        QUrl url(pendingUrl);
        const QString pendNorm = normalizePath(url.path());
        if (pendNorm == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
        // Also allow match if directory had an extra '/' when emitted
        if (normalizePath(url.path() + "/") == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
    }
    
    if (fullFtpUrl.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Keine entsprechende FTP-URL gefunden f√ºr:" << directory;
        return;
    }
    
    // Extract host from full FTP URL for file path construction
    QUrl ftpUrl(fullFtpUrl);
    QString host = ftpUrl.host();
    QString basePath = ftpUrl.path();
    // Normalize basePath to '/path' without trailing '/'
    if (!basePath.startsWith('/')) basePath.prepend('/');
    if (basePath.length() > 1 && basePath.endsWith('/')) basePath.chop(1);
    
    // Add all files to allFiles list
    QSet<QString> processedFileNames; // üöÄ Prevent size-variant duplicates
    
    for (const QString &encodedFile : files) {
        // ‚úÖ FIX: Parse encoded "absolute/path/to/file|size" OR "/absolute/path/to/directory/" format
        QString rawEntry = encodedFile.trimmed();
        bool isDirectoryEntry = rawEntry.endsWith('/') && !rawEntry.contains('|');
        QString fileName;
        qint64 fileSize = 0;
        QString absolutePath; // full absolute path inside FTP server
        
        if (rawEntry.contains('|')) {
            // File with size info: absolute/path|12345
            int sep = rawEntry.lastIndexOf('|');
            fileSize = rawEntry.mid(sep + 1).toLongLong();
            absolutePath = rawEntry.left(sep);
            // Extract filename from absolute path
            fileName = QFileInfo(absolutePath).fileName();
        } else if (isDirectoryEntry) {
            // Pure directory ‚Äì skip
            qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe FTP-Verzeichnis:" << rawEntry;
            continue;
        } else {
            // Fallback: treat as file without size (absolute or relative)
            absolutePath = rawEntry;
            fileName = QFileInfo(absolutePath).fileName();
        }
        if (fileName.isEmpty()) {
            qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Eintrag ohne Dateiname √ºbersprungen:" << rawEntry;
            continue;
        }
        
        // ÔøΩüöÄ CRITICAL FIX: Skip if we already processed this filename (prevent size variants)
        if (processedFileNames.contains(fileName)) {
            qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Gr√∂√üen-Variante:" << fileName;
            continue;
        }
        processedFileNames.insert(fileName);
        
        // ‚úÖ Construct full ftp:// URL using absolute path (absolutePath already begins with '/')
        QString encodedFullPath;
        {
            QStringList pathParts = absolutePath.split('/', Qt::SkipEmptyParts);
            QStringList encodedParts;
            for (const QString &p : pathParts) {
                encodedParts << QUrl::toPercentEncoding(p);
            }
            encodedFullPath = "/" + encodedParts.join('/');
        }
        FileInfo fileInfo;
        fileInfo.filePath = QString("ftp://%1%2").arg(host, encodedFullPath);
        fileInfo.fileName = fileName; // Original-Dateiname f√ºr Anzeige
        fileInfo.size = fileSize; // ‚úÖ FIX: Use real file size from FTP LIST
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = "";
        fileInfo.isLocal = false; // ‚úÖ NEU: Markiere als Netzwerk-Datei
        fileInfo.networkType = "FTP"; // ‚úÖ NEU: Netzwerk-Typ
        
        // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe Scan-ID vor File-Hinzuf√ºgung
        if (this->currentScanId.load() != callbackScanId) {
            qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Batch-Datei ignoriert: Scan-ID nicht mehr g√ºltig (alte:" << callbackScanId << "neue:" << this->currentScanId.load() << ")";
            continue;
        }
        
        allFiles.append(fileInfo);
        qDebug() << "[Scanner] ‚úÖ Added FTP file:" << fileInfo.filePath << "Size:" << fileSize << "bytes";
    }
    
    // Mark this directory as completed
    completedFtpDirectories.append(directory);
    ftpDirectoriesProcessed++;
    
    // ‚úÖ NEU: Z√§hle lokale und FTP-Dateien separat f√ºr bessere Anzeige
    int localFiles = 0;
    int ftpFiles = 0;
    for (const FileInfo &file : allFiles) {
        if (file.isLocal) {
            localFiles++;
        } else {
            ftpFiles++;
        }
    }
    
    emit scanStatusChanged(QString("Parallel: Lokal %1, FTP %2/%3 (%4 Dateien)")
                          .arg(localFiles)
                          .arg(ftpDirectoriesProcessed)
                          .arg(pendingFtpDirectories.size())
                          .arg(ftpFiles));
    
    // Check if all FTP directories are processed
    if (completedFtpDirectories.size() >= pendingFtpDirectories.size()) {
        qDebug() << "[Scanner] ‚úÖ Alle FTP-Verzeichnisse verarbeitet (lokal:" << localFiles << ", ftp:" << ftpFiles << "), starte Size-Filtering";
        
        // ‚úÖ ENTFERNT: HashEngine expectedFilesCount wird jetzt in startHashing() korrekt gesetzt
        
        // ‚úÖ FIX ENTFERNT: HashEngine NICHT stoppen bei dual scan!
        // HashEngine muss f√ºr lokale+FTP Dateien weiterlaufen k√∂nnen
        qDebug() << "[Scanner] ‚ö° FTP-Sammlung abgeschlossen, HashEngine l√§uft f√ºr alle Dateien weiter";
        
        QTimer::singleShot(100, this, [this]() {
            filterBySize(); // ‚úÖ KORREKTUR: Erst Size-Filtering f√ºr alle Dateien
        });
    }
}

void Scanner::collectFtpFiles(const QString &ftpDirectory, QSet<QString> &processedFiles)
{
    qDebug() << "[Scanner] üì° FTP-Optimiert: Sammle Dateien f√ºr:" << ftpDirectory;
    
    // ‚ö° PERFORMANCE: Cache f√ºr gro√üe Datens√§tze 
    static QHash<QString, QStringList> ftpFileCache;
    static QDateTime lastCacheUpdate;
    
    // Cache-Check: Verwende gecachte Daten wenn < 5 Min alt
    if (ftpFileCache.contains(ftpDirectory) && 
        lastCacheUpdate.secsTo(QDateTime::currentDateTime()) < 300) {
        qDebug() << "[Scanner] ‚ö° FTP-Cache-Hit f√ºr:" << ftpDirectory;
        processCachedFtpFiles(ftpDirectory, ftpFileCache[ftpDirectory], processedFiles);
        return;
    }
    
    // Extract IP and path from FTP URL: ftp://192.168.1.224/sdb/Comedy/
    QUrl ftpUrl(ftpDirectory);
    if (!ftpUrl.isValid()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltige FTP-URL:" << ftpDirectory;
        return;
    }
    QString host = ftpUrl.host();
    QString path = ftpUrl.path();
    if (host.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger FTP-Pfad (Host leer):" << ftpDirectory;
        return;
    }
    if (path.isEmpty()) path = "/"; // ensure non-empty directory path
    
    // ‚ö° OPTIMIERT: Wiederverwendung bestehender FTP-Connections
    FtpClient *urlSpecificClient = getOrCreateFtpClient(host);
    if (!urlSpecificClient) {
        qCritical() << "[Scanner] ‚ùå Konnte keinen FTP-Client erstellen f√ºr Host:" << host;
        return;
    }
    
    // ‚úÖ BULLETPROOF: PresetManager Null-Check mit Fallback
    if (!presetManager) {
        qCritical() << "[Scanner] ‚ùå FATAL: PresetManager null! Verwende Default-Credentials";
        useDefaultFtpCredentials(urlSpecificClient, host);
    } else {
        // Hole Credentials aus PresetManager f√ºr gespeicherte Logins
        LoginData login = presetManager->getLogin(host, 21);
        if (!login.isValid()) {
            qWarning() << "[Scanner] ‚ö†Ô∏è Keine Login-Daten f√ºr" << host << ":21 ‚Üí Verwende Default";
            useDefaultFtpCredentials(urlSpecificClient, host);
        } else {
            qDebug() << "[Scanner] üîê Verwende Credentials:" << login.username << "f√ºr" << host;
            urlSpecificClient->setCredentials(host, 21, login.username, login.password);
        }
    }
    
    // Add to pending directories list for tracking; skip duplicate setup if already pending
    bool newlyAdded = false;
    if (!pendingFtpDirectories.contains(ftpDirectory)) {
        pendingFtpDirectories.append(ftpDirectory);
        newlyAdded = true;
    } else {
        qDebug() << "[Scanner] ‚è≠Ô∏è FTP-Verzeichnis bereits pending, √ºberspringe erneute Verbindung:" << ftpDirectory;
        return;
    }
    
    qDebug() << "[Scanner] üìÇ Starte rekursive FTP-Datei-Sammlung f√ºr:" << host << path;
    
    // üéØ FTP-TRACKING: Registriere neuen aktiven FTP-Scan
    activeFtpScans.fetch_add(1);
    ftpScanningActive.store(true);
    qDebug() << "[Scanner] üîÑ FTP-Scan gestartet. Aktive Scans:" << activeFtpScans.load();
    
    // Verbinde Signal f√ºr rekursive Dateisammlung (einzigartig, keine Duplikate)
    connect(urlSpecificClient, &FtpClient::allFilesRecursivelyFinished,
            this, [this, ftpDirectory](const QStringList &allFiles, bool success) {
        qDebug() << "[Scanner] ÔøΩ Rekursive FTP-Dateien empfangen f√ºr:" << ftpDirectory << "Files:" << allFiles.size() << "Success:" << success;
        
        // üéØ FTP-TRACKING: Markiere diesen FTP-Scan als abgeschlossen (IMMER, auch bei Fehlern)
        int remainingScans = activeFtpScans.fetch_sub(1) - 1;
        if (remainingScans <= 0) {
            ftpScanningActive.store(false);
            qDebug() << "[Scanner] ‚úÖ Alle FTP-Scans abgeschlossen! Status auf false gesetzt.";
        } else {
            qDebug() << "[Scanner] üîÑ FTP-Scan abgeschlossen. Verbleibende Scans:" << remainingScans;
        }
        
        // üö® CRITICAL MEMORY PROTECTION: Prevent QSet crash for large datasets
        if (allFiles.size() > 15000) {  // Reduziert von 25000 auf 15000 f√ºr bessere Stabilit√§t
            qWarning() << "[Scanner] üö® KRITISCH: Gro√üe Datenmenge (" << allFiles.size() << ") - verwende sichere Batch-Verarbeitung";
            processFtpFilesBatch(ftpDirectory, allFiles, success);
            return;
        }
        
        // üõ°Ô∏è EXTRA MEMORY PROTECTION: Check for potential memory stress
        if (allFiles.size() > 10000) {
            qWarning() << "[Scanner] ‚ö†Ô∏è WARNUNG: Sehr gro√üe Datenmenge (" << allFiles.size() << ") - aktiviere zus√§tzliche Memory-Protection";
            // Trigger garbage collection if possible
            QCoreApplication::processEvents();
        }
        
        // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe ob Callback noch f√ºr aktuellen Scan g√ºltig ist
        uint64_t callbackScanId = this->currentScanId.load();
        if (callbackScanId == 0) {
            qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Callback ignoriert: Kein aktiver Scan (Scan-ID=0)";
            return;
        }
        
        if (success) {
            // üõ°Ô∏è CRASH-SAFE: Use member variable instead of reference capture
            if (this->processedFiles.size() > 20000) {
                qWarning() << "[Scanner] üö® ProcessedFiles-Cache zu gro√ü (" << this->processedFiles.size() << ") - l√∂sche f√ºr Stabilit√§t";
                this->processedFiles.clear();
            }
            
            // Einheitliche Gro√üdatei-Politik (FTP): env-basiert
            bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
            qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;

            for (const QString &file : allFiles) {
                QString baseFileName = file;
                qint64 fileSize = 0;
                
                // üéØ KRITISCHER FIX: Parse FTP-Dateien mit |Gr√∂√üe-Anhang und verwende base filename!
                if (file.contains("|")) {
                    QStringList fileNameParts = file.split("|");
                    baseFileName = fileNameParts[0];
                    fileSize = fileNameParts[1].toLongLong();
                    // Einheitliche Gro√üdatei-Politik anwenden
                    if (skipLarge && maxSizeMb > 0) {
                        qint64 maxBytes = maxSizeMb * 1024 * 1024;
                        if (fileSize > maxBytes) {
                            qDebug() << "[Scanner] üö´ GROSSE FTP-Datei √ºbersprungen (" << maxSizeMb << "MB):" << baseFileName;
                            continue;
                        }
                    }
                    
                    qDebug() << "[Scanner] üõ°Ô∏è DUPLIKAT-FIX: √úberspringe Gr√∂√üe-Variante:" << file << "‚Üí verwende nur:" << baseFileName;
                    // ‚úÖ KRITISCHER FIX: CONTINUE ENTFERNT - wir verwenden baseFileName weiter!
                }
                
                // üîß CRITICAL FIX: Pr√ºfe ob baseFileName bereits absoluter Pfad ist
                QString fullPath;
                if (baseFileName.startsWith("/")) {
                    // baseFileName ist bereits absoluter Pfad vom FTP-Server - verwende as-is
                    fullPath = QString("ftp://%1%2").arg(QUrl(ftpDirectory).host(), baseFileName);
                    qDebug() << "[Scanner] üîß Absolute FTP path detected, constructed:" << fullPath;
                } else {
                    // baseFileName ist relativ - f√ºge zu ftpDirectory hinzu  
                    fullPath = ftpDirectory;
                    if (!fullPath.endsWith("/")) fullPath += "/";
                    fullPath += baseFileName;
                    qDebug() << "[Scanner] üîß Relative FTP path detected, constructed:" << fullPath;
                }
                
                // üõ°Ô∏è CRASH-SAFE: Use member variable instead of dangling reference
                QString canonicalPath = QUrl(fullPath).toString();  // FTP-URLs normalisieren
                if (this->processedFiles.contains(canonicalPath)) {
                    qDebug() << "[Scanner] ‚è≠Ô∏è FTP-Datei bereits in diesem Scan verarbeitet (√ºbersprungen):" << canonicalPath.right(50);
                    continue;
                }
                this->processedFiles.insert(canonicalPath);
                
                // üöÄ VERZEICHNIS-FILTER: FTP-Duplikate d√ºrfen keine Verzeichnisse sein
                if (baseFileName.endsWith('/') || baseFileName.isEmpty()) {
                    qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe FTP-Verzeichnis:" << baseFileName;
                    continue;
                }
                
                // ‚úÖ F√ºge FTP-Datei zur Sammlung hinzu mit korrekter Gr√∂√üe
                FileInfo ftpFile;
                ftpFile.filePath = fullPath;
                ftpFile.fileName = baseFileName;
                ftpFile.size = fileSize;
                ftpFile.lastModified = QDateTime::currentDateTime().toSecsSinceEpoch();
                ftpFile.hash = "";  // Wird sp√§ter berechnet
                ftpFile.isLocal = false;  // FTP-Datei
                ftpFile.networkType = "FTP";
                
                // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe Scan-ID vor File-Hinzuf√ºgung
                if (this->currentScanId.load() != callbackScanId) {
                    qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Datei ignoriert: Scan-ID nicht mehr g√ºltig (alte:" << callbackScanId << "neue:" << this->currentScanId.load() << ")";
                    continue;
                }
                
                this->allFiles.append(ftpFile);  // ‚úÖ FIX: Verwende Member-Variable this->allFiles
                qDebug() << "[Scanner] ‚úÖ FTP-Datei hinzugef√ºgt (rekursiv):" << baseFileName << "Size:" << fileSize;
            }
        } else {
            qWarning() << "[Scanner] ‚ö†Ô∏è FTP-Fehler beim Laden von:" << ftpDirectory;
        }
        
        // Entferne aus pending list
        pendingFtpDirectories.removeAll(ftpDirectory);

        // Wichtig: Pooled-Clients NICHT l√∂schen, nur Verbindung l√∂sen, damit kein Dangling Pointer im Pool entsteht
        QObject *s = sender();
        if (s) {
            QObject::disconnect(s, nullptr, this, nullptr);
        }

        // ‚úÖ FTP CALLBACK FIXED: Check if all FTP directories are completed
        if (scanning.load()) {
            qDebug() << "[Scanner] üîÑ FTP abgeschlossen, pr√ºfe ob alle FTP-Verzeichnisse fertig sind...";
            qDebug() << "[Scanner] üìä FTP Status: Pending:" << pendingFtpDirectories.size() << "Completed:" << completedFtpDirectories.size() << "Total Files:" << allFiles.size();
            
            // Critical fix: Call checkScanProgress to proceed with duplicate detection
            QTimer::singleShot(50, this, &Scanner::checkScanProgress);
        }
    });
    
    // Starte die Verbindung und rekursive Dateiliste 
    urlSpecificClient->connectToHost();
    // Ensure path points to a directory
    if (!path.endsWith('/')) path += '/';
    
    qDebug() << "[Scanner] üîÑ Starte REKURSIVE FTP-Dateisammlung f√ºr:" << path;
    urlSpecificClient->listAllFilesRecursively(path);
    
    qDebug() << "[Scanner] ‚úÖ FTP-Collection gestartet f√ºr" << ftpDirectory;
}

void Scanner::checkScanProgress()
{
    qDebug() << "[Scanner] üîç checkScanProgress() aufgerufen - Pending FTP:" << pendingFtpDirectories.size();
    qDebug() << "[Scanner] üîç DEBUG: Ist pendingFtpDirectories leer?" << pendingFtpDirectories.isEmpty();
    
    // üìä PROGRESS-UPDATE: FTP-Verarbeitung
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    if (totalFtpDirs > 0) {
        int progressPercent = (completedFtpDirectories.size() * 100) / totalFtpDirs;
        emit scanProgress(progressPercent, completedFtpDirectories.size(), totalFtpDirs);
        emit currentFileProcessing(
            QString("FTP-Verzeichnis %1/%2").arg(completedFtpDirectories.size()).arg(totalFtpDirs),
            "üì° Lade Netzwerk-Dateien",
            completedFtpDirectories.size(),
            totalFtpDirs
        );
    }
    
    // Wenn alle FTP-Operationen abgeschlossen sind, starte die Hash-Berechnung
    if (pendingFtpDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Alle FTP-Verzeichnisse geladen - starte Duplikat-Erkennung";
        qDebug() << "[Scanner] ÔøΩ FTP-COLLECTION COMPLETE: Anzahl Dateien in allFiles:" << allFiles.size();
        
        // üîÑ CRITICAL FIX: Call filterBySize directly since FTP file collection is complete
        QTimer::singleShot(50, this, &Scanner::filterBySize);
        return;
    }
}

// üß† NPU-CALLBACK: NPU-Bildverarbeitung abgeschlossen
void Scanner::onNpuImageBatchProcessed(const QStringList &processedImages)
{
    qDebug() << "[Scanner] üé® NPU-Bildverarbeitung abgeschlossen:" << processedImages.size() << "Bilder verarbeitet";
    
    // üéØ LIVE-NPU-UPDATES f√ºr jedes verarbeitete Bild
    for (int i = 0; i < processedImages.size(); ++i) {
        QString imagePath = processedImages.at(i);
        QString fileName = QFileInfo(imagePath).fileName();
        
        // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI senden
        emit currentFileProcessing(fileName, "NPU-Bildanalyse", i + 1, processedImages.size());
        emit processActivityUpdate("NPU-Bildverarbeitung", 
                                   QString("Feature-Extraktion: %1").arg(fileName));
    }
    
    // Statistiken f√ºr NPU-Verarbeitung
    emit scanStatusChanged(QString("üß† NPU-Bildverarbeitung: %1 Bilder analysiert").arg(processedImages.size()));
    
    // üöÄ NPU-AKTIVIT√ÑTS-UPDATE f√ºr Activity-Indicator
    emit npuActivityUpdate(processedImages.size(), 0); // Noch keine Duplikate gefunden
    
    // Hier k√∂nnten wir die NPU-Ergebnisse weiterverarbeiten
    // z.B. f√ºr intelligente Duplikatserkennung basierend auf Bild√§hnlichkeit
}

// üóëÔ∏è FTP-Remove Callback
void Scanner::onFtpRemoveFinished(const QString &remoteFile, bool ok)
{
    deleteAttempted++;
    if (ok) deleteSucceeded++;
    emit deleteProgress(remoteFile, ok, ok ? "FTP gel√∂scht" : "FTP l√∂schen fehlgeschlagen");
    if (deleteAttempted == 0) return; // shouldn‚Äôt happen
}

// üóëÔ∏è Duplikate l√∂schen (Batch)
void Scanner::deleteDuplicateFiles(const QList<FileInfo> &filesToDelete)
{
    deleteAttempted = 0;
    deleteSucceeded = 0;
    for (const auto &fi : filesToDelete) {
        // üö´ Schutz: Original-Dateien niemals l√∂schen (wenn Gruppe erkennbar)
        // Heuristik: Falls Hash vorhanden und diese Datei in hashGroups[hash] die "√§lteste/j√ºngste" Regel erf√ºllt
        if (!fi.hash.isEmpty() && hashGroups.contains(fi.hash)) {
            const QList<FileInfo> &group = hashGroups.value(fi.hash);
            if (group.size() > 1) {
                // Bestimme Original nach aktuellem Regel-Set (angenommen: neueste behalten)
                FileInfo candidateOriginal = group.first();
                for (const FileInfo &gfi : group) {
                    if (gfi.lastModified > candidateOriginal.lastModified) {
                        candidateOriginal = gfi;
                    }
                }
                if (candidateOriginal.filePath == fi.filePath) {
                    emit deleteProgress(fi.filePath, false, "Original gesch√ºtzt");
                    continue; // Original nicht l√∂schen
                }
            }
        }
        QString msg;
        if (fi.isLocal) {
            bool ok = deleteLocalFile(fi.filePath, msg);
            deleteAttempted++;
            if (ok) deleteSucceeded++;
            emit deleteProgress(fi.filePath, ok, msg);
        } else if (fi.filePath.startsWith("ftp://")) {
            // Sicherheitsnetz: Verzeichnisse nicht l√∂schen
            if (fi.filePath.endsWith('/')) {
                emit deleteProgress(fi.filePath, false, "Verzeichnis-L√∂schen blockiert");
                continue;
            }
            // FTP: Host + Remote Pfad extrahieren
            QUrl u(fi.filePath);
            QString remote = u.path();
            if (remote.startsWith('/')) remote.remove(0,1);
            if (!ftpClient) {
                emit deleteProgress(fi.filePath, false, "Kein FTP-Client verf√ºgbar");
                continue;
            }
            // Anmeldedaten werden vom FtpClient verwaltet; wir rufen remove() auf
            connect(ftpClient, &FtpClient::removeFinished, this, &Scanner::onFtpRemoveFinished, Qt::UniqueConnection);
            ftpClient->remove(remote);
        } else if (fi.filePath.startsWith("sftp://")) {
            emit deleteProgress(fi.filePath, false, "SFTP-L√∂schen noch nicht implementiert");
        } else if (fi.filePath.startsWith("smb://")) {
            emit deleteProgress(fi.filePath, false, "SMB-L√∂schen noch nicht implementiert");
        } else if (fi.filePath.startsWith("nfs://")) {
            emit deleteProgress(fi.filePath, false, "NFS-L√∂schen noch nicht implementiert");
        } else {
            emit deleteProgress(fi.filePath, false, "Unbekannter Netzwerktyp");
        }
    }
    emit deleteBatchFinished(deleteAttempted, deleteSucceeded);
}

// üóëÔ∏è Lokale Datei l√∂schen ‚Üí Papierkorb wenn m√∂glich, sonst hart
bool Scanner::deleteLocalFile(const QString &path, QString &msg)
{
    QFileInfo info(path);
    if (!info.exists() || !info.isFile()) {
        msg = "Nicht gefunden oder keine Datei";
        return false;
    }
    // Versuch: direkt l√∂schen (send2trash w√§re extern, hier Fallback)
    if (QFile::remove(path)) {
        msg = "Gel√∂scht";
        return true;
    }
    msg = "L√∂schen fehlgeschlagen";
    return false;
}

// üõ°Ô∏è NEUE FUNKTION: Deduplication-Caches leeren
void Scanner::clearDeduplicationCaches()
{
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    processedFiles.clear();  // üõ°Ô∏è KRITISCH: Member-Variable auch leeren!
    
    // üßπ ERWEITERTE MEMORY-BEREINIGUNG
    // Nur leeren wenn bereits verarbeitet (nicht w√§hrend aktiver Scan)
    if (!scanning.load()) {
        allFiles.clear();
        allFiles.squeeze(); // Force deallocation
        
        fileSizeGroups.clear();
        hashGroups.clear();
        dateSizeGroups.clear();
        
        extractedFeatures.clear();
        extractedFeatures.squeeze(); // Force deallocation
        
        imageDuplicateGroups.clear();
        imageDuplicateGroups.squeeze(); // Force deallocation
        
        // Directory iterators cleanup
        currentDirIterators.clear();
        
        qDebug() << "[Scanner] üßπ ERWEITERTE Memory-Bereinigung durchgef√ºhrt";
    }
    
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert (inkl. processedFiles)";
}

// üõ°Ô∏è NEUE FUNKTION: Pr√ºfung ob Datei bereits verarbeitet wurde
bool Scanner::isFileAlreadyProcessed(const QString &filePath)
{
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    return globalProcessedFiles.contains(canonicalPath);
}

// ‚úÖ NEW: Enhanced remote path detection
bool Scanner::isRemotePath(const QString &path)
{
    // Check for various remote protocols
    QStringList remoteProtocols = {
        "ftp://", "ftps://", "sftp://", 
        "smb://", "cifs://", "nfs://",
        "ssh://", "http://", "https://"
    };
    
    for (const QString &protocol : remoteProtocols) {
        if (path.startsWith(protocol, Qt::CaseInsensitive)) {
            return true;
        }
    }
    
    // Check for UNC paths (Windows network shares)
    if (path.startsWith("\\\\") || path.startsWith("//")) {
        return true;
    }
    
    return false;
}

// üß† MEMORY-SAFE: Batch-Verarbeitung f√ºr gro√üe FTP-Datens√§tze (>25.000 Dateien)
void Scanner::processFtpFilesBatch(const QString &directoryOrUrl, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üß† BATCH-VERARBEITUNG f√ºr" << files.size() << "Dateien gestartet";
    
    // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe ob Callback noch f√ºr aktuellen Scan g√ºltig ist
    uint64_t callbackScanId = this->currentScanId.load();
    if (callbackScanId == 0) {
        qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Batch-Callback ignoriert: Kein aktiver Scan (Scan-ID=0)";
        return;
    }
    
    const int batchSize = 5000; // 5K Dateien pro Batch
    int totalBatches = (files.size() + batchSize - 1) / batchSize;
    // Ermittele Basis-URL f√ºr korrekte Pfadkonstruktion
    QString baseUrl = directoryOrUrl;
    if (!baseUrl.startsWith("ftp://")) {
        auto normalizePath = [](QString p) {
            if (p.isEmpty()) return p;
            if (!p.startsWith('/')) p.prepend('/');
            if (p.length() > 1 && p.endsWith('/')) p.chop(1);
            return p;
        };
        const QString dirNorm = normalizePath(directoryOrUrl);
        for (const QString &pendingUrl : pendingFtpDirectories) {
            QUrl url(pendingUrl);
            const QString pendNorm = normalizePath(url.path());
            if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                baseUrl = pendingUrl;
                break;
            }
        }
    }
    
    for (int batch = 0; batch < totalBatches; batch++) {
        int startIdx = batch * batchSize;
        int endIdx = qMin(startIdx + batchSize, files.size());
        
        QStringList batchFiles = files.mid(startIdx, endIdx - startIdx);
        qDebug() << "[Scanner] üß† Verarbeite Batch" << (batch + 1) << "/" << totalBatches 
                 << ":" << batchFiles.size() << "Dateien";
        
        // ‚úÖ Direkte Verarbeitung ohne rekursiven Aufruf mit korrekter Basis-URL
        processSingleFtpBatch(baseUrl, batchFiles);
        
        // üõ°Ô∏è Memory-Cleanup zwischen Batches
        if (batch % 2 == 0) { // Every 2nd batch
            clearDeduplicationCaches();
            
            // üßπ AGGRESSIVE Memory-Cleanup f√ºr gro√üe Datens√§tze
            if (batch % 10 == 0 && allFiles.size() > 5000) {
                // Periodisches Memory-Defragmentierung bei gro√üen Datens√§tzen
                allFiles.squeeze();
                qDebug() << "[Scanner] üíæ Aggressive Memory-Defragmentierung bei" << allFiles.size() << "Dateien";
            }
            
            qDebug() << "[Scanner] üßπ Batch-Memory-Cleanup durchgef√ºhrt";
        }
        
        // Kurze Pause zwischen Batches um Memory-Pressure zu reduzieren
        QThread::msleep(50);
    }
    
    // Mark directory as completed after all batches
    pendingFtpDirectories.removeOne(directoryOrUrl);
    
    // ‚úÖ FIXED: Continue async directory processing instead of old checkScanProgress
    if (scanning.load()) {
        qDebug() << "[Scanner] üîÑ FTP batch abgeschlossen, setze async directory processing fort...";
        // Continue with next directory in the async processing loop
        QTimer::singleShot(50, this, &Scanner::processNextDirectoryChunk);
    }
    
    qDebug() << "[Scanner] ‚úÖ BATCH-VERARBEITUNG abgeschlossen:" << totalBatches << "Batches verarbeitet";
}

// üß† MEMORY-SAFE: Einzelner Batch ohne Rekursion
void Scanner::processSingleFtpBatch(const QString &baseUrl, const QStringList &files)
{
    // üõ°Ô∏è RACE CONDITION PROTECTION: Pr√ºfe ob Callback noch f√ºr aktuellen Scan g√ºltig ist
    uint64_t callbackScanId = this->currentScanId.load();
    if (callbackScanId == 0) {
        qDebug() << "[Scanner] ‚ö†Ô∏è FTP-Single-Batch-Callback ignoriert: Kein aktiver Scan (Scan-ID=0)";
        return;
    }
    
    // ‚úÖ Einfache Batch-Verarbeitung ohne komplexe NPU-Logik
    // Einheitliche Gro√üdatei-Politik (FTP): env-basiert
    bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
    qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
    for (const QString &fileName : files) {
        // ‚úÖ Erstelle FileInfo ohne QSet-Overhead
        QString filePath;
        qint64 fileSize = 0;
        
        // Parse file info (name|size format)
        if (fileName.contains('|')) {
            QStringList parts = fileName.split('|');
            QString name = parts[0];
            if (parts.size() > 1) {
                fileSize = parts[1].toLongLong();
            }
            // Einheitliche Gro√üdatei-Politik anwenden
            if (skipLarge && maxSizeMb > 0) {
                qint64 maxBytes = maxSizeMb * 1024 * 1024;
                if (fileSize > maxBytes) {
                    qDebug() << "[Scanner] üö´ GROSSE FTP-Datei √ºbersprungen (Batch) (" << maxSizeMb << "MB):" << name;
                    continue;
                }
            }
            filePath = name;
        } else {
            filePath = fileName;
        }
        
        // ‚úÖ Create FTP FileInfo - extract host from directory context
        FileInfo fileInfo;
        fileInfo.fileName = QFileInfo(filePath).fileName();
        
        // ‚úÖ Proper URL construction: baseUrl is a full FTP URL already
        QString url = baseUrl;
        if (!url.endsWith('/')) url += '/';
        fileInfo.filePath = url + QUrl::toPercentEncoding(fileInfo.fileName);
        
        fileInfo.size = fileSize;
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = ""; // Will be calculated later
        fileInfo.isLocal = false;
        fileInfo.networkType = "FTP";
        
        // ‚úÖ Add to main file list (thread-safe) - Hash will be calculated in startHashing()
        allFiles.append(fileInfo);
        
        // üìä PROGRESS UPDATE f√ºr FTP-Processing
        if (allFiles.size() % 1000 == 0) {
            emit ftpProcessingProgress(allFiles.size(), QString("FTP-Dateien verarbeitet: %1").arg(allFiles.size()));
        }
    }
    
    qDebug() << "[Scanner] ‚úÖ Batch-Dateien hinzugef√ºgt:" << files.size() << "Total:" << allFiles.size();
}

// üéØ NPU-BILDVERARBEITUNG: Feature-basierte √Ñhnlichkeitsanalyse
void Scanner::startNpuImageAnalysis(const QStringList &imagePaths) {
    if (!npuManager) {
        qWarning() << "[Scanner] ‚ùå NPU-Manager nicht verf√ºgbar - √ºberspringe Bildanalyse";
        return;
    }
    
    qDebug() << "[Scanner] üéØ NPU-Bildanalyse startet f√ºr" << imagePaths.size() << "Bilder";
    emit npuAnalysisProgress("Extrahiere Bildfeatures mit NPU...");
    
    // Extrahiere Features f√ºr alle Bilder
    extractedFeatures = npuManager->extractImageFeatures(imagePaths);
    emit imageFeaturesExtracted(extractedFeatures);
    
    // F√ºhre √Ñhnlichkeitsanalyse durch
    emit npuAnalysisProgress("Analysiere Bild√§hnlichkeiten...");
    processImageFeatures(extractedFeatures);
}

void Scanner::processImageFeatures(const QList<NpuManager::ImageFeature> &features) {
    if (features.isEmpty()) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine g√ºltigen Bildfeatures - √ºberspringe NPU-Analyse";
        return;
    }
    
    qDebug() << "[Scanner] üîç Verarbeite" << features.size() << "Bildfeatures";
    
    // Verwende konfigurierbaren √Ñhnlichkeitsmodus (Standard: NEAR_DUPLICATES)
    QList<NpuManager::NpuDuplicateGroup> npuGroups = npuManager->findSimilarImages(features, currentSimilarityMode);
    
    // Konvertiere NPU-Gruppen zu Scanner-Format
    imageDuplicateGroups.clear();
    for (const auto &npuGroup : npuGroups) {
        ImageDuplicateGroup scannerGroup;
        scannerGroup.originalImage = npuGroup.originalImage;
        scannerGroup.duplicateImages = npuGroup.similarImages;
        scannerGroup.averageSimilarity = npuGroup.avgSimilarity;
        
        // Bestimme Gruppen-Typ basierend auf √Ñhnlichkeit
        if (npuGroup.avgSimilarity >= 0.95f) scannerGroup.groupType = "STRICT";
        else if (npuGroup.avgSimilarity >= 0.85f) scannerGroup.groupType = "NEAR";
        else if (npuGroup.avgSimilarity >= 0.70f) scannerGroup.groupType = "SIMILAR";
        else scannerGroup.groupType = "LOOSE";
        
        imageDuplicateGroups.append(scannerGroup);
    }
    
    qDebug() << "[Scanner] ‚úÖ NPU-Analyse abgeschlossen:" << imageDuplicateGroups.size() << "Bild-Duplikat-Gruppen";
    emit imageDuplicatesFound(imageDuplicateGroups);
}

// Filtere Bilddateien aus allen gefundenen Dateien
QStringList Scanner::filterImageFiles(const QList<FileInfo> &allFiles) {
    QStringList imagePaths;
    QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp"};
    
    for (const FileInfo &file : allFiles) {
        if (isImageFile(file.filePath)) {
            imagePaths.append(file.filePath);
        }
    }
    
    qDebug() << "[Scanner] üñºÔ∏è " << imagePaths.size() << "Bilddateien von" << allFiles.size() << "Dateien gefiltert";
    return imagePaths;
}

// Pr√ºfe ob Datei ein Bild ist
bool Scanner::isImageFile(const QString &filePath) const {
    static QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".svg"};
    
    QString lowerPath = filePath.toLower();
    for (const QString &ext : imageExtensions) {
        if (lowerPath.endsWith(ext)) {
            return true;
        }
    }
    return false;
}

// Kombiniere Hash- und NPU-basierte Ergebnisse
CombinedDuplicateResult Scanner::combineHashAndImageResults() {
    CombinedDuplicateResult combined;
    
    // Hash-basierte Duplikate aus aktuellen Gruppen
    for (const auto &sizeGroup : fileSizeGroups) {
        if (sizeGroup.size() > 1) {
            QHash<QString, QList<FileInfo>> hashMap;
            for (const FileInfo &file : sizeGroup) {
                if (!file.hash.isEmpty()) {
                    hashMap[file.hash].append(file);
                }
            }
            
            for (auto it = hashMap.begin(); it != hashMap.end(); ++it) {
                if (it.value().size() > 1) {
                    DuplicateGroup group;
                    group.hash = it.key();
                    group.size = it.value().first().size;
                    group.original = it.value().first();
                    
                    for (int i = 1; i < it.value().size(); ++i) {
                        group.duplicates.append(it.value()[i]);
                    }
                    
                    combined.hashDuplicates.append(group);
                }
            }
        }
    }
    
    // NPU-basierte Bild-Duplikate hinzuf√ºgen
    combined.imageDuplicates = imageDuplicateGroups;
    
    qDebug() << "[Scanner] üîó Kombinierte Ergebnisse:" << combined.hashDuplicates.size() << "Hash-Gruppen," << combined.imageDuplicates.size() << "Bild-Gruppen";
    return combined;
}

// Erweiterte Duplikatserkennung: Hash + NPU kombiniert
void Scanner::startAdvancedDuplicateDetection() {
    qDebug() << "[Scanner] üöÄ Erweiterte Duplikatserkennung startet (Hash + NPU)";
    
    // Phase 1: Traditionelle Hash-basierte Duplikaterkennung
    emit scanStatusChanged("Berechne File-Hashes...");
    compareHashes();
    
    // Phase 2: NPU-basierte Bild√§hnlichkeitsanalyse
    if (npuManager) {
        QStringList imagePaths = filterImageFiles(allFiles);
        if (!imagePaths.isEmpty()) {
            emit scanStatusChanged("NPU analysiert Bild√§hnlichkeiten...");
            currentSimilarityMode = NpuManager::NEAR_DUPLICATES; // Konfigurierbar
            startNpuImageAnalysis(imagePaths);
        }
    }
    
    // Phase 3: Kombiniere Ergebnisse
    emit scanStatusChanged("Kombiniere Duplikat-Ergebnisse...");
    CombinedDuplicateResult combined = combineHashAndImageResults();
    emit combinedScanCompleted(combined);
}

// Implementierung f√ºr CombinedDuplicateResult::totalDuplicates()
int CombinedDuplicateResult::totalDuplicates() const {
    int total = 0;
    for (const DuplicateGroup &group : hashDuplicates) {
        total += group.duplicates.size();
    }
    for (const ImageDuplicateGroup &group : imageDuplicates) {
        total += group.duplicateImages.size();
    }
    return total;
}

void Scanner::processNextFile()
{
    // No longer used - processing is handled by HashEngine callbacks
    // This method is kept for compatibility but should not be called
    qDebug() << "[Scanner] ‚ö†Ô∏è processNextFile() called - should use HashEngine callbacks instead";
}

// ‚ö° OPTIMIERUNG: Erstelle partielle Results f√ºr Anti-Hang Mechanismus
DuplicateGroups Scanner::buildPartialResults() {
    DuplicateGroups partialResults;
    
    qDebug() << "[Scanner] üîß Erstelle partielle Results f√ºr Anti-Hang...";
    
    // Sammle alle bereits gehashten Dateien mit identischen Hashes
    QHash<QString, QList<FileInfo>> hashGroups;
    
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup) {
            if (!file.hash.isEmpty() && 
                file.hash != "FTP_SKIPPED" && 
                file.hash != "FTP_DOWNLOAD_FAILED" &&
                file.hash != "GPU_ERROR") {
                hashGroups[file.hash].append(file);
            }
        }
    }
    
    // Erstelle DuplicateGroups aus Hash-Matches
    for (auto hashIt = hashGroups.begin(); hashIt != hashGroups.end(); ++hashIt) {
        const QString &hash = hashIt.key();
        const QList<FileInfo> &files = hashIt.value();
        if (files.size() > 1) {
            DuplicateGroup group;
            group.hash = hash;
            group.size = files.first().size;
            
            // Bestimme Original (√§lteste Datei)
            FileInfo oldest = files.first();
            for (const FileInfo &file : files) {
                if (file.lastModified < oldest.lastModified) {
                    oldest = file;
                }
            }
            
            group.original = oldest;
            for (const FileInfo &file : files) {
                if (file.filePath != oldest.filePath) {
                    group.duplicates.append(file);
                }
            }
            
            if (!group.duplicates.isEmpty()) {
                partialResults.groups.append(group);
            }
        }
    }
    
    // Statistiken berechnen - nur ECHTE Duplikat-Kandidaten z√§hlen
    int totalFilesInSizeGroups = 0;
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        totalFilesInSizeGroups += groupIt.value().size();
    }
    
    partialResults.totalFiles = totalFilesInSizeGroups; // ‚úÖ NUR Duplikat-Kandidaten z√§hlen!
    partialResults.duplicateFiles = 0;
    partialResults.duplicateSize = 0;
    for (const auto &grp : partialResults.groups) {
        partialResults.duplicateFiles += grp.duplicates.size();
        partialResults.duplicateSize += grp.size * grp.duplicates.size();
    }
    qDebug() << "[Scanner] ‚úÖ Partielle Results:" << partialResults.groups.size() << "Duplikat-Gruppen erstellt"
             << "Duplikat-Kandidaten (nur gleiche Gr√∂√üen):" << totalFilesInSizeGroups
             << "Echte Duplikat-Dateien:" << partialResults.duplicateFiles
             << "Gesparte Gr√∂√üe:" << partialResults.duplicateSize;
    return partialResults;
}

// ‚ö° OPTIMIERUNG: Cache-Processing f√ºr FTP-Dateien
void Scanner::processCachedFtpFiles(const QString &ftpDirectory, const QStringList &files, QSet<QString> &processedFiles) {
    qDebug() << "[Scanner] ‚ö° Verarbeite" << files.size() << "gecachte FTP-Dateien f√ºr:" << ftpDirectory;
    
    for (const QString &entry : files) {
        QString fileName = entry; // mutable copy
        if (processedFiles.contains(fileName)) continue; // Skip bereits verarbeitete Dateien

        QString originalEntry = fileName;
        qint64 parsedSize = -1;
        if (fileName.contains('|')) {
            int sep = fileName.lastIndexOf('|');
            QString sizePart = fileName.mid(sep + 1).trimmed();
            QString namePart = fileName.left(sep).trimmed();
            bool okSize = false;
            qint64 sz = sizePart.toLongLong(&okSize);
            if (okSize && sz >= 0) {
                parsedSize = sz;
                fileName = namePart; // use pure filename onward
                qDebug() << "[Scanner] üìè FTP-Eintrag mit Gr√∂√üe erkannt:" << originalEntry << "‚Üí Name=" << fileName << "Size=" << parsedSize;
            } else {
                qDebug() << "[Scanner] ‚ö†Ô∏è Ung√ºltige Size-Variante ignoriert, verwende Eintrag als Name:" << originalEntry;
            }
        }

        // FTP cached entries are names, not local paths; build proper URL
    QString fullPath = ftpDirectory;
        if (!fullPath.endsWith('/')) fullPath += '/';
    fullPath += fileName;

        // Falls derselbe Pfad bereits ohne Gr√∂√üe aufgenommen wurde und wir jetzt eine Gr√∂√üe haben ‚Üí aktualisieren
        bool updatedExisting = false;
        if (parsedSize >= 0) {
            for (FileInfo &existing : allFiles) {
                if (!existing.isLocal && existing.filePath == fullPath && existing.size == 0) {
                    existing.size = parsedSize;
                    updatedExisting = true;
                    qDebug() << "[Scanner] üîÑ Aktualisiere bestehendes FTP-File mit echter Gr√∂√üe:" << fullPath << "‚Üí" << parsedSize;
                    break;
                }
            }
        }

        if (updatedExisting) {
            processedFiles.insert(fileName);
            continue; // Gr√∂√üe aktualisiert, kein neuer Eintrag n√∂tig
        }

        FileInfo info;
    info.filePath = fullPath;
    info.fileName = fileName;
        info.size = (parsedSize >= 0) ? parsedSize : 0; // 0 bleibt Fallback, wird sonst gleich behandelt
        info.lastModified = QDateTime::currentSecsSinceEpoch();
        info.hash = "";
        info.isLocal = false;
        info.networkType = "FTP";

        allFiles.append(info);
    processedFiles.insert(fileName);
    }
    
    // ‚úÖ FIXED: Continue with async directory processing instead of dual calls
    if (scanning.load()) {
        qDebug() << "[Scanner] üîÑ FTP-Cache verarbeitet, setze async directory processing fort...";
        QTimer::singleShot(50, this, &Scanner::processNextDirectoryChunk);
    }
}

// ‚ö° OPTIMIERUNG: FTP-Client Pool f√ºr Connection-Reuse
FtpClient* Scanner::getOrCreateFtpClient(const QString &host) {
    static QHash<QString, FtpClient*> clientPool;
    
    if (!clientPool.contains(host)) {
        qDebug() << "[Scanner] üîó Erstelle neuen FTP-Client f√ºr:" << host;
        FtpClient *client = new FtpClient(this);
        clientPool[host] = client;
        return client;
    }
    
    qDebug() << "[Scanner] ‚ôªÔ∏è Wiederverwendung FTP-Client f√ºr:" << host;
    return clientPool[host];
}

// ‚ö° FALLBACK: Default-Credentials wenn PresetManager fehlt
void Scanner::useDefaultFtpCredentials(FtpClient *client, const QString &host) {
    qDebug() << "[Scanner] üîë Verwende Default-Credentials f√ºr:" << host;
    
    // Standard FTP-Credentials (Anonymous oder h√§ufige Kombinationen)
    QStringList commonUsers = {"ftp", "anonymous", "guest", "user", "admin"};
    QStringList commonPasses = {"", "anonymous", "guest", "password", "admin"};
    
    // Verwende erste Kombination als Default
    client->setCredentials(host, 21, commonUsers.first(), commonPasses.first());
}

// ‚úÖ Asynchrone Dateisammlung - GUI-responsive und crash-sicher
void Scanner::startAsyncFileCollection() {
    qDebug() << "[Scanner] üöÄ Starte asynchrone Dateisammlung f√ºr" << scanDirectories.size() << "Verzeichnisse";
    
    // Reset state
    directoriesToProcess.clear();
    cleanupFileCollection();
    allFiles.clear();
    processedFiles.clear();
    currentDirectoryIndex = 0;
    filesFoundInCurrentDir = 0;
    
    // F√ºlle die Queue mit zu verarbeitenden Verzeichnissen
    for (const QString &dir : scanDirectories) {
        directoriesToProcess.enqueue(dir);
    }
    
    emit scanStatusChanged(QString("Sammle Dateien aus %1 Verzeichnissen...").arg(directoriesToProcess.size()));
    
    // Starte den Timer f√ºr asynchrone Verarbeitung
    if (!directoriesToProcess.isEmpty()) {
        fileCollectionTimer->start();
    } else {
        // Keine Verzeichnisse -> direkt zur Size-Filtering Phase
        filterBySize();
    }
}

void Scanner::processNextDirectoryChunk() {
    if (!scanning.load() || directoriesToProcess.isEmpty()) {
        // üîç CHECK: Sind noch FTP-Operationen ausstehend?
        if (!pendingFtpDirectories.isEmpty()) {
            qDebug() << "[Scanner] ‚è≥ Lokale Sammlung abgeschlossen, aber" << pendingFtpDirectories.size() << "FTP-Verzeichnisse noch ausstehend - warte...";
            emit scanStatusChanged(QString("üì° Warte auf %1 FTP-Verzeichnisse...").arg(pendingFtpDirectories.size()));
            return; // Wait for FTP completion
        }
        
        // Sammlung wirklich abgeschlossen (lokal + FTP)
        cleanupFileCollection();
        
        if (scanning.load()) {
            qDebug() << "[Scanner] ‚úÖ Dateisammlung abgeschlossen:" << allFiles.size() << "Dateien gefunden";
            emit scanStatusChanged(QString("Sammlung abgeschlossen: %1 Dateien gefunden").arg(allFiles.size()));
            
            // Weiter zur Size-Filtering Phase
            qDebug() << "[Scanner] üöÄ Starte QTimer::singleShot f√ºr filterBySize()";
            QTimer::singleShot(100, this, &Scanner::filterBySize);
            qDebug() << "[Scanner] üì° QTimer::singleShot aufgerufen, warte 100ms auf filterBySize()";
        }
        return;
    }
    
    // Verarbeite das n√§chste Verzeichnis oder chunk
    if (!currentDirIterator) {
        // Starte neues Verzeichnis
        QString currentDir = directoriesToProcess.dequeue();
        currentDirectoryIndex++;
        filesFoundInCurrentDir = 0;
        
        qDebug() << "[Scanner] üìÇ Bearbeite Verzeichnis" << currentDirectoryIndex << "/" 
                 << (currentDirectoryIndex + directoriesToProcess.size()) << ":" << currentDir;
        
        emit currentFileProcessing(
            QFileInfo(currentDir).fileName(),
            "üìÅ Sammle Dateien",
            currentDirectoryIndex,
            currentDirectoryIndex + directoriesToProcess.size()
        );
        
        if (isRemotePath(currentDir)) {
            // Remote-Verzeichnis - verwende entsprechende Client-Logik
            if (currentDir.startsWith("ftp://") || currentDir.startsWith("ftps://")) {
                collectFtpFiles(currentDir, processedFiles);
                // FTP ist asynchron - nach Completion wird processNextDirectoryChunk() automatisch fortgesetzt
            } else if (currentDir.startsWith("sftp://") || currentDir.startsWith("ssh://")) {
                // TODO: SFTP client integration
                qDebug() << "[Scanner] üöß SFTP support not yet implemented:" << currentDir;
                // For now, continue to next directory
                QTimer::singleShot(50, this, &Scanner::processNextDirectoryChunk);
            } else if (currentDir.startsWith("smb://") || currentDir.startsWith("cifs://")) {
                // TODO: SMB client integration
                qDebug() << "[Scanner] üöß SMB support not yet implemented:" << currentDir;
                // For now, continue to next directory
                QTimer::singleShot(50, this, &Scanner::processNextDirectoryChunk);
            } else {
                qDebug() << "[Scanner] ‚ö†Ô∏è Unsupported remote protocol:" << currentDir;
                // Continue to next directory
                QTimer::singleShot(50, this, &Scanner::processNextDirectoryChunk);
            }
            return;
        } else {
            // Lokales Verzeichnis - erstelle Iterator
            currentDirIterator = new QDirIterator(currentDir, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);
        }
    }
    
    // Verarbeite Chunk von Dateien (z.B. 20 Dateien pro Timer-Event)
    int filesProcessedInChunk = 0;
    const int MAX_FILES_PER_CHUNK = 20;
    
    while (currentDirIterator && currentDirIterator->hasNext() && filesProcessedInChunk < MAX_FILES_PER_CHUNK) {
        if (!scanning.load()) return;
        
        QString filePath = currentDirIterator->next();
        QFileInfo fileInfo(filePath);
        
        // üö´ VERZEICHNIS-FILTER: Duplikate d√ºrfen keine Verzeichnisse sein
        if (!fileInfo.isFile()) {
            qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Verzeichnis:" << filePath;
            filesProcessedInChunk++;
            continue;
        }
        
        // Normale Dateiverarbeitung
        QString canonicalPath = fileInfo.canonicalFilePath();
        if (canonicalPath.isEmpty()) {
            canonicalPath = fileInfo.absoluteFilePath();
        }
        
        if (processedFiles.contains(canonicalPath)) {
            filesProcessedInChunk++;
            continue;  // Skip duplicate
        }
        
        processedFiles.insert(canonicalPath);
        filesFoundInCurrentDir++;
        
        // Erstelle FileInfo
        FileInfo file;
        file.filePath = canonicalPath;
        file.fileName = fileInfo.fileName();
        file.size = fileInfo.size();
        file.lastModified = fileInfo.lastModified().toSecsSinceEpoch();
        file.isLocal = true;
        
        allFiles.append(file);
        filesProcessedInChunk++;
        
        // Progress update alle 100 Dateien
        if (allFiles.size() % 100 == 0) {
            emit processActivityUpdate(
                QString("üìä %1 Dateien gefunden").arg(allFiles.size()),
                QString("Aktuell: %1").arg(fileInfo.fileName())
            );
        }
    }
    
    // Pr√ºfe ob aktuelles Verzeichnis abgeschlossen ist
    if (currentDirIterator && !currentDirIterator->hasNext()) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
        
        qDebug() << "[Scanner] ‚úÖ Verzeichnis abgeschlossen:" << filesFoundInCurrentDir << "Dateien gefunden";
    }
}

void Scanner::cleanupFileCollection() {
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
    }
    
    if (currentDirIterator) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
    }
    
    directoriesToProcess.clear();
}

bool Scanner::isScanning() const { return scanning.load(); }
bool Scanner::isPaused() const { return paused.load(); }

// Missing slot implementations required for linking
void Scanner::onCollectionFinished()
{
    qDebug() << "[Scanner] ‚úÖ File collection completed";
    emit scanPhaseCompleted(COLLECTING);
    
    // Transition to next phase
    if (scanning.load()) {
        filterBySize();
    }
}

void Scanner::onFtpListFinished(const QStringList &allDirs, bool success)
{
    qDebug() << "[Scanner] üì° FTP list finished - Dirs:" << allDirs.size() << "Success:" << success;
    
    if (success) {
        // Process the received directories
        for (const QString &dir : allDirs) {
            if (!pendingFtpDirectories.contains(dir)) {
                pendingFtpDirectories.append(dir);
            }
        }
        qDebug() << "[Scanner] üìÇ Added" << allDirs.size() << "FTP directories to queue";
    } else {
        qWarning() << "[Scanner] ‚ùå FTP list failed";
    }
}

// üöÄ 8-ENGINE SYSTEM IMPLEMENTATION

void Scanner::initializeEnginePool()
{
    std::cout << "[Scanner] üöÄ Initialisiere 8-Engine Parallel Processing System..." << std::endl;
    
    // Clear any existing engines
    cleanupEnginePool();
    
    // Initialize 8 HashEngine instances
    for (int i = 0; i < maxEngines; ++i) {
        HashEngine *engine = new HashEngine(this);
        
        // Set unique engine ID for identification and debugging
        engine->setEngineId(i + 1);  // IDs 1-8 for easier debugging
        
        // Set up NPU manager for each engine if available
        if (npuManager) {
            engine->setPresetManager(presetManager);
        }
        
        // Connect signals for parallel processing
        connect(engine, &HashEngine::hashCalculated,
                this, [this](const QString &fileName, const QString &hash) {
                    FileInfo info;
                    info.filePath = fileName;
                    info.fileName = QFileInfo(fileName).fileName();
                    info.hash = hash;
                    info.isLocal = !fileName.startsWith("ftp://");
                    processHashResult(info, hash);
                }, Qt::QueuedConnection);
        
        // üîß CRITICAL FIX: Connect engine completion signal for coordination
        connect(engine, &HashEngine::allHashesCompleted,
                this, [this, i]() {
                    std::cout << "[Scanner] ‚úÖ Engine " << i << " hat alle Hashes abgeschlossen" << std::endl;
                    startNextEngineIfNeeded(i);
                }, Qt::QueuedConnection);
        
        enginePool.append(engine);
        std::cout << "[Scanner] ‚ö° Engine " << (i+1) << "/8 initialisiert" << std::endl;
    }
    
    // Initialize counters
    processedFilesCounter.store(0);
    completedEngines.store(0);
    currentFileIndex = 0;
    activeEngines = 0;
    
    std::cout << "[Scanner] ‚úÖ 8-Engine System bereit - " << enginePool.size() << " Engines verf√ºgbar" << std::endl;
}

void Scanner::cleanupEnginePool()
{
    std::cout << "[Scanner] üßπ Bereinige Engine Pool..." << std::endl;
    
    // Stop all engines
    stopAllEngines();
    
    // Delete all engines
    for (HashEngine *engine : enginePool) {
        if (engine) {
            engine->deleteLater();
        }
    }
    enginePool.clear();
    
    // Reset counters
    processedFilesCounter.store(0);
    completedEngines.store(0);
    currentFileIndex = 0;
    activeEngines = 0;
    
    std::cout << "[Scanner] ‚úÖ Engine Pool bereinigt" << std::endl;
}

QList<QList<FileInfo>> Scanner::createBalancedFileChunks(const QList<FileInfo> &files, int numEngines)
{
    std::cout << "[Scanner] üß† Erstelle " << numEngines << " balancierte Chunks f√ºr " << files.size() << " Dateien" << std::endl;
    
    if (files.isEmpty() || numEngines <= 0) {
        return QList<QList<FileInfo>>();
    }
    
    // Sort files by size (largest first) for better load balancing
    QList<FileInfo> sortedFiles = files;
    sortFilesBySize(sortedFiles);
    
    // Initialize chunks
    QList<QList<FileInfo>> chunks;
    QList<qint64> chunkSizes;
    
    for (int i = 0; i < numEngines; ++i) {
        chunks.append(QList<FileInfo>());
        chunkSizes.append(0);
    }
    
    // Distribute files using "largest remaining processing time" algorithm
    for (const FileInfo &file : sortedFiles) {
        // Find chunk with smallest total size
        int smallestChunkIndex = 0;
        qint64 smallestChunkSize = chunkSizes[0];
        
        for (int i = 1; i < numEngines; ++i) {
            if (chunkSizes[i] < smallestChunkSize) {
                smallestChunkSize = chunkSizes[i];
                smallestChunkIndex = i;
            }
        }
        
        // Add file to smallest chunk
        chunks[smallestChunkIndex].append(file);
        chunkSizes[smallestChunkIndex] += file.size;
    }
    
    // Log chunk distribution
    for (int i = 0; i < chunks.size(); ++i) {
        qint64 chunkSize = calculateChunkSize(chunks[i]);
        std::cout << "[Scanner] üìä Engine " << (i+1) << ": " << chunks[i].size() 
                  << " Dateien, " << (chunkSize / 1024 / 1024) << " MB" << std::endl;
    }
    
    return chunks;
}

void Scanner::sortFilesBySize(QList<FileInfo> &files)
{
    std::sort(files.begin(), files.end(), [](const FileInfo &a, const FileInfo &b) {
        return a.size > b.size; // Largest first
    });
}

qint64 Scanner::calculateChunkSize(const QList<FileInfo> &chunk)
{
    qint64 totalSize = 0;
    for (const FileInfo &file : chunk) {
        totalSize += file.size;
    }
    return totalSize;
}

void Scanner::startNextEngineIfNeeded(int completedEngineIndex)
{
    QMutexLocker locker(&filesMutex);
    
    std::cout << "[Scanner] üéØ Engine " << completedEngineIndex << " abgeschlossen. Aktive Engines: " << activeEngines << std::endl;
    
    // Check if more files need processing
    if (currentFileIndex < allFiles.size() && activeEngines < maxEngines) {
        // Calculate next chunk
        int remainingFiles = allFiles.size() - currentFileIndex;
        int chunkSize = qMin(engineChunkSize, remainingFiles);
        
        if (chunkSize > 0) {
            // Find available engine
            for (int i = 0; i < enginePool.size(); ++i) {
                HashEngine *engine = enginePool[i];
                if (engine && !engine->isBusy()) { // Assuming isBusy() method exists
                    // Create file chunk
                    QList<FileInfo> chunk = allFiles.mid(currentFileIndex, chunkSize);
                    
                    // Start processing chunk
                    QStringList filePaths;
                    for (const FileInfo &file : chunk) {
                        filePaths.append(file.filePath);
                    }
                    
                    std::cout << "[Scanner] üöÄ Engine " << i << " startet mit " << chunk.size() << " Dateien (ab Index " << currentFileIndex << ")" << std::endl;
                    
                    // Start engine processing
                    engine->calculateMultipleHashes(filePaths);
                    
                    currentFileIndex += chunkSize;
                    activeEngines++;
                    break;
                }
            }
        }
    }
    
    // Update completion counter
    int completed = completedEngines.fetch_add(1) + 1;
    if (activeEngines > 0) activeEngines--;
    
    // Check if all engines completed
    if (completed >= maxEngines || (currentFileIndex >= allFiles.size() && activeEngines == 0)) {
        std::cout << "[Scanner] ‚úÖ Alle Engines abgeschlossen. Starte Ergebnis-Zusammenf√ºhrung..." << std::endl;
        emitDuplicatesFound();
    } else {
        // Force completion after short delay if we have processed files and engines are quiet
        QTimer::singleShot(1000, this, [this, completed]() {
            if (completed > 0 && scanning.load()) {
                std::cout << "[Scanner] ‚è∞ Force completion - " << completed << " engines completed, finalizing..." << std::endl;
                emitDuplicatesFound();
            }
        });
    }
}

void Scanner::stopAllEngines()
{
    std::cout << "[Scanner] üõë Stoppe alle " << enginePool.size() << " Engines..." << std::endl;
    
    for (HashEngine *engine : enginePool) {
        if (engine) {
            // Stop engine processing (assuming stop method exists)
            engine->stop();
        }
    }
    
    activeEngines = 0;
    std::cout << "[Scanner] ‚úÖ Alle Engines gestoppt" << std::endl;
}

// üîß INTELLIGENT ORIGINAL SELECTION: Choose best file as original
FileInfo Scanner::selectBestOriginal(const QList<FileInfo> &files) 
{
    if (files.isEmpty()) {
        return FileInfo(); // Empty fallback
    }
    
    if (files.size() == 1) {
        return files.first(); // Only one file
    }
    
    FileInfo bestFile = files.first();
    int bestScore = calculateOriginalScore(bestFile);
    
    // Find file with highest score
    for (const FileInfo &file : files) {
        int score = calculateOriginalScore(file);
        if (score > bestScore) {
            bestScore = score;
            bestFile = file;
        }
    }
    
    qDebug() << "[Scanner] üéØ Original gew√§hlt:" << QFileInfo(bestFile.filePath).fileName() 
             << "Score:" << bestScore << "(von" << files.size() << "Dateien)";
    
    return bestFile;
}

// Calculate score for original selection (higher = better original)
int Scanner::calculateOriginalScore(const FileInfo &file) 
{
    int score = 0;
    
    // üèÜ PRIORITY 1: √ÑLTESTE DATEI ist Original (User-Anforderung)
    QFileInfo fileInfo(file.filePath);
    QDateTime lastModified = fileInfo.lastModified();
    
    // Je √§lter die Datei, desto h√∂her der Score (in Tagen seit Epoch)
    qint64 ageInDays = QDateTime::currentDateTime().daysTo(lastModified);
    score += (-ageInDays * 10); // Negative Tage = positive Score f√ºr alte Dateien
    
    // üèÜ PRIORITY 2: Avoid temp/cache directories
    QString path = file.filePath.toLower();
    if (path.contains("/tmp/") || path.contains("/cache/") || path.contains("temp")) {
        score -= 50; // Penalize temp files
    }
    
    // üèÜ PRIORITY 3: Prefer organized directory structures
    if (path.contains("/home/") && !path.contains("/tmp/")) {
        score += 25; // Bonus for home directory
    }
    
    // üèÜ PRIORITY 4: Prefer files with clear names (not random hashes)
    QString fileName = QFileInfo(file.filePath).fileName();
    if (fileName.length() > 10 && !fileName.contains(QRegularExpression("^[a-f0-9]{8,}")) ) {
        score += 10; // Bonus for descriptive names
    }
    
    qDebug() << "[Scanner] üìÖ Datei" << fileName << "- Alter:" << (-ageInDays) << "Tage, Score:" << score;
    
    return score;
}

void Scanner::emitDuplicatesFound()
{
    std::cout << "[Scanner] üéØ Erstelle finale Duplikate-Ergebnisse aus " << sharedHashGroups.size() << " Hash-Gruppen" << std::endl;
    
    QMutexLocker locker(&sharedHashGroupsMutex);
    
    DuplicateGroups finalResults;
    finalResults.groups.clear();
    
    // Process shared hash groups
    for (auto it = sharedHashGroups.begin(); it != sharedHashGroups.end(); ++it) {
        const QString &hash = it.key();
        const QList<FileInfo> &filesWithSameHash = it.value();
        
        if (filesWithSameHash.size() > 1) {
            DuplicateGroup group;
            group.hash = hash;
            group.size = filesWithSameHash.first().size;
            
            // üîß INTELLIGENT ORIGINAL SELECTION: Best file becomes original
            FileInfo bestOriginal = selectBestOriginal(filesWithSameHash);
            group.original = bestOriginal;
            
            // Add all other files as duplicates
            for (const FileInfo &file : filesWithSameHash) {
                if (file.filePath != bestOriginal.filePath) {
                    group.duplicates.append(file);
                }
            }
            
            // üö® KRITISCHER FIX: Nur Gruppen mit echten Duplikaten hinzuf√ºgen!
            // User will keine Unikate in der Liste - nur Original + mindestens 1 Duplikat
            if (group.duplicates.size() > 0) {
                finalResults.groups.append(group);
                qDebug() << "[Scanner] ‚úÖ Duplikat-Gruppe hinzugef√ºgt:" << group.original.filePath 
                         << "mit" << group.duplicates.size() << "Duplikaten";
            } else {
                qDebug() << "[Scanner] üö´ Unikat √ºbersprungen:" << bestOriginal.filePath 
                         << "(keine Duplikate gefunden)";
            }
        }
    }
    
    // ‚úÖ KORREKTE STATISTIK: Nur tats√§chlich untersuchte Duplikat-Kandidaten z√§hlen  
    int totalDuplicateCandidates = 0;
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        totalDuplicateCandidates += groupIt.value().size();
    }
    finalResults.totalFiles = totalDuplicateCandidates; // Nur Dateien mit m√∂glichen Duplikaten
    finalResults.duplicateFiles = 0;
    for (const DuplicateGroup &group : finalResults.groups) {
        finalResults.duplicateFiles += group.duplicates.size();
    }
    
    std::cout << "[Scanner] ‚úÖ 8-Engine Scan abgeschlossen: " << finalResults.groups.size() 
              << " Duplikat-Gruppen mit " << finalResults.duplicateFiles << " Duplikaten" << std::endl;
    
    scanning.store(false);
    currentPhase = COMPLETED;
    emit scanCompleted(finalResults);
}

void Scanner::processHashResult(const FileInfo &fileInfo, const QString &hash)
{
    QMutexLocker locker(&sharedHashGroupsMutex);
    
    // Add to shared hash groups (thread-safe)
    if (!sharedHashGroups.contains(hash)) {
        sharedHashGroups[hash] = QList<FileInfo>();
    }
    sharedHashGroups[hash].append(fileInfo);
    
    // Update progress counter
    int processed = processedFilesCounter.fetch_add(1) + 1;
    
    // Emit progress update
    if (totalFilesForHashing > 0) {
        int progressPercent = (processed * 100) / totalFilesForHashing;
        emit scanProgress(progressPercent, processed, totalFilesForHashing);
        
        if (processed % 100 == 0 || processed == totalFilesForHashing) {
            std::cout << "[Scanner] üìä 8-Engine Progress: " << processed << "/" << totalFilesForHashing 
                      << " (" << progressPercent << "%)" << std::endl;
        }
    }
}

// üåê MULTI-HOST FTP CONNECTION POOLING

void Scanner::setupMultiHostFtpConnectionPool(const QSet<QString> &ftpHosts)
{
    std::cout << "[Scanner] üåê Setup Multi-Host FTP Connection Pool f√ºr " << ftpHosts.size() << " Hosts" << std::endl;
    
    QMutexLocker locker(&ftpPoolsMutex);
    
    // Clean up existing pools
    cleanupFtpConnectionPools();
    
    // Create connection pools for each host
    for (const QString &host : ftpHosts) {
        QList<FtpClient*> hostPool;
        
        // Create multiple connections per host (up to maxConnectionsPerHost)
        for (int i = 0; i < maxConnectionsPerHost; ++i) {
            FtpClient *client = new FtpClient(this);
            
            // Set credentials (assuming they're stored)
            if (presetManager) {
                auto credentials = presetManager->getLogin(host, currentFtpPort);
                if (!credentials.username.isEmpty()) {
                    client->setCredentials(host, currentFtpPort, credentials.username, credentials.password);
                }
            }
            
            hostPool.append(client);
            std::cout << "[Scanner] üîó FTP Connection " << (i+1) << "/" << maxConnectionsPerHost 
                      << " erstellt f√ºr Host: " << host.toStdString() << std::endl;
        }
        
        ftpConnectionPools[host] = hostPool;
    }
    
    std::cout << "[Scanner] ‚úÖ FTP Connection Pool bereit: " << ftpHosts.size() << " Hosts, " 
              << (ftpHosts.size() * maxConnectionsPerHost) << " Connections total" << std::endl;
}

FtpClient* Scanner::getFtpClientForHost(const QString &host)
{
    QMutexLocker locker(&ftpPoolsMutex);
    
    if (!ftpConnectionPools.contains(host)) {
        std::cout << "[Scanner] ‚ö†Ô∏è Kein FTP Pool f√ºr Host: " << host.toStdString() << std::endl;
        return nullptr;
    }
    
    QList<FtpClient*> &hostPool = ftpConnectionPools[host];
    
    // Find available client in pool
    for (FtpClient *client : hostPool) {
        if (client) { // All clients in pool are available
            std::cout << "[Scanner] üì° FTP Client ausgeliehen f√ºr Host: " << host.toStdString() << std::endl;
            return client;
        }
    }
    
    std::cout << "[Scanner] ‚ö†Ô∏è Alle FTP Clients f√ºr Host " << host.toStdString() << " sind besch√§ftigt" << std::endl;
    return nullptr;
}

void Scanner::returnFtpClientToPool(const QString &host, FtpClient *client)
{
    Q_UNUSED(host)
    Q_UNUSED(client)
    
    // Client is automatically returned to pool when it becomes not busy
    std::cout << "[Scanner] üîÑ FTP Client zur√ºckgegeben an Pool f√ºr Host: " << host.toStdString() << std::endl;
}

void Scanner::cleanupFtpConnectionPools()
{
    std::cout << "[Scanner] üßπ Bereinige FTP Connection Pools (async)..." << std::endl;
    
    QMutexLocker locker(&ftpPoolsMutex);
    
    // ‚úÖ DEADLOCK FIX: Verwende async cleanup statt deleteLater()
    for (auto it = ftpConnectionPools.begin(); it != ftpConnectionPools.end(); ++it) {
        QList<FtpClient*> &hostPool = it.value();
        
        for (FtpClient *client : hostPool) {
            if (client) {
                // ‚ö° INSTANT CLEANUP: Direkte L√∂schung statt deleteLater()
                client->disconnect(); // Disconnect signals first
                delete client;        // Direct delete - no event loop needed
            }
        }
        hostPool.clear();
    }
    
    ftpConnectionPools.clear();
    std::cout << "[Scanner] ‚úÖ FTP Connection Pools SOFORT bereinigt (deadlock-free)" << std::endl;
}
