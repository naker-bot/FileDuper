#include "scanner.h"
#include "hashengine.h"
#include "presetmanager.h"
#include "ftpclient.h"
#include "sftpclient.h"          // ‚úÖ SFTP Client Include
#include "smbclient.h"           // ‚úÖ SMB Client Include
#include "nfsclient.h"           // ‚úÖ NFS Client Include
#include "hardwarebenchmark.h"   // ‚ö° Hardware Auto-Detect & Optimization
#include <QApplication>
#include <QDebug>
#include <QDir>
#include <QDirIterator>
#include <QDateTime>
#include <QCryptographicHash>
#include <QFileInfo>
#include <QUrl>
#include <QFile>
#include <QStandardPaths>
#include <iostream>

Scanner::Scanner(QObject *parent)
    : QObject(parent), hashEngine(nullptr), presetManager(nullptr), ftpClient(nullptr), 
      sftpClient(nullptr), smbClient(nullptr), nfsClient(nullptr), npuManager(nullptr),
      scanning(false), paused(false), currentPhase(IDLE), ftpDirectoriesProcessed(0),
      currentSimilarityMode(NpuManager::NEAR_DUPLICATES)  // Default: Sehr √§hnliche Bilder
{
    std::cout << "[Scanner] Scanner initialisiert" << std::endl;
    
    // THREADPOOL: Setze auf 200 parallele Worker f√ºr FTP-Operationen
    QThreadPool::globalInstance()->setMaxThreadCount(200);
    QThreadPool::globalInstance()->setExpiryTimeout(-1);  // Threads bleiben IMMER aktiv!
    qDebug() << "[Scanner] QThreadPool konfiguriert: 200 parallele Worker (persistent)";
    
    // HARDWARE AUTO-DETECT: Erkenne und optimiere f√ºr aktuelle Hardware
    HardwareBenchmark *benchmark = new HardwareBenchmark(this);
    connect(benchmark, &HardwareBenchmark::benchmarkProgress, this, 
            [](const QString &msg, int progress) {
        qDebug() << "[Scanner] üîß" << progress << "%" << msg;
    });
    
    hardwareCaps = benchmark->detectAndBenchmark();
    
    // Wende Hardware-optimierte Einstellungen an
    maxParallelFtpScans = hardwareCaps.maxParallelFtpScans;
    
    // üöÄ OPTIMIERUNG 2 & 3: Aktiviere Smart Features basierend auf Hardware
    if (hardwareCaps.hasNPU) {
        useNpuForHashing = true;
        qDebug() << "   üß† NPU-Hash-Beschleunigung: AKTIVIERT";
    }
    if (hardwareCaps.hasGPU) {
        useGpuForHashing = true;
        qDebug() << "   üéÆ GPU-Hash-Beschleunigung: AKTIVIERT";
    }
    if (hardwareCaps.ioScore > 80) {
        minFileSizeForHashing = 512;  // Super-SSD: Auch kleinere Dateien hashen
        qDebug() << "   ‚ö° Smart Pre-Filter: 512 Bytes (SSD-optimiert)";
    } else {
        minFileSizeForHashing = 2048;  // Normale HDD: Nur gr√∂√üere Dateien
        qDebug() << "   ‚ö° Smart Pre-Filter: 2048 Bytes (HDD-optimiert)";
    }
    
    qDebug() << "[Scanner] ‚ö° Optimiert f√ºr Hardware:";
    qDebug() << "   üî¢ CPU-Kerne:" << hardwareCaps.cpuCores;
    qDebug() << "   üíæ RAM:" << hardwareCaps.availableRamMB << "MB";
    qDebug() << "   üß† NPU:" << (hardwareCaps.hasNPU ? "Verf√ºgbar ‚úÖ" : "Nicht verf√ºgbar ‚ùå");
    qDebug() << "   üéÆ GPU:" << (hardwareCaps.hasGPU ? hardwareCaps.gpuName + " ‚úÖ" : "Nicht verf√ºgbar ‚ùå");
    qDebug() << "   üì° Parallele FTP-Scans:" << maxParallelFtpScans;
    qDebug() << "   üîê Paralleles Hashing:" << hardwareCaps.maxParallelHashing;
    qDebug() << "   üí™ CPU Score:" << hardwareCaps.cpuScore << "/100";
    qDebug() << "   üíø I/O Score:" << hardwareCaps.ioScore << "/100";
    qDebug() << "   üì∂ Network Score:" << hardwareCaps.networkScore << "/100";

    // üîê SCAN-HISTORY: Lade persistente History beim Start
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
    scanHistoryFile = configPath + "/.fileduper_scan_history.dat";
    loadScanHistory();
    qDebug() << "[Scanner] üìú Scan-History geladen:" << scannedDirectoriesHistory.size() << "Verzeichnisse," 
             << scannedFilesHistory.size() << "Dateien";

    // Ultra-responsive Timer f√ºr GUI
    processTimer = new QTimer(this);
    processTimer->setSingleShot(false);
    processTimer->setInterval(25); // 25ms = 40 FPS f√ºr fl√ºssige GUI
    connect(processTimer, &QTimer::timeout, this, &Scanner::processNextFile);

    // ‚úÖ Asynchroner Timer f√ºr Dateisammlung - verhindert GUI-Blockierung
    fileCollectionTimer = new QTimer(this);
    fileCollectionTimer->setSingleShot(false);
    fileCollectionTimer->setInterval(50); // 50ms = 20 FPS f√ºr responsive Dateisammlung
    connect(fileCollectionTimer, &QTimer::timeout, this, &Scanner::processNextDirectoryChunk);

    // üöÄ FTP Queue Drain Timer: Periodically check FTP queue and start new scans
    ftpQueueDrainTimer = new QTimer(this);
    ftpQueueDrainTimer->setSingleShot(false);
    ftpQueueDrainTimer->setInterval(200); // Check every 200ms
    connect(ftpQueueDrainTimer, &QTimer::timeout, this, [this]() {
        // Check all hosts with queued directories
        for (auto it = ftpQueuePerHost.begin(); it != ftpQueuePerHost.end(); ++it) {
            QString host = it.key();
            if (it.value().isEmpty()) continue;
            
            int currentActive = activeFtpScansPerHost.value(host, 0);
            int queueSize = it.value().size();
            
            // ÔøΩüöÄ DISCOVERY-MODUS: SEHR HOHE PARALLELIT√ÑT (500 statt 50)
            int adaptiveLimit = maxParallelFtpScans;
            if (ftpDiscoveryPhase) {
                adaptiveLimit = 500;  // Discovery kann 500 parallel
            } else if (queueSize > 2000) {
                adaptiveLimit = maxParallelFtpScans * 5 / 4;  // 125%
            } else if (queueSize > 1000) {
                adaptiveLimit = maxParallelFtpScans * 9 / 8;  // 112.5%
            }
            adaptiveLimit = qMin(adaptiveLimit, ftpDiscoveryPhase ? 500 : 75);
            
            // ÔøΩüîç DEBUG: Log IMMER wenn Queue nicht leer (alle 50 Checks = 10 Sekunden)
            static int timerCheckCount = 0;
            timerCheckCount++;
            if (queueSize > 0 && timerCheckCount % 50 == 0) {
                qDebug() << "[FTP-Timer] üìä Check #" << timerCheckCount << "| Queue:" << queueSize 
                         << "| Active:" << currentActive << "/" << adaptiveLimit 
                         << (ftpDiscoveryPhase ? " (DISCOVERY-500)" : " (SCAN-75)");
            }
            
            // Start new scans if below limit
            if (currentActive < adaptiveLimit && queueSize > 0) {
                int availableSlots = adaptiveLimit - currentActive;
                int maxBatch = (queueSize > 2000) ? 30 : (queueSize > 1000) ? 20 : 15;
                int batchSize = qMin(availableSlots, qMin(queueSize, maxBatch));
                
                qDebug() << "[FTP-Timer] üîÑ Queue-Drain f√ºr" << host << ":" << batchSize << "neue Scans | Queue:" << queueSize << "| Active:" << currentActive << "/" << adaptiveLimit;
                
                for (int i = 0; i < batchSize && !ftpQueuePerHost[host].isEmpty(); ++i) {
                    QString nextDir = ftpQueuePerHost[host].takeFirst();
                    collectFtpFiles(nextDir, this->processedFiles, true);
                }
            }
        }
    });

    // Initialisiere Pfad-Deduplicator f√ºr optimierte Verarbeitung
}

Scanner::~Scanner()
{
    stopScan();
}

void Scanner::setHashEngine(HashEngine *engine)
{
    hashEngine = engine;
    if (hashEngine)
    {
        connect(hashEngine, &HashEngine::hashCalculated,
                this, &Scanner::onHashCalculated);
    }
}

void Scanner::setPresetManager(PresetManager *manager)
{
    presetManager = manager;
}

void Scanner::setFtpClient(FtpClient *client)
{
    // Disconnect previous client safely to avoid duplicate signal deliveries
    if (ftpClient) {
        QObject::disconnect(ftpClient, nullptr, this, nullptr);
    }
    ftpClient = client;
    // Note: We intentionally do NOT connect filesListFinished here.
    // Per-host clients created in collectFtpFiles() are connected with a
    // scoped lambda using Qt::UniqueConnection to avoid double-processing
    // and race conditions when multiple FTP directories are scanned.
}

// üß† NPU-INTEGRATION: NPU-Manager f√ºr intelligente Bildverarbeitung
void Scanner::setNpuManager(NpuManager *manager)
{
    npuManager = manager;
    if (npuManager)
    {
        connect(npuManager, &NpuManager::imageBatchProcessed,
                this, &Scanner::onNpuImageBatchProcessed);
        qDebug() << "[Scanner] üß† NPU-Manager f√ºr Bildverarbeitung verbunden";
    }
}

void Scanner::setNpuEnabled(bool enabled)
{
    npuEnabled = enabled;
    qDebug() << "[Scanner] üß† NPU enabled set to" << npuEnabled;
}

void Scanner::startScan(const QStringList &directories, const QString &hashAlgorithm, const QString &fileFilter)
{
    qDebug() << "[Scanner] üöÄ startScan aufgerufen mit" << directories.size() << "Verzeichnissen:" << directories;
    qDebug() << "[Scanner] Hash-Algorithmus:" << hashAlgorithm << "FileFilter:" << fileFilter;
    qDebug() << "[Scanner] üß† NPU enabled?" << npuEnabled << "(Hash-only when false)";

    // üìä SOFORTIGER PROGRESS-UPDATE: Scan-Initialisierung
    emit scanProgress(0, 0, directories.size());
    emit scanStatusChanged(QString("üîç Initialisiere Scan f√ºr %1 Verzeichnisse...").arg(directories.size()));
    emit currentFileProcessing("Initialisierung", "üîç Scan-Vorbereitung", 0, directories.size());
    emit processActivityUpdate("üîç Starte Duplikat-Scan", QString("Bereite %1 Verzeichnisse vor").arg(directories.size()));

    // Defensive pointer checks (log-only, allow scan to proceed where possible)
    if (!hashEngine) qWarning() << "[Scanner] ‚ö†Ô∏è hashEngine ist null ‚Äì Hashing wird sp√§ter eventuell √ºbersprungen.";
    if (!presetManager) qWarning() << "[Scanner] ‚ö†Ô∏è presetManager ist null ‚Äì FTP-Logins verwenden Default-Credentials.";

    // üß† NPU-Counter zur√ºcksetzen bei neuem Scan
    npuProcessedImages = 0;
    qDebug() << "[Scanner] üîÑ NPU-Counter zur√ºckgesetzt f√ºr neuen Scan";

    // ‚úÖ FIX: Clear processed files cache f√ºr neuen Scan
    if (hashEngine) {
        hashEngine->clearProcessedFiles();
        qDebug() << "[Scanner] üßπ HashEngine processed files cache geleert";
    }

    // üî• CRITICAL FIX: L√∂sche Scan-History bei jedem neuen Scan!
    // Andernfalls werden alle Verzeichnisse als "bereits gescannt" √ºbersprungen
    clearScanHistory();
    qDebug() << "[Scanner] üóëÔ∏è Scan-History gel√∂scht f√ºr neuen Scan";

    // ‚úÖ FIX: Pr√ºfe ob bereits ein Scan l√§uft
    if (scanning.load()) {
        qDebug() << "[Scanner] ‚è∏Ô∏è Stoppe vorherigen Scan, starte neuen...";
        stopScan(); // Stoppe aktuellen Scan
        scanning.store(false); // Reset scanning state
    }

    if (directories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå Keine Verzeichnisse zum Scannen!";
        emit scanProgress(100, 0, 0);
        emit scanStatusChanged("‚ùå Keine Verzeichnisse ausgew√§hlt - Scan abgebrochen");
        // ‚ö†Ô∏è WICHTIG: Emittiere KEIN scanCompleted - Scan wurde nicht gestartet!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT - verwirrt GUI
        return;
    }
    
    // üîê HISTORY-CHECK: Filtere bereits gescannte Verzeichnisse
    QStringList newDirectories;
    QStringList skippedDirectories;
    
    for (const QString &dir : directories) {
        if (isDirectoryInHistory(dir)) {
            skippedDirectories.append(dir);
            qDebug() << "[Scanner] ‚è≠Ô∏è √úberspringe bereits gescanntes Verzeichnis:" << dir;
        } else {
            newDirectories.append(dir);
        }
    }
    
    if (!skippedDirectories.isEmpty()) {
        qDebug() << "[Scanner] üìú History-Filter:" << skippedDirectories.size() << "√ºbersprungen," 
                 << newDirectories.size() << "neu";
        // ‚úÖ Zeige Info nur wenn auch neue Verzeichnisse da sind
        if (!newDirectories.isEmpty()) {
            emit scanStatusChanged(QString("üîç Starte Scan (%1 neu, %2 √ºbersprungen)").arg(newDirectories.size()).arg(skippedDirectories.size()));
        }
    }
    
    if (newDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Alle Verzeichnisse bereits in History - nichts zu tun!";
        emit scanProgress(100, 0, 0);
        emit scanStatusChanged("‚è≠Ô∏è Alle Verzeichnisse bereits gescannt - nichts zu tun!");
        emit currentFileProcessing("Keine neuen Verzeichnisse", "‚úÖ Alle bereits gescannt", 0, 0);
        // ‚ö†Ô∏è WICHTIG: Emittiere KEIN scanCompleted - w√ºrde "0 Duplikate" anzeigen!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT
        return;
    }
    
    // ‚úÖ WICHTIG: Status f√ºr aktiven Scan setzen
    emit scanStatusChanged(QString("üîç Starte Duplikat-Scan mit %1 Verzeichnissen...").arg(newDirectories.size()));
    // ‚úÖ NEU: Separiere lokale und FTP-Pfade f√ºr parallele Verarbeitung
    QStringList localDirectories;
    QStringList ftpDirectories;
    
    for (const QString &dir : newDirectories) {  // ‚úÖ USE newDirectories (history-filtered)
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            ftpDirectories.append(dir);
        } else {
            localDirectories.append(dir);
        }
    }
    
    qDebug() << "[Scanner] üìÇ Lokale Verzeichnisse:" << localDirectories.size();
    qDebug() << "[Scanner] üì° Netzwerk-Verzeichnisse:" << ftpDirectories.size();

    // Deduplicate directories to prevent redundant work
    QStringList optimizedDirectories = deduplicateDirectories(newDirectories);  // ‚úÖ USE newDirectories
    
    if (optimizedDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚ùå Nach Pfad-Optimierung keine Verzeichnisse √ºbrig!";
        emit scanStatusChanged("‚ö†Ô∏è Pfad-Optimierung: Alle Verzeichnisse redundant");
        // ‚ö†Ô∏è WICHTIG: KEIN scanCompleted - Scan wurde nicht gestartet!
        // emit scanCompleted(DuplicateGroups{});  // DEAKTIVIERT
        return;
    }

    scanDirectories = optimizedDirectories;
    currentHashAlgorithm = hashAlgorithm;
    currentFileFilter = fileFilter;

    // üõ°Ô∏è KRITISCH: Deduplication-Caches f√ºr NEUEN Scan zur√ºcksetzen
    clearDeduplicationCaches();
    
    // üîê F√ºge neue Verzeichnisse zur History hinzu
    for (const QString &dir : optimizedDirectories) {
        addToScanHistory(dir, true);
    }
    qDebug() << "[Scanner] üîÑ Neuer Scan gestartet - Deduplication-Caches zur√ºckgesetzt";

    // Reset state
    allFiles.clear();
    fileSizeGroups.clear();
    hashGroups.clear();
    
    // üî• KRITISCH: Reset m_totalCollectedFiles f√ºr neuen Scan
    m_totalCollectedFiles = 0;

    scanning.store(true);
    paused.store(false);
    currentPhase = COLLECTING;
    
    // üî• GUARD FLAG RESET: Erlaube neue scanCompleted-Emission f√ºr diesen Scan
    m_scanCompletedEmitted.store(false);

    qDebug() << "[Scanner] üîç Pfad-Optimierung:" << directories.size()
              << "‚Üí" << optimizedDirectories.size() << "Verzeichnisse";
    emit scanStatusChanged("Sammle Dateien (parallel: lokal + netzwerk)...");

    // üöÄ START FTP QUEUE DRAIN TIMER: Falls bereits Queue existiert (z.B. nach Neustart)
    bool hasQueuedFtpDirs = false;
    for (auto it = ftpQueuePerHost.begin(); it != ftpQueuePerHost.end(); ++it) {
        if (!it.value().isEmpty()) {
            hasQueuedFtpDirs = true;
            break;
        }
    }
    if (hasQueuedFtpDirs && ftpQueueDrainTimer && !ftpQueueDrainTimer->isActive()) {
        ftpQueueDrainTimer->start();
        qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestartet (existierende Queue gefunden)";
    }

    // ‚ö° ASYNC via QTimer: Already non-blocking - timers run in GUI event loop
    // QtConcurrent wurde entfernt weil QTimer nicht aus Worker-Thread gestartet werden kann
    startAsyncFileCollection();
}

QStringList Scanner::deduplicateDirectories(const QStringList &directories)
{
    QSet<QString> canonicalPaths;
    QStringList result;

    // Convert all paths to canonical form (handle both local and FTP paths)
    QMap<QString, QString> originalToCanonical;
    for (const QString &dir : directories)
    {
        QString canonical;
        
        // üõ°Ô∏è CRASH-FIX: SAFE URL/path handling f√ºr FTP und lokale Pfade
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            canonical = dir; // FTP/Network paths bleiben unver√§ndert
            qDebug() << "[Scanner] üì° Network-URL beibehalten:" << canonical;
        } else {
            // SAFE: Nur auf lokale Pfade canonicalPath() anwenden
            QDir dirObj(dir);
            if (dirObj.exists()) {
                canonical = dirObj.canonicalPath();
                qDebug() << "[Scanner] üìÇ Lokaler Pfad kanonisch:" << canonical;
            } else {
                canonical = dir; // Falls nicht existiert, Original beibehalten
                qDebug() << "[Scanner] ‚ö†Ô∏è Pfad existiert nicht, Original beibehalten:" << canonical;
            }
        }
        
        if (!canonical.isEmpty())
        {
            originalToCanonical[dir] = canonical;
        }
    }

    // Remove parent-child relationships and duplicates
    for (auto it = originalToCanonical.begin(); it != originalToCanonical.end(); ++it)
    {
        QString currentPath = it.value();
        bool isRedundant = false;

        // ‚úÖ FIX: √úberspringe Deduplication f√ºr FTP/Netzwerk-Pfade
        if (currentPath.startsWith("ftp://") || currentPath.startsWith("sftp://") || currentPath.startsWith("smb://")) {
            canonicalPaths.insert(currentPath);
            result.append(it.key());
            qDebug() << "[Scanner] üì° Network-Pfad hinzugef√ºgt ohne Deduplication:" << currentPath;
            continue; // √úberspringe Parent-Child-Pr√ºfung f√ºr Netzwerk-Pfade
        }

        // Check if this path is a child of any already processed path (nur f√ºr lokale Pfade)
        for (const QString &existingPath : canonicalPaths)
        {
            // √úberspringe Vergleich mit Netzwerk-Pfaden
            if (existingPath.startsWith("ftp://") || existingPath.startsWith("sftp://") || existingPath.startsWith("smb://")) {
                continue;
            }
            
            if (currentPath.startsWith(existingPath + "/"))
            {
                isRedundant = true;
                std::cout << "‚è≠Ô∏è  √úberspringe Unterverzeichnis: " << it.key().toLocal8Bit().constData()
                          << " (enthalten in " << existingPath.toLocal8Bit().constData() << ")" << std::endl;
                break;
            }
        }

        if (!isRedundant)
        {
            // Remove any existing paths that are children of the current path
            auto existing = canonicalPaths.begin();
            while (existing != canonicalPaths.end())
            {
                if (existing->startsWith(currentPath + "/"))
                {
                    std::cout << "üîÑ Ersetze Unterverzeichnis " << existing->toLocal8Bit().constData()
                              << " durch Elternverzeichnis " << currentPath.toLocal8Bit().constData() << std::endl;
                    existing = canonicalPaths.erase(existing);
                }
                else
                {
                    ++existing;
                }
            }

            canonicalPaths.insert(currentPath);
            result.append(it.key());
        }
    }

    return result;
}
void Scanner::stopScan()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] ‚èπÔ∏è FORCE-STOP: Stoppe alle Scan-Aktivit√§ten";
    
    scanning.store(false);
    paused.store(false);
    currentPhase = IDLE;
    
    // ‚úÖ KRITISCH: Stoppe alle Timer
    if (processTimer) {
        processTimer->stop();
        qDebug() << "[Scanner] üõë ProcessTimer gestoppt";
    }
    
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
        qDebug() << "[Scanner] üõë FileCollectionTimer gestoppt";
    }
    
    if (ftpQueueDrainTimer && ftpQueueDrainTimer->isActive()) {
        ftpQueueDrainTimer->stop();
        qDebug() << "[Scanner] üõë FTP-Queue-Drain-Timer gestoppt (Scan abgebrochen)";
    }
    
    // ‚úÖ Cleanup asynchrone Dateisammlung
    cleanupFileCollection();
    
    // ‚úÖ KRITISCH: Stoppe HashEngine
    if (hashEngine) {
        // Hier k√∂nnten wir hashEngine->stopCalculation() aufrufen
        hashEngine->clearProcessedFiles(); // üõ°Ô∏è CRITICAL: Clear to prevent infinite loops
        qDebug() << "[Scanner] üõë HashEngine-Stop signalisiert und Cache geleert";
    }
    
    // ‚úÖ KRITISCH: Leere alle Collections f√ºr sauberen Stop
    allFiles.clear();
    hashGroups.clear();
    fileSizeGroups.clear();
    
    // üõ°Ô∏è NEU: Deduplication-Caches leeren bei Scan-Stop
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    
    qDebug() << "[Scanner] üßπ Alle Collections geleert";
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert";
    
    emit scanStatusChanged("‚èπÔ∏è Scan gestoppt - alle Prozesse beendet");
    std::cout << "‚èπÔ∏è Duplikat-Scan vollst√§ndig gestoppt" << std::endl;
    
    // ‚úÖ KRITISCH: Emittiere leere Ergebnisse um GUI zu clearen (nur einmal)
    if (!m_scanCompletedEmitted.exchange(true)) {
        DuplicateGroups emptyResults;
        emit scanCompleted(emptyResults);
        qDebug() << "[Scanner] üî• EMIT scanCompleted (STOP) - totalFiles: 0";
    }
}

void Scanner::pauseScan()
{
    if (!scanning.load())
        return;

    paused.store(true);
    processTimer->stop();
    emit scanStatusChanged("Scan pausiert");
    std::cout << "‚è∏Ô∏è Duplikat-Scan pausiert" << std::endl;
}

void Scanner::resumeScan()
{
    if (!scanning.load() || !paused.load())
        return;

    paused.store(false);
    processTimer->start();
    emit scanStatusChanged("Scan fortgesetzt");
    std::cout << "‚ñ∂Ô∏è Duplikat-Scan fortgesetzt" << std::endl;
}

void Scanner::collectFiles()
{
    emit scanStatusChanged("Sammle Dateien parallel (lokal + netzwerk)...");
    QSet<QString> processedFiles; // Prevent duplicate file processing
    
    // Clear FTP processing state
    pendingFtpDirectories.clear();
    completedFtpDirectories.clear();
    ftpDirectoriesProcessed = 0;
    
    bool hasFtpDirectories = false;
    bool hasLocalDirectories = false;
    
    // üéØ FORTSCHRITTS-TRACKING f√ºr Dateien sammeln
    int totalDirectoriesToProcess = scanDirectories.size();
    int processedDirectoriesCount = 0;
    int totalFilesFound = 0;

    for (const QString &directory : scanDirectories)
    {
        if (!scanning.load())
            return;
            
        // üìä LIVE-Update: Verzeichnis-Fortschritt
        processedDirectoriesCount++;
        emit currentFileProcessing(
            QFileInfo(directory).fileName(), 
            "üìÅ Dateien sammeln", 
            processedDirectoriesCount, 
            totalDirectoriesToProcess
        );
        emit processActivityUpdate(
            QString("üìÇ Sammle Dateien aus Verzeichnis %1/%2")
                .arg(processedDirectoriesCount).arg(totalDirectoriesToProcess),
            QString("Aktuell: %1").arg(QFileInfo(directory).fileName())
        );

        // Check if this is an FTP path
        if (directory.startsWith("ftp://"))
        {
            hasFtpDirectories = true;
            
            // üöÄ START FTP QUEUE DRAIN TIMER: Periodischer Queue-Check
            if (ftpQueueDrainTimer && !ftpQueueDrainTimer->isActive()) {
                ftpQueueDrainTimer->start();
                qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestartet (200ms Intervall)";
            }
            
            collectFtpFiles(directory, processedFiles);
            
            // üöÄ TRIGGER: Starte initiales Progress-Update nach kurzem Delay
            QTimer::singleShot(1000, this, &Scanner::checkScanProgress);
        }
        else
        {
            hasLocalDirectories = true;
            // Local directory scanning - parallel zu FTP
            QDirIterator it(directory, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);

            while (it.hasNext())
            {
                if (!scanning.load())
                    return;

                QString filePath = it.next();
                QFileInfo fileInfo(filePath);
                
                // üöÄ ECHTZEIT GUI: JEDE Datei processEvents f√ºr maximale Responsivit√§t
                QApplication::processEvents();
                
                // üìä ECHTZEIT-Update: Datei gefunden
                totalFilesFound++;
                if (totalFilesFound % 10 == 0) { // Alle 10 Dateien Update (war: 50)
                    emit currentFileProcessing(
                        fileInfo.fileName(), 
                        "üîç Dateien scannen", 
                        totalFilesFound, 
                        0  // Unbekannte Gesamtzahl w√§hrend sammeln
                    );
                    emit processActivityUpdate(
                        QString("üìä %1 Dateien gefunden").arg(totalFilesFound),
                        QString("Aktuell: %1").arg(fileInfo.fileName())
                    );
                    
                    // üñ•Ô∏è CONSOLE SYNC: Zeige in Console was GUI anzeigt
                    std::cout << "\r[Scanner] üîç Sammle Dateien: " << totalFilesFound 
                              << " gefunden - Aktuell: " << fileInfo.fileName().toUtf8().constData() 
                              << std::flush; // \r f√ºr same-line update
                    
                    QApplication::processEvents(); // Extra processEvents bei Status-Updates
                }

                qDebug() << "[Scanner] üîç Untersuche Datei:" << filePath;

                // Normalize path to prevent duplicates
                QString canonicalPath = fileInfo.canonicalFilePath();
                
                // üõ°Ô∏è FALLBACK: Wenn canonicalFilePath leer ist, verwende absoluten Pfad
                if (canonicalPath.isEmpty()) {
                    canonicalPath = fileInfo.absoluteFilePath();
                    qDebug() << "[Scanner] ‚ö†Ô∏è canonicalFilePath leer, verwende absoluten Pfad:" << canonicalPath;
                }
                
                qDebug() << "[Scanner] üìù Kanonischer Pfad:" << canonicalPath;
                qDebug() << "[Scanner] üìä processedFiles.size():" << processedFiles.size();
                
                // üõ°Ô∏è VEREINFACHTER SCHUTZ: Nur lokaler processedFiles-Cache (globaler wird bei Scan-Ende geleert)
                if (processedFiles.contains(canonicalPath))
                {
                    qDebug() << "[Scanner] üîÑ Datei bereits in diesem Scan verarbeitet (√ºbersprungen):" << canonicalPath.right(50);
                    continue; // Skip duplicate files
                }
                processedFiles.insert(canonicalPath);
                qDebug() << "[Scanner] ‚úÖ Datei zu processedFiles hinzugef√ºgt:" << canonicalPath.right(50);

                // Apply file filter
                if (!currentFileFilter.isEmpty() && currentFileFilter != "Alle Dateien" && currentFileFilter != "*")
                {
                    QString extension = fileInfo.suffix().toLower();
                    qDebug() << "[Scanner] üîç Pr√ºfe Filter:" << currentFileFilter << "vs Extension:" << extension;
                    if (!currentFileFilter.contains(extension, Qt::CaseInsensitive))
                    {
                        qDebug() << "[Scanner] ‚ùå Datei durch Filter ausgeschlossen:" << filePath;
                        continue;
                    }
                }
                else
                {
                    qDebug() << "[Scanner] ‚úÖ Filter √ºbersprungen (alle Dateien):" << currentFileFilter;
                }

                // Skip system paths if PresetManager available
                if (presetManager && presetManager->shouldExcludePath(filePath))
                {
                    qDebug() << "[Scanner] ‚ùå Datei durch PresetManager ausgeschlossen:" << filePath;
                    continue;
                }

                // Ô∏è Optional: Gro√üe Dateien √ºberspringen nur wenn explizit aktiviert
                // Steuerung √ºber FILEDUPER_SKIP_LARGE=1 und optional FILEDUPER_MAX_SIZE_MB (Default 0 = kein Limit)
                qint64 fileSize = fileInfo.size();
                bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
                qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
                if (skipLarge && maxSizeMb > 0) {
                    qint64 maxBytes = maxSizeMb * 1024 * 1024;
                    if (fileSize > maxBytes) {
                        qDebug() << "[Scanner] üö® GROSSE DATEI √ºbersprungen (" << maxSizeMb << "MB):" << filePath << "Gr√∂√üe:" << (fileSize / 1024 / 1024) << "MB";
                        continue;
                    }
                }

                qDebug() << "[Scanner] ‚úÖ Datei bestanden alle Filter, f√ºge zu allFiles hinzu:" << canonicalPath;

                FileInfo file;
                file.filePath = canonicalPath; // Use canonical path
                file.fileName = fileInfo.fileName();
                file.size = fileInfo.size();
                file.lastModified = fileInfo.lastModified().toMSecsSinceEpoch();
                file.isLocal = true; // ‚úÖ NEU: Markiere als lokale Datei

                allFiles.append(file);
                qDebug() << "[Scanner] üìä allFiles.size() nach Hinzuf√ºgung:" << allFiles.size();

                if (allFiles.size() % 1000 == 0)
                {
                    // During collection phase: Show files collected with indeterminate progress
                    emit scanProgress(0, allFiles.size(), -1); // -1 indicates collection phase
                    std::cout << "üìÅ " << allFiles.size() << " lokale Dateien gesammelt..." << std::endl;
                }
            }
        }
    }

    emit filesCollected(allFiles.size());
    
    // üî• SPEICHERE Anzahl gesammelter Dateien f√ºr sp√§tere scanCompleted-Emissionen
    m_totalCollectedFiles = allFiles.size();
    qDebug() << "[Scanner] üìä GESPEICHERT: m_totalCollectedFiles =" << m_totalCollectedFiles;
    
    std::cout << "üìÅ " << allFiles.size() << " eindeutige Dateien gesammelt (lokal: " << (hasLocalDirectories ? "‚úÖ" : "‚ùå") << ", netzwerk: " << (hasFtpDirectories ? "‚úÖ" : "‚ùå") << ")" << std::endl;
    if (processedFiles.size() > allFiles.size())
    {
        std::cout << "üîÑ " << (processedFiles.size() - allFiles.size()) << " Duplikate √ºbersprungen" << std::endl;
    }

    // üîç DEBUG: Zeige hasLocalDirectories und hasFtpDirectories Status vor if-else Kette
    qDebug() << "[Scanner] üîç DEBUG PATH LOGIC: hasLocalDirectories=" << hasLocalDirectories << "hasFtpDirectories=" << hasFtpDirectories;
    
    // ‚úÖ NEU: Parallele Verarbeitung - lokale Dateien sind bereits gesammelt
    if (hasLocalDirectories && !hasFtpDirectories) {
        // Nur lokale Dateien - sofort weiter zur Size-Filterung
        qDebug() << "[Scanner] üìÇ Nur lokale Dateien gefunden, starte Size-Filtering";
        filterBySize();
    } else if (!hasLocalDirectories && hasFtpDirectories) {
        // Nur FTP-Dateien - warte auf FTP-Verarbeitung
        qDebug() << "[Scanner] üì° Nur FTP-Dateien gefunden, warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Lade FTP-Verzeichnisse: 0/%1").arg(pendingFtpDirectories.size()));
    } else if (hasLocalDirectories && hasFtpDirectories) {
        // Beide Arten - lokale sind bereits da, warte auf FTP-Completion
        qDebug() << "[Scanner] ÔøΩ Parallel-Scan: Lokale Dateien fertig (" << allFiles.size() << "), warte auf" << pendingFtpDirectories.size() << "FTP-Verzeichnisse";
        emit scanStatusChanged(QString("Parallel: Lokal fertig (%1), FTP: 0/%2").arg(allFiles.size()).arg(pendingFtpDirectories.size()));
    } else {
        // Keine Dateien gefunden
        qDebug() << "[Scanner] ‚ùå Keine Dateien gefunden";
        filterBySize(); // Leerer Scan
    }
}

void Scanner::filterBySize()
{
    if (!scanning.load())
        return;

    emit scanStatusChanged("Sortiere nach Dateigr√∂√üe...");
    currentPhase = SIZE_FILTERING;
    
    // üìä LIVE-Update: Gr√∂√üen-Analyse starten
    emit currentFileProcessing(
        QString("%1 Dateien").arg(allFiles.size()), 
        "üìè Gr√∂√üen-Analyse", 
        0, 
        allFiles.size()
    );
    emit processActivityUpdate(
        "üìä Analysiere Dateigr√∂√üen f√ºr Duplikat-Erkennung",
        QString("Verarbeite %1 Dateien").arg(allFiles.size())
    );

    // Group files by size
    int processedFiles = 0;
    for (const FileInfo &file : allFiles)
    {
        if (!scanning.load())
            return;
            
        // üîç DEBUG: Zeige file.size f√ºr Duplikat-Debug
        if (file.filePath.contains("data1")) {
            qDebug() << "[Scanner] üìè DEBUG SIZE:" << file.filePath << "size:" << file.size;
        }
        
        fileSizeGroups[file.size].append(file);
        processedFiles++;
        
        // ÔøΩÔ∏è GUI RESPONSIVE: Alle 100 Dateien processEvents aufrufen
        // üöÄ ECHTZEIT: ProcessEvents alle 25 Dateien (war: 100)
        if (processedFiles % 25 == 0) {
            QApplication::processEvents();
        }
        
        // üìä ECHTZEIT-Update: Gr√∂√üen-Analyse Fortschritt
        if (processedFiles % 100 == 0) { // Alle 100 Dateien Update (war: 1000)
            emit currentFileProcessing(
                QFileInfo(file.filePath).fileName(), 
                "üìè Gr√∂√üen-Analyse", 
                processedFiles, 
                allFiles.size()
            );
            emit processActivityUpdate(
                QString("üìä Gr√∂√üen-Analyse: %1/%2 (%3%)")
                    .arg(processedFiles)
                    .arg(allFiles.size())
                    .arg(int(100.0 * processedFiles / allFiles.size())),
                QString("Aktuell: %1").arg(QFileInfo(file.filePath).fileName())
            );
        }
    }
    
    // üìä FINAL-Update: Gr√∂√üen-Analyse abgeschlossen
    emit currentFileProcessing(
        QString("%1 Gr√∂√üen-Gruppen").arg(fileSizeGroups.size()), 
        "üìè Gr√∂√üen-Analyse abgeschlossen", 
        allFiles.size(), 
        allFiles.size()
    );

    // ‚úÖ PRODUCTION: Optimiere durch Entfernung von Single-File-Gruppen (echte Duplikat-Erkennung)
    qDebug() << "[Scanner] üìä Size-Groups vor Filterung:" << fileSizeGroups.size() << "verschiedene Gr√∂√üen";
    
    // Entferne Gruppen mit nur einer Datei (keine Duplikate m√∂glich)
    auto it = fileSizeGroups.begin();
    while (it != fileSizeGroups.end())
    {
        if (it.value().size() == 1)
        {
            it = fileSizeGroups.erase(it);
        }
        else
        {
            ++it;
        }
    }
    
    qDebug() << "[Scanner] üìä Size-Groups nach Filterung:" << fileSizeGroups.size() << "Gruppen mit potentiellen Duplikaten";

    // üîé Optional: Deep debug per size-group when FILEDUPER_DEBUG_GROUPS=1
    static const bool debugGroups = qEnvironmentVariableIsSet("FILEDUPER_DEBUG_GROUPS") && (qgetenv("FILEDUPER_DEBUG_GROUPS") == "1");
    if (debugGroups) {
        int groupIndex = 0;
        for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ++it) {
            const qint64 sizeKey = it.key();
            const QList<FileInfo> &files = it.value();
            int localCount = 0, ftpCount = 0;
            for (const FileInfo &f : files) {
                if (f.isLocal) localCount++; else if (f.filePath.startsWith("ftp://")) ftpCount++;
            }
            qDebug() << "[Scanner] üîé Gruppe" << (++groupIndex) << ": size=" << sizeKey
                     << " files=" << files.size() << " local=" << localCount << " ftp=" << ftpCount;
        }
    }

    int potentialDuplicates = 0;
    for (const auto &group : fileSizeGroups)
    {
        potentialDuplicates += group.size();
    }

    qDebug() << "[Scanner] üìä" << potentialDuplicates << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    std::cout << "üìä " << potentialDuplicates << " Dateien zur Hash-Berechnung hinzugef√ºgt" << std::endl;

    // üî• KRITISCH: Rufe startHashing() NUR auf wenn KEIN FTP-Scan aktiv ist!
    // Bei FTP-Scans wird startHashing() von checkScanProgress() aufgerufen
    if (pendingFtpDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Kein FTP-Scan aktiv - starte Hash-Berechnung direkt";
        startHashing();
    } else {
        qDebug() << "[Scanner] ‚è≥ FTP-Scan aktiv (" << pendingFtpDirectories.size() << "pending) - warte auf checkScanProgress()";
    }
}

void Scanner::startHashing()
{
    qDebug() << "[Scanner] startHashing() aufgerufen";
    qDebug() << "[Scanner] scanning.load():" << scanning.load();
    qDebug() << "[Scanner] hashEngine g√ºltig:" << (hashEngine != nullptr);
    qDebug() << "[Scanner] allFiles.size():" << allFiles.size();
    
    if (!scanning.load() || !hashEngine) {
        qDebug() << "[Scanner] ‚ùå startHashing() - Fr√ºher Return: scanning=" << scanning.load() << ", hashEngine=" << (hashEngine != nullptr);
        return;
    }

    qDebug() << "[Scanner] ‚úÖ startHashing() - Bedingungen erf√ºllt, starte Hash-Berechnung";
    
    // üöÄ OPTIMIERUNG 2: Smart Pre-Filtering - Skip kleine Dateien
    int originalCount = allFiles.size();
    QList<FileInfo> filteredFiles;
    int skippedTooSmall = 0;
    
    if (enableSmartPreFiltering) {
        for (auto it = fileSizeGroups.begin(); it != fileSizeGroups.end(); ) {
            qint64 fileSize = it.key();
            QList<FileInfo> &filesInGroup = it.value();
            
            if (fileSize < minFileSizeForHashing) {
                skippedTooSmall += filesInGroup.size();
                it = fileSizeGroups.erase(it);  // Remove entire size group
            } else {
                ++it;
            }
        }
        
        qDebug() << "[Scanner] ‚ö° Smart Pre-Filter: √úberspringe" << skippedTooSmall 
                 << "Dateien <" << minFileSizeForHashing << "Bytes";
        qDebug() << "[Scanner] ‚úÖ Verbleibend f√ºr Hash-Berechnung:" << (originalCount - skippedTooSmall) << "Dateien";
    }
    
    emit scanStatusChanged(QString("Berechne Hashes f√ºr %1 Dateien...").arg(originalCount - skippedTooSmall));
    currentPhase = HASHING;
    
    // üî• KRITISCH: Speichere m_totalCollectedFiles HIER als Backup
    // Falls es in collectFiles() nicht gesetzt wurde (z.B. bei FTP-only Scans)
    if (m_totalCollectedFiles == 0 && allFiles.size() > 0) {
        m_totalCollectedFiles = allFiles.size();
        qDebug() << "[Scanner] üìä BACKUP GESPEICHERT in startHashing(): m_totalCollectedFiles =" << m_totalCollectedFiles;
    }
    
    QStringList filesToHash;
    
    // ‚úÖ FTP-Credentials aus INI-Datei laden (ignoriere URL-Credentials)
    if (presetManager) {
        QSet<QString> ftpHosts;
        for (const FileInfo &file : allFiles) {
            if (file.filePath.startsWith("ftp://")) {
                QUrl url(file.filePath);
                if (url.isValid()) {
                    // Verwende nur den Host, ignoriere Credentials in der URL
                    QString host = url.host();
                    if (!host.isEmpty()) {
                        ftpHosts.insert(host);
                    }
                }
            }
        }
        
        // Lade echte Credentials aus INI-Datei f√ºr jeden Host
        for (const QString &host : ftpHosts) {
            LoginData login = presetManager->getLogin(host, 21);  
            if (login.isValid()) {
                hashEngine->setFtpCredentials(host, login.username, login.password);
                qDebug() << "[Scanner] üîê Echte FTP-Credentials aus INI-Datei geladen f√ºr:" << host << "User:" << login.username;
            } else {
                qWarning() << "[Scanner] ‚ö†Ô∏è Keine FTP-Credentials in INI-Datei gefunden f√ºr:" << host;
                qWarning() << "[Scanner] üí° Bitte FTP-Credentials in Settings speichern f√ºr Host:" << host;
            }
        }
    }
    
    // ÔøΩ OPTIMIZED: Use only files from optimized size+date groups instead of ALL files
    QMap<QString, QList<FileInfo>> dateSizeGroups;
    
    // ‚úÖ FIX: Hash ALL files - size filtering prevents content-based duplicate detection
    for (auto &sizeGroup : fileSizeGroups)
    {
        // REMOVED: Unique size filtering - files with same content can have different sizes
        // All files must be hashed to ensure proper duplicate detection
        
        bool hasNetworkFiles = false;
        // Check if group contains network files (FTP/SFTP etc.)
        for (const FileInfo &file : sizeGroup) {
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://")) {
                hasNetworkFiles = true;
                break;
            }
        }
        
        if (hasNetworkFiles) {
            // For network files: Skip date filtering (unreliable timestamps)
            QString sizeOnlyKey = QString("size_%1").arg(sizeGroup.first().size);
            dateSizeGroups[sizeOnlyKey] = sizeGroup;
            qDebug() << "[Scanner] üì° Network-Gruppe (nur Size-Filter):" << sizeGroup.size() << "Dateien";
        } else {
            // For local files: Use size+date filtering for better optimization  
            QMap<QString, QList<FileInfo>> dateSubGroups;
            for (const FileInfo &file : sizeGroup) {
                QDateTime dateTime = QDateTime::fromSecsSinceEpoch(file.lastModified);
                QString dateKey = QString("%1_%2").arg(dateTime.toString("yyyy-MM-dd")).arg(file.size);
                dateSubGroups[dateKey].append(file);
            }
            
            // ‚úÖ FIX: Keep ALL files in date groups - size filtering already happened
            // Files with same size but different dates could still be duplicates
            for (auto dateIt = dateSubGroups.begin(); dateIt != dateSubGroups.end(); ++dateIt) {
                dateSizeGroups[dateIt.key()] = dateIt.value();
            }
            qDebug() << "[Scanner] üìÅ Lokale Gruppe (Size+Date-Filter):" << dateSubGroups.size() << "Untergruppen";
        }
    }
    
    // Add optimized files to hash calculation
    QSet<QString> processedForHashing; // üõ°Ô∏è SCHUTZ: Verhindere doppelte Hash-Berechnung
    for (const auto &group : dateSizeGroups)
    {
        for (const FileInfo &file : group) {
            // üõ°Ô∏è CRITICAL FIX: Pr√ºfe ob Datei bereits zur Hash-Berechnung hinzugef√ºgt wurde
            QString canonicalPath;
            if (file.filePath.startsWith("ftp://") || file.filePath.startsWith("sftp://") || 
                file.filePath.startsWith("smb://")) {
                // F√ºr Netzwerk-URLs: Verwende den Pfad direkt ohne canonicalFilePath()
                canonicalPath = file.filePath;
            } else {
                // F√ºr lokale Dateien: Verwende canonicalFilePath()
                canonicalPath = QFileInfo(file.filePath).canonicalFilePath();
                // üõ°Ô∏è ZUS√ÑTZLICHER SCHUTZ: Leere/ung√ºltige Pfade √ºberspringen
                if (canonicalPath.isEmpty()) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger canonicalPath f√ºr:" << file.filePath;
                    continue;
                }
            }
            
            // üõ°Ô∏è CRITICAL SECURITY: Auch globalHashedFiles pr√ºfen um Infinite-Loop zu verhindern
            if (processedForHashing.contains(canonicalPath) || globalHashedFiles.contains(canonicalPath)) {
                qDebug() << "[Scanner] ‚ö†Ô∏è Datei bereits f√ºr Hashing vorgemerkt/verarbeitet (√ºbersprungen):" << file.filePath.right(50);
                continue;
            }
            processedForHashing.insert(canonicalPath);
            // ‚úÖ FIX: F√ºge Datei NICHT vorab zu globalHashedFiles hinzu - erst wenn Hash empfangen!
            filesToHash.append(file.filePath);
        }
    }

    qDebug() << "[Scanner] üîç Starte OPTIMIERTE Hash-Berechnung f√ºr" << filesToHash.size() << "Dateien";
    qDebug() << "[Scanner] ‚ö° Performance-Boost durch" << (allFiles.size() - filesToHash.size()) << "√ºbersprungene Unique-Dateien";
    
    // Handle case when ALL files are unique
    if (filesToHash.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ ALLE Dateien sind unique - keine Hash-Berechnung erforderlich!";
        emit scanStatusChanged("‚úÖ Alle Dateien sind unique - keine Duplikate gefunden!");
        
        // üî• KRITISCH: Setze totalFiles damit GUI "Keine Duplikate gefunden!" korrekt anzeigt
        // ‚úÖ FIX: Nutze m_totalCollectedFiles statt allFiles.size() (k√∂nnte 0 sein!)
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = m_totalCollectedFiles; // Gespeicherte Anzahl
        
        qDebug() << "[Scanner] üî• PREPARE EMIT - totalFiles:" << emptyResults.totalFiles 
                 << "m_totalCollectedFiles:" << m_totalCollectedFiles 
                 << "allFiles.size:" << allFiles.size();
        
        // üî• GUARD: Emittiere nur wenn noch nicht emittiert
        // ‚úÖ FIX: KEIN QTimer - direkte Emission da alle Dateien unique sind (kein Hashing n√∂tig)
        if (!m_scanCompletedEmitted.exchange(true)) {
            emit scanCompleted(emptyResults);
            qDebug() << "[Scanner] üî• EMIT scanCompleted (ALL UNIQUE) - totalFiles:" << emptyResults.totalFiles;
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è scanCompleted bereits emittiert - √ºberspringe ALL UNIQUE emission";
        }
        return;
    }

    qDebug() << "[Scanner] üîç Starte Hash-Berechnung f√ºr" << filesToHash.size() << "Dateien";
    qDebug() << "[Scanner] üìä" << filesToHash.size() << "Dateien zur Hash-Berechnung hinzugef√ºgt";
    
    // ‚ö° CHUNK-BASIERTE PARALLEL-HASH-BERECHNUNG: 30 Chunks wie NetworkScanner
    const int HASH_CHUNKS = 30;  // Parallel-Processing f√ºr maximale Geschwindigkeit
    const int filesPerChunk = (filesToHash.size() + HASH_CHUNKS - 1) / HASH_CHUNKS;
    
    qDebug() << "[Scanner] üöÄ CHUNK-PROCESSING:" << HASH_CHUNKS << "Chunks √†" << filesPerChunk << "Dateien";
    
    // Teile Dateien in Chunks auf
    QList<QStringList> fileChunks;
    for (int i = 0; i < HASH_CHUNKS && i * filesPerChunk < filesToHash.size(); ++i) {
        int startIdx = i * filesPerChunk;
        int endIdx = qMin(startIdx + filesPerChunk, filesToHash.size());
        QStringList chunk = filesToHash.mid(startIdx, endIdx - startIdx);
        if (!chunk.isEmpty()) {
            fileChunks.append(chunk);
        }
    }
    
    qDebug() << "[Scanner] ‚úÖ Aufgeteilt in" << fileChunks.size() << "Chunks f√ºr Parallel-Processing";
    
    // Starte Chunks parallel mit QTimer
    int chunkIndex = 0;
    for (const QStringList &chunk : fileChunks) {
        QTimer::singleShot(chunkIndex * 50, this, [this, chunk, chunkIndex, fileChunks]() {
            qDebug() << "[Scanner] üî• Chunk" << (chunkIndex + 1) << "/" << fileChunks.size() 
                     << "gestartet mit" << chunk.size() << "Dateien";
            
            // Sende Chunk zur Hash-Berechnung
            for (const QString &file : chunk) {
                hashEngine->calculateFileHashAsync(file);
            }
        });
        chunkIndex++;
    }
    
    qDebug() << "[Scanner] üöÄ Alle" << fileChunks.size() << "Hash-Chunks gestartet!";
    
    // ‚ö° ERWEITERTER TIMEOUT-SCHUTZ: Gib HashEngine mehr Zeit f√ºr Duplikat-Erkennung
    QTimer::singleShot(45000, this, [this, filesToHash]() {  // 45s statt 30s
        if (scanning.load() && currentPhase == HASHING) {
            qWarning() << "[Scanner] üö® ERWEITERTER TIMEOUT: 45s Hash-Timeout ‚Üí Warte auf HashEngine-Fertigstellung...";
            
            // ‚úÖ WICHTIG: Gib HashEngine zus√§tzliche 15s f√ºr Duplikat-Finalisierung 
            QTimer::singleShot(15000, this, [this, filesToHash]() {
                if (scanning.load()) {
                    qWarning() << "[Scanner] ÔøΩ FINALER TIMEOUT: Nutze bereits gefundene Duplikate!";
                    
                    // Versuche partielle Ergebnisse aus der HashEngine zu extrahieren
                    DuplicateGroups partialResults = buildPartialResults();
                    
                    if (partialResults.groups.size() > 0) {
                        qDebug() << "[Scanner] üéØ TIMEOUT-RETTUNG: Gefunden" << partialResults.groups.size() << "Duplikat-Gruppen!";
                        
                        // ‚úÖ FIX: HashEngine stoppen bevor scanCompleted emittiert wird
                        if (hashEngine) {
                            hashEngine->clearProcessedFiles();
                            qDebug() << "[Scanner] üõë HashEngine gestoppt wegen Timeout";
                        }
                        
                        scanning.store(false);
                        currentPhase = COMPLETED;
                        emit scanProgress(100, filesToHash.size(), filesToHash.size());
                        
                        // üî• GUARD: Emittiere nur wenn noch nicht emittiert
                        if (!m_scanCompletedEmitted.exchange(true)) {
                            emit scanCompleted(partialResults);
                            qDebug() << "[Scanner] üî• EMIT scanCompleted (TIMEOUT PARTIAL) - groups:" << partialResults.groups.size();
                        }
                        return;
                    }
                    
                    // ‚úÖ Fallback: Leere Ergebnisse nur wenn wirklich nichts gefunden wurde
                    // ‚úÖ FIX: HashEngine stoppen bevor scanCompleted emittiert wird
                    if (hashEngine) {
                        hashEngine->clearProcessedFiles();
                        qDebug() << "[Scanner] üõë HashEngine gestoppt wegen Timeout (Fallback)";
                    }
                    
                    scanning.store(false);
                    currentPhase = COMPLETED;
                    emit scanProgress(100, filesToHash.size(), filesToHash.size());
                    
                    // üî• KRITISCH: Setze totalFiles damit GUI nicht "Keine Duplikate" zeigt
                    DuplicateGroups timeoutResults;
                    timeoutResults.totalFiles = filesToHash.size();
                    
                    // üî• GUARD: Emittiere nur wenn noch nicht emittiert
                    if (!m_scanCompletedEmitted.exchange(true)) {
                        emit scanCompleted(timeoutResults);
                        qDebug() << "[Scanner] üî• EMIT scanCompleted (TIMEOUT FALLBACK) - totalFiles:" << timeoutResults.totalFiles;
                    }
                }
            });
            return;
        }
    });
    
    // ÔøΩüöÄüß† Optional: NPU-FIRST BILDVERARBEITUNG: Separiere Bilder BEVOR Hash-Berechnung beginnt!
    QStringList imageFiles;
    QStringList nonImageFiles;
    
    // ‚úÖ BILDFILES vs. NORMAL FILES separieren
    for (const QString &filePath : filesToHash) {
        QString lowerExt = QFileInfo(filePath).suffix().toLower();
        if (lowerExt == "jpg" || lowerExt == "jpeg" || lowerExt == "png" || lowerExt == "bmp" || 
            lowerExt == "tiff" || lowerExt == "tif" || lowerExt == "cr2" || lowerExt == "raw" ||
            lowerExt == "nef" || lowerExt == "arw" || lowerExt == "dng" || lowerExt == "webp") {
            imageFiles.append(filePath);
        } else {
            nonImageFiles.append(filePath);
        }
    }
    
    qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "| Non-Images:" << nonImageFiles.size();
    
    // üß† NPU-BILDVERARBEITUNG: Parallel zur Hash-Pipeline (immer zus√§tzlich, niemals als Ersatz)
    if (npuEnabled && hashEngine && hashEngine->isNpuAvailable() && !imageFiles.isEmpty()) {
        qDebug() << "[Scanner] üöÄ NPU Bildanalyse startet parallel f√ºr" << imageFiles.size() << "Bilder (Hash bleibt aktiv)!";
        emit scanStatusChanged("üß† NPU analysiert Bilder (parallel zur Hash-Berechnung)...");

        // üìä LIVE-Update: NPU-Bildverarbeitung starten
        emit currentFileProcessing(
            QString("%1 Bilder").arg(imageFiles.size()),
            "üß† NPU-Bildverarbeitung (parallel)",
            0,
            imageFiles.size()
        );
        emit processActivityUpdate(
            "üß† Intel NPU analysiert Bilder f√ºr intelligente Duplikat-Erkennung",
            QString("Verarbeite %1 Bilder").arg(imageFiles.size())
        );

        // NPU Feature-Vector Processing f√ºr Bilder (zus√§tzlich; ersetzt NICHT den Content-Hash)
        hashEngine->processImagesWithNpuUltraFast(imageFiles);
        npuProcessedImages = imageFiles.size();

        // üìä FINAL-Update: NPU-Bildverarbeitung abgeschlossen
        emit currentFileProcessing(
            QString("%1 Features extrahiert").arg(npuProcessedImages),
            "üß† NPU-Bildverarbeitung abgeschlossen (parallel)",
            npuProcessedImages,
            imageFiles.size()
        );
        emit processActivityUpdate(
            QString("üß† NPU hat %1 Bilder analysiert (Content-Hash l√§uft weiter)").arg(npuProcessedImages),
            "Intelligente Bildanalyse abgeschlossen"
        );
    }
    
    // Hinweis: Bilder werden weiterhin gehasht, auch wenn NPU parallel lief
    if (npuEnabled && npuProcessedImages > 0) {
        qDebug() << "[Scanner] üß† NPU hat" << npuProcessedImages << "Bilder analysiert (Content-Hashes folgen wie gewohnt)";
    }
    
    // Hash-Berechnung f√ºr alle Dateien (auch Bilder). NPU-Ergebnisse sind zus√§tzlich verf√ºgbar.
    if (!filesToHash.isEmpty()) {
        totalFilesForHashing = filesToHash.size(); // üéØ Setze Gesamt-Anzahl f√ºr Live-Updates
        
        // üìä LIVE-Update: Hash-Berechnung starten
        emit currentFileProcessing(
            QString("%1 Dateien").arg(filesToHash.size()), 
            "üîê Hash-Berechnung", 
            0, 
            filesToHash.size()
        );
        emit processActivityUpdate(
            "üîê Berechne kryptographische Hashes f√ºr Duplikat-Erkennung",
            QString("Verarbeite %1 Dateien").arg(filesToHash.size())
        );
        
        emit hashingStarted(filesToHash.size());
        
        // ‚úÖ KRITISCH: HashEngine √ºber die erwartete Dateianzahl informieren (NACH NPU-Verarbeitung!)
        if (hashEngine) {
            hashEngine->setExpectedFilesCount(filesToHash.size());
            qDebug() << "[Scanner] üìä HashEngine informiert: erwarte" << filesToHash.size() << "Dateien f√ºr Hash-Berechnung (nach NPU)";
        }
        
        hashEngine->calculateMultipleHashes(filesToHash);
    } else {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine Dateien f√ºr die Hash-Berechnung ermittelt (leer)";
        emit scanStatusChanged("‚ö†Ô∏è Keine Dateien zum Hashen gefunden");
        QTimer::singleShot(500, this, &Scanner::compareHashes);
    }
}

void Scanner::onHashCalculated(const QString &filePath, const QString &hash)
{
    if (!scanning.load())
        return;

    // üöÄ THROTTLING: GUI-Updates nur alle 100ms oder bei wichtigen Ereignissen
    static qint64 lastGuiUpdate = 0;
    static int lastDisplayedCount = 0;
    qint64 guiUpdateTime = QDateTime::currentMSecsSinceEpoch();
    bool shouldUpdateGui = false;
    
    static int currentHashCount = 0;
    currentHashCount++;
    
    // Update bei: 1) Erster Datei, 2) Alle 100ms, 3) Jeder 10. Datei, 4) Wichtige Ereignisse
    if (currentHashCount == 1 || 
        (guiUpdateTime - lastGuiUpdate >= 100) ||
        (currentHashCount % 10 == 0)) {
        shouldUpdateGui = true;
        lastGuiUpdate = guiUpdateTime;
    }

    // üéØ LIVE-DATEINAME-UPDATE: Zeige aktuell verarbeitete Datei in GUI
    QString fileName = QFileInfo(filePath).fileName();
    QString shortPath = filePath;
    
    // üî• ECHTZEIT: Zeige vollst√§ndigen Pfad, aber komprimiert f√ºr GUI
    if (filePath.length() > 80) {
        shortPath = "..." + filePath.right(77);
    }
    
    QString processType = "üîç Hash-Berechnung";
    const bool isNpuHash = hash.startsWith("npv_");
    
    // Unterscheide zwischen NPU und Standard-Hash
    if (isNpuHash) {
        processType = "ü§ñ NPU-Bildanalyse";
    } else if (hash.startsWith("md5_")) {
        processType = "üîê MD5-Hash";
    } else if (hash.startsWith("sha256_")) {
        processType = "üîê SHA256-Hash";
    } else if (filePath.startsWith("ftp://")) {
        processType = "üì° FTP-Hash (Stream)";
    } else {
        processType = "üîç Lokale Hash-Berechnung";
    }
    
    // üî• ECHTZEIT-STATUS-UPDATE: Zeige Pfad + Aktivit√§t in GUI (throttled)
    if (shouldUpdateGui) {
        emit scanStatusChanged(QString("%1: %2").arg(processType, shortPath));
    }
    
    // Ô∏è SICHERUNG: Verhindere Doppelbearbeitung bereits berechneter Hashes
    // WICHTIG: NPU-Hashes (npv_*) sind zus√§tzlich und d√ºrfen den Content-Hash NICHT ersetzen.
    // Daher markieren wir Dateien nur als gehasht, wenn es sich NICHT um einen NPU-Hash handelt.
    if (globalHashedFiles.contains(filePath)) {
        if (isNpuHash) {
            qDebug() << "[Scanner] ‚ÑπÔ∏è NPU-Zusatzhash ignoriert f√ºr bereits verarbeitete Datei:" << filePath.right(50);
            return; // Zusatzinfo, Content-Hash bleibt ma√ügeblich
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è Content-Hash bereits registriert f√ºr:" << filePath.right(50);
            return;
        }
    }
    
    // üö® MEMORY PROTECTION: Prevent QSet overflow crash
    if (globalHashedFiles.size() > 20000) {
        qWarning() << "[Scanner] üö® QSet zu gro√ü (" << globalHashedFiles.size() << ") - leere Cache f√ºr Stabilit√§t";
        globalHashedFiles.clear();
        globalProcessedFiles.clear();
    }
    
    // Nur Content-Hashes z√§hlen f√ºr den Abschluss/Progress
    if (!isNpuHash) {
        globalHashedFiles.insert(filePath);
    }

    // üìä KORREKTER PROGRESS-COUNTER: Verwende globalHashedFiles.size() f√ºr aktuellen Stand
    currentHashCount = globalHashedFiles.size(); // Nutze static Variable von Zeile 1015
    int progressPercent = totalFilesForHashing > 0 ? (currentHashCount * 100) / totalFilesForHashing : 0;
    
    
    if (shouldUpdateGui) {
        // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI mit korrekten Z√§hlern
        emit currentFileProcessing(fileName, processType, currentHashCount, totalFilesForHashing);
        emit processActivityUpdate(processType, QString("Verarbeite: %1 (%2/%3)").arg(fileName).arg(currentHashCount).arg(totalFilesForHashing));
        emit scanProgress(progressPercent, currentHashCount, totalFilesForHashing);
        
        qDebug() << "[Scanner] üìä GUI-Update:" << processType << fileName << QString("(%1/%2)").arg(currentHashCount).arg(totalFilesForHashing);
    }

    qDebug() << "[Scanner] üìä Hash berechnet f√ºr:" << filePath.right(50) << "‚Üí" << hash.left(16) << QString("(%1/%2)").arg(currentHashCount).arg(totalFilesForHashing);

    // ‚úÖ FIX: Update hash in fileSizeGroups (nicht allFiles - das ist nur eine Kopie)
    bool hashUpdated = false;
    for (auto &group : fileSizeGroups)
    {
        for (FileInfo &file : group)
        {
            if (file.filePath == filePath)
            {
                // üõ°Ô∏è NPU-Hashes nicht als Content-Hash speichern
                if (isNpuHash) {
                    continue; // Lass Content-Hash unber√ºhrt
                }
                // üõ°Ô∏è ZUS√ÑTZLICHE SICHERUNG: Verhindere Hash-√úberschreibung (au√üer wenn vorher leer)
                if (!file.hash.isEmpty() && file.hash != hash) {
                    qWarning() << "[Scanner] ‚ö†Ô∏è Hash-Konflikt f√ºr" << filePath.right(50) 
                              << "- Alt:" << file.hash.left(16) << "Neu:" << hash.left(16);
                }
                file.hash = hash;
                hashUpdated = true;
                break;
            }
        }
        if (hashUpdated) break;
    }

    // ‚ö° OPTIMIERT: Schnelle Progress-Berechnung mit Early Return
    int totalFilesInGroups = 0;
    int hashedFilesInGroups = 0;
    
    // Early Return: Wenn keine Gruppen vorhanden
    if (fileSizeGroups.isEmpty()) {
        emit scanProgress(100, 0, 0); // 100% f√ºr leere Scans
        return;
    }
    
    // Optimierte Iteration mit const& und reserve
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        const qint64 size = groupIt.key();
        const QList<FileInfo> &filesInGroup = groupIt.value();
        totalFilesInGroups += filesInGroup.size();
        for (const FileInfo &file : filesInGroup) {
            if (!file.hash.isEmpty() && 
                file.hash != "FTP_SKIPPED" && 
                file.hash != "FTP_DOWNLOAD_FAILED" &&
                file.hash != "GPU_ERROR") {
                hashedFilesInGroups++;
            }
        }
    }
    
    // ‚úÖ BULLETPROOF: Division-by-Zero Protection + Overflow Protection + DEBUG
    int percentage = 0;
    if (totalFilesInGroups > 0) {
        qDebug() << "[Scanner] üîß DIVISION-DEBUG: hashedFiles=" << hashedFilesInGroups 
                 << "totalFiles=" << totalFilesInGroups << "vor Division";
        
        // Verhindere Integer-Overflow bei sehr gro√üen Dateizahlen
        if (hashedFilesInGroups > INT_MAX / 100) {
            percentage = (int)((long long)hashedFilesInGroups * 100 / totalFilesInGroups);
            qDebug() << "[Scanner] üîß OVERFLOW-PROTECTION: LongLong-Division verwendet";
        } else {
            percentage = (hashedFilesInGroups * 100) / totalFilesInGroups;
            qDebug() << "[Scanner] üîß NORMAL-DIVISION: Standard-Division verwendet";
        }
        percentage = qMax(0, qMin(100, percentage)); // Clamp 0-100%
        qDebug() << "[Scanner] üîß RESULT-PERCENTAGE:" << percentage << "%";
    } else {
        qDebug() << "[Scanner] üö® ZERO-DIVISION-AVOIDED: totalFilesInGroups=0, percentage=0";
    }
    
    // üöÄ ECHTZEIT PROGRESS: Maximale GUI-Responsivit√§t (16ms = ~60 FPS)
    static int lastEmittedPercentage = -1;
    static qint64 lastEmitTime = 0;
    static int rapidUpdateCount = 0;
    
    qint64 progressTime = QDateTime::currentMSecsSinceEpoch();
    bool shouldEmitProgress = false;
    
    // üéØ ECHTZEIT-MODUS: Sehr schnelle Updates f√ºr fl√ºssige GUI
    int timeDelta = progressTime - lastEmitTime;
    int percentageDelta = abs(percentage - lastEmittedPercentage);
    
    if (percentageDelta >= 1) {
        if (timeDelta >= 16) { // 16ms = 60 FPS f√ºr butterweiche Updates
            shouldEmitProgress = true;
            rapidUpdateCount = 0;
        } else {
            rapidUpdateCount++;
            // Jeder 2. Update bei ultra-schnellen √Ñnderungen (war: jeder 5.)
            if (rapidUpdateCount >= 2) {
                shouldEmitProgress = true;
                rapidUpdateCount = 0;
            }
        }
    }
    
    // Kritische Meilensteine: 0%, 25%, 50%, 75%, 100% - IMMER emittieren
    // Plus: Force-Update alle 500ms (war 1000ms) f√ºr garantierte Echtzeit-Anzeige
    if (percentage == 0 || percentage == 25 || percentage == 50 || 
        percentage == 75 || percentage == 100 || timeDelta >= 500) {
        shouldEmitProgress = true;
    }
    
    if (shouldEmitProgress) {
        emit scanProgress(percentage, hashedFilesInGroups, totalFilesInGroups);
        qDebug() << "[Scanner] üìä Hash-Progress (Optimized):" << hashedFilesInGroups 
                 << "/" << totalFilesInGroups << "(" << percentage << "%) Œît:" << (progressTime - lastEmitTime) << "ms";
        lastEmittedPercentage = percentage;
        lastEmitTime = progressTime;
    }
    
    
    // ‚úÖ SMARTE ANTI-HANG: Adaptive Stagnation Detection mit Time-based Checks
    static int lastPercentage = -1;
    static int stagnationCount = 0;
    static qint64 stagnationStartTime = 0;
    
    // Wiederverwendung von progressTime f√ºr Stagnation-Detection
    if (percentage == lastPercentage && percentage > 0) {
        if (stagnationCount == 0) {
            stagnationStartTime = progressTime; // Erste Stagnation markieren
        }
        stagnationCount++;
        
        // Progressive Timeouts: 5s bei 0-50%, 10s bei 50-90%, 15s bei 90-100%
        int timeoutMs = (percentage < 50) ? 5000 : (percentage < 90) ? 10000 : 15000;
        qint64 stagnationDuration = progressTime - stagnationStartTime;
        
        if (stagnationDuration >= timeoutMs && stagnationCount >= 3) {
            qWarning() << "[Scanner] üö® Progress-Stagnation:" << percentage 
                      << "% f√ºr" << stagnationDuration << "ms ‚Üí Smart Force Complete!";
            
            // ‚ö° INTELLIGENTE FORCE COMPLETION: Graduelle Steigerung
            int forcePercentage = qMin(100, percentage + 20); // +20% pro Force-Step
            emit scanProgress(forcePercentage, hashedFilesInGroups, totalFilesInGroups);
            
            if (forcePercentage >= 100) {
                // Erstelle minimale Results f√ºr Completion
                DuplicateGroups intelligentResults = buildPartialResults();
                
                // üî• GUARD: Emittiere nur wenn noch nicht emittiert
                if (!m_scanCompletedEmitted.exchange(true)) {
                    emit scanCompleted(intelligentResults);
                    qDebug() << "[Scanner] üî• EMIT scanCompleted (INTELLIGENT) - groups:" << intelligentResults.groups.size();
                }
                return;
            }
            stagnationCount = 0; // Reset f√ºr n√§chsten Force-Step
        }
    } else {
        lastPercentage = percentage;
        stagnationCount = 0; // Reset bei Progress-√Ñnderung
        stagnationStartTime = 0;
    }
    
    // Check if all hashes are calculated (exclude FTP_SKIPPED files)
    bool allHashesReady = (hashedFilesInGroups >= totalFilesInGroups && totalFilesInGroups > 0);
    
    // ‚úÖ TIMEOUT-SCHUTZ: Force completion if 50% der Dateien fertig sind (weniger aggressiv)
    bool forceComplete = (totalFilesInGroups > 0 && hashedFilesInGroups >= (totalFilesInGroups * 0.5));
    
    if (allHashesReady || forceComplete)
    {
        if (forceComplete && !allHashesReady) {
            qDebug() << "[Scanner] ‚ö†Ô∏è TIMEOUT-SCHUTZ: Erzwinge Completion mit" << hashedFilesInGroups << "/" << totalFilesInGroups << "Dateien (85%+)";
        } else {
            qDebug() << "[Scanner] ‚úÖ Alle Hashes berechnet, starte Vergleich";
        }
        
        // üéØ SYNC-FIX: Debounce mit QTimer um sicherzustellen dass ALLE onHashCalculated() callbacks durch sind
        static QTimer* debounceTimer = nullptr;
        if (!debounceTimer) {
            debounceTimer = new QTimer(this);
            debounceTimer->setSingleShot(true);
            connect(debounceTimer, &QTimer::timeout, this, &Scanner::compareHashes);
        }
        
        // Starte/Restarte Timer mit 100ms delay - l√§sst Event-Queue leeren
        debounceTimer->start(100);
        qDebug() << "[Scanner] ‚è±Ô∏è compareHashes() debounced um 100ms verz√∂gert (Event-Queue leeren)";
    }
}

void Scanner::compareHashes()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] üéØ compareHashes() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();
    
    emit scanStatusChanged("Vergleiche Duplikate (lokal ‚Üî netzwerk)...");
    currentPhase = COMPARING;
    emit comparingStarted();
    
    // üìä LIVE-Update: Duplikat-Vergleich starten
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen").arg(hashGroups.size()), 
        "üîç Duplikat-Vergleich", 
        0, 
        hashGroups.size()
    );
    emit processActivityUpdate(
        "üîç Vergleiche Hashes f√ºr Duplikat-Erkennung",
        QString("Analysiere %1 verschiedene Hash-Gruppen").arg(hashGroups.size())
    );

    // ‚úÖ FIX: Group files by hash from fileSizeGroups (not allFiles)
    int processedGroups = 0;
    int totalValidHashes = 0;
    int skippedHashes = 0;
    
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt)
    {
        if (!scanning.load())
            return;
            
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup)
        {
            if (file.hash.isEmpty()) {
                skippedHashes++;
                continue;
            }
            if (file.hash.startsWith("npv_")) {
                skippedHashes++;
                continue; // NPU-Feature-Hashes sind Zusatzinfos, nicht f√ºr Content-Duplikate
            }
            if (file.hash == "FTP_SKIPPED" || file.hash == "FTP_DOWNLOAD_FAILED") {
                skippedHashes++;
                continue;
            }
            
            hashGroups[file.hash].append(file);
            totalValidHashes++;
        }
        
        processedGroups++;
        // ÔøΩ ECHTZEIT-Update: Gruppierungs-Fortschritt (alle 25 statt 100)
        if (processedGroups % 25 == 0) {
            emit currentFileProcessing(
                QString("Gruppe %1").arg(processedGroups), 
                "üîç Hash-Gruppierung", 
                processedGroups, 
                fileSizeGroups.size()
            );
        }
    }
    
    // üìä LIVE-Update: Hash-Gruppierung abgeschlossen
    emit currentFileProcessing(
        QString("%1 Hash-Gruppen erstellt").arg(hashGroups.size()), 
        "üîç Hash-Gruppierung abgeschlossen", 
        fileSizeGroups.size(), 
        fileSizeGroups.size()
    );
    
    // üìä DEBUG: Zeige wichtige Hash-Statistiken
    qDebug() << "[Scanner] üîç HASH-DEBUG:" << hashGroups.size() << "eindeutige Hashes";
    qDebug() << "[Scanner] üìä Verarbeitet:" << totalValidHashes << "g√ºltige Hashes," << skippedHashes << "√ºbersprungen";
    
    int duplicateGroups = 0;
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (it.value().size() > 1) {
            duplicateGroups++;
            qDebug() << "[Scanner] üîÑ DUPLIKAT-GRUPPE Hash" << it.key().left(8) << "hat" << it.value().size() << "Dateien:";
            for (const FileInfo &file : it.value()) {
                qDebug() << "    -" << (file.isLocal ? "LOCAL" : "FTP") << file.filePath << "(" << file.size << "bytes)";
            }
        }
    }
    qDebug() << "[Scanner] üéØ DUPLIKAT-GRUPPEN gefunden:" << duplicateGroups;
    
    // üî• ECHTZEIT-UPDATE: Zeige gefundene Duplikate SOFORT in GUI
    emit scanStatusChanged(QString("üîç %1 Duplikat-Gruppen gefunden!").arg(duplicateGroups));
    emit currentFileProcessing(
        QString("%1 Duplikat-Gruppen").arg(duplicateGroups),
        "üéØ Duplikate identifiziert",
        duplicateGroups,
        hashGroups.size()
    );

    // Remove unique hashes FIRST, THEN check if empty
    qDebug() << "[Scanner] üßπ Entferne Unikate: Vor Bereinigung" << hashGroups.size() << "Gruppen";
    auto it = hashGroups.begin();
    int removedUniqueGroups = 0;
    while (it != hashGroups.end())
    {
        if (it.value().size() == 1)
        {
            removedUniqueGroups++;
            it = hashGroups.erase(it);
        }
        else
        {
            ++it;
        }
    }
    qDebug() << "[Scanner] üßπ Nach Bereinigung:" << hashGroups.size() << "Duplikat-Gruppen," << removedUniqueGroups << "Unikate entfernt";

    // üì¢ USER-FRIENDLY MESSAGE: Show if no duplicates found AFTER cleanup
    if (hashGroups.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ KEINE DUPLIKATE GEFUNDEN - alle Dateien sind unique!";
        emit scanStatusChanged("‚úÖ Scan abgeschlossen - keine Duplikate gefunden!");
        
        // üî• KRITISCH: Setze totalFiles - Dateien wurden gescannt, nur keine Duplikate gefunden
        DuplicateGroups emptyResults;
        emptyResults.totalFiles = totalValidHashes; // Anzahl g√ºltiger Hashes = gescannte Dateien
        
        // üî• GUARD: Emittiere nur wenn noch nicht emittiert
        // ‚úÖ FIX: KEIN QTimer - direkte Emission da Hash-Vergleich abgeschlossen ist
        if (!m_scanCompletedEmitted.exchange(true)) {
            emit scanCompleted(emptyResults);
            qDebug() << "[Scanner] üî• EMIT scanCompleted (NO DUPLICATES) - totalFiles:" << emptyResults.totalFiles;
        }
        return; // Beende hier, keine weiteren Vergleiche n√∂tig
    }

    // ‚úÖ NEU: Statistiken f√ºr lokale vs Netzwerk-Duplikate und Hardware-Updates
    int localOnlyGroups = 0;
    int networkOnlyGroups = 0;
    int crossNetworkGroups = 0;
    int totalComparisons = 0;
    int duplicatesFound = 0;
    int groupsCreated = 0;
    
    // üéØ HARDWARE-MONITORING: Simuliere Hardware-Nutzung basierend auf Vergleichsaufwand
    auto getHardwareUsage = [&](int currentComparison, int totalComparisons) {
        // Simuliere unterschiedliche Hardware-Nutzung basierend auf Workload
        QString processingUnit;
        int utilizationPercent = 0;
        QString currentTask;
        
        if (totalComparisons > 1000) {
            // Gro√üe Datenmenge ‚Üí NPU/GPU
            processingUnit = npuManager ? "NPU (Intel Arc)" : "GPU (OpenCL)";
            utilizationPercent = 70 + (currentComparison % 30); // 70-99% Auslastung
            currentTask = "Parallele Hash-Vergleiche";
        } else if (totalComparisons > 100) {
            // Mittlere Datenmenge ‚Üí GPU
            processingUnit = "GPU (OpenCL)";
            utilizationPercent = 40 + (currentComparison % 40); // 40-79% Auslastung
            currentTask = "Sequentielle Vergleiche";
        } else {
            // Kleine Datenmenge ‚Üí CPU
            processingUnit = "CPU (Multi-Core)";
            utilizationPercent = 10 + (currentComparison % 30); // 10-39% Auslastung
            currentTask = "Standard-Vergleiche";
        }
        
        return std::make_tuple(processingUnit, utilizationPercent, currentTask);
    };
    
    // Berechne die Gesamtzahl der Vergleiche f√ºr Progress-Updates
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        int filesInGroup = it.value().size();
        totalComparisons += (filesInGroup * (filesInGroup - 1)) / 2; // n*(n-1)/2 Vergleiche
    }
    
    qDebug() << "[Scanner] üîç Starte" << totalComparisons << "Datei-Vergleiche in" << hashGroups.size() << "Hash-Gruppen";
    
    // üéØ LIVE-UPDATE: Hardware-Status zu Beginn
    auto [initialUnit, initialPercent, initialTask] = getHardwareUsage(0, totalComparisons);
    emit hardwareUsageUpdate(initialUnit, initialPercent, QString("Initialisiere %1").arg(initialTask));
    
    int currentComparison = 0;
    
    for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
        if (!scanning.load()) return;
        
        const QList<FileInfo> &files = it.value();
        
        if (files.size() > 1) {
            groupsCreated++;
            
            // üéØ DETAILLIERTE DATEI-ZU-DATEI-VERGLEICHE
            for (int i = 0; i < files.size(); i++) {
                for (int j = i + 1; j < files.size(); j++) {
                    if (!scanning.load()) return;
                    
                    // üñ•Ô∏è GUI RESPONSIVE: Bei JEDEM Vergleich processEvents f√ºr maximale Responsivit√§t
                    QApplication::processEvents();
                    
                    // Alternative: Alle 5 Vergleiche (weniger overhead)
                    // if (currentComparison % 5 == 0) {
                    //     QApplication::processEvents();
                    // }
                    
                    currentComparison++;
                    const FileInfo &file1 = files[i];
                    const FileInfo &file2 = files[j];
                    
                    // üìä LIVE-Update: Detaillierter Datei-Vergleich
                    emit fileComparisonProgress(
                        QFileInfo(file1.filePath).fileName(),
                        QFileInfo(file2.filePath).fileName(),
                        currentComparison,
                        totalComparisons
                    );
                    
                    // Bestimme Vergleichstyp
                    QString comparisonType;
                    if (file1.isLocal && file2.isLocal) {
                        comparisonType = "Lokal ‚Üî Lokal";
                    } else if (!file1.isLocal && !file2.isLocal) {
                        comparisonType = "Netzwerk ‚Üî Netzwerk";
                    } else {
                        comparisonType = "Lokal ‚Üî Netzwerk";
                        crossNetworkGroups++;
                    }
                    
                    // üìä LIVE-Update: Vergleichsaktivit√§t
                    emit processActivityUpdate(
                        QString("üîç %1 Vergleich").arg(comparisonType),
                        QString("Vergleiche %1 vs %2").arg(
                            QFileInfo(file1.filePath).fileName(),
                            QFileInfo(file2.filePath).fileName()
                        )
                    );
                    
                    duplicatesFound++;
                    
                    // üìä LIVE-Update: Duplikat gefunden
                    emit duplicateDetectionUpdate(
                        duplicatesFound,
                        groupsCreated,
                        QString("%1 ‚âà %2").arg(
                            QFileInfo(file1.filePath).fileName(),
                            QFileInfo(file2.filePath).fileName()
                        )
                    );
                    
                    // üöÄ ECHTZEIT: GUI-Update alle 10 Vergleiche (war: 50)
                    if (currentComparison % 10 == 0) {
                        int percentage = (currentComparison * 100) / totalComparisons;
                        emit scanProgressDetailed(
                            percentage,
                            currentComparison,
                            totalComparisons,
                            QString("Vergleiche Dateien (%1)").arg(comparisonType)
                        );
                        
                        // GUI-Responsivit√§t bei JEDEM 10. Vergleich
                        QApplication::processEvents();
                    }
                }
            }
            
            // Klassifiziere Gruppe
            bool hasLocal = false;
            bool hasNetwork = false;
            for (const FileInfo &file : files) {
                if (file.isLocal) hasLocal = true;
                else hasNetwork = true;
            }
            
            if (hasLocal && hasNetwork) {
                crossNetworkGroups++;
            } else if (hasLocal) {
                localOnlyGroups++;
            } else {
                networkOnlyGroups++;
            }
        }
    }
    int mixedGroups = 0;
    
    for (const auto &hashGroup : hashGroups) {
        bool hasLocal = false;
        bool hasNetwork = false;
        
        for (const FileInfo &file : hashGroup) {
            if (file.isLocal) {
                hasLocal = true;
            } else {
                hasNetwork = true;
            }
        }
        
        if (hasLocal && hasNetwork) {
            mixedGroups++;
        } else if (hasLocal) {
            localOnlyGroups++;
        } else if (hasNetwork) {
            networkOnlyGroups++;
        }
    }

    std::cout << "üîç " << hashGroups.size() << " Duplikat-Gruppen gefunden:" << std::endl;
    std::cout << "   üìÇ Nur lokal: " << localOnlyGroups << " Gruppen" << std::endl;
    std::cout << "   üì° Nur netzwerk: " << networkOnlyGroups << " Gruppen" << std::endl;
    std::cout << "   üîÑ Lokal ‚Üî Netzwerk: " << mixedGroups << " Gruppen" << std::endl;

    // Falls keine Hash-Gruppen entstanden sind (z.B. nur NPU-Ergebnisse), trotzdem Ergebnisse erzeugen
    generateResults();
}

void Scanner::generateResults()
{
    if (!scanning.load())
        return;

    qDebug() << "[Scanner] üéØ generateResults() aufgerufen!";
    qDebug() << "[Scanner] üìä hashGroups.size():" << hashGroups.size();

    emit scanStatusChanged("Generiere Ergebnisse (lokal + netzwerk)...");
    currentPhase = COMPLETED;

    DuplicateGroups results;
    int crossNetworkDuplicates = 0;

    qDebug() << "[Scanner] üìä GENERATERESULTS: Starte mit" << hashGroups.size() << "Hash-Gruppen";
    int processedGroups = 0;
    
    for (const auto &hashGroup : hashGroups)
    {
        processedGroups++;
        qDebug() << "[Scanner] üîç Pr√ºfe Gruppe" << processedGroups << "/" << hashGroups.size() << "mit" << hashGroup.size() << "Dateien";
        if (hashGroup.size() < 2) {
            qDebug() << "[Scanner] ‚è≠Ô∏è √úberspringe Gruppe (nur" << hashGroup.size() << "Datei)";
            continue;
        }

        DuplicateGroup group;
        QList<FileInfo> files = hashGroup;

        // ‚úÖ NEU: Pr√ºfe ob es sich um lokale ‚Üî Netzwerk Duplikate handelt
        bool hasLocal = false;
        bool hasNetwork = false;
        for (const FileInfo &file : files) {
            if (file.isLocal) {
                hasLocal = true;
            } else {
                hasNetwork = true;
            }
        }
        
        if (hasLocal && hasNetwork) {
            crossNetworkDuplicates++;
        }

        // Sort by modification time and prefer local files as originals
        std::sort(files.begin(), files.end(), [](const FileInfo &a, const FileInfo &b)
                  { 
                      // ‚úÖ PRIORIT√ÑT 1: Bevorzuge lokale Dateien als Original (sicherer)
                      if (a.isLocal != b.isLocal) {
                          return a.isLocal > b.isLocal; // Lokale Dateien zuerst
                      }
                      // ‚úÖ PRIORIT√ÑT 2: √Ñlteste Datei als Original (Standard: KEEP_OLDEST)
                      return a.lastModified < b.lastModified; // √Ñlteste zuerst (Original)
                  });

        // First file is original (preferably local), rest are duplicates
        group.original = files.takeFirst();
        group.duplicates = files;
        group.hash = group.original.hash;
        group.size = group.original.size;

        results.groups.append(group);
        results.duplicateFiles += group.duplicates.size();
        results.duplicateSize += group.size * group.duplicates.size();
    }

    results.totalFiles = allFiles.size();

    scanning.store(false);
    currentPhase = IDLE;

    // ‚úÖ DEBUG: Detaillierte Ergebnis-Analyse
    qDebug() << "[Scanner] üìä FINALE STATISTIKEN:";
    qDebug() << "    - Verarbeitete Dateien:" << results.totalFiles;
    qDebug() << "    - Duplikat-Gruppen:" << results.groups.size();
    qDebug() << "    - Duplikat-Dateien:" << results.duplicateFiles;
    qDebug() << "    - Gesparte Gr√∂√üe:" << (results.duplicateSize / (1024*1024)) << "MB";

    std::cout << "‚úÖ Parallel-Scan abgeschlossen: " << results.groups.size()
              << " Duplikat-Gruppen mit " << results.duplicateFiles << " Duplikaten" << std::endl;
    std::cout << "   üîÑ Lokal ‚Üî Netzwerk Duplikate: " << crossNetworkDuplicates << " Gruppen" << std::endl;
    
    // üîê SPEICHERE SCAN-HISTORY nach erfolgreichem Scan
    for (const FileInfo &file : allFiles) {
        addToScanHistory(file.filePath, false);
    }
    saveScanHistory();
    qDebug() << "[Scanner] üíæ Scan-History gespeichert:" << allFiles.size() << "neue Dateien";

    // Benutzerfreundliche Status-Nachricht basierend auf Ergebnis
    if (results.groups.empty()) {
        emit scanStatusChanged("‚úÖ Scan abgeschlossen - keine Duplikate gefunden!");
    } else {
        emit scanStatusChanged(QString("‚úÖ Scan abgeschlossen - %1 Duplikat-Gruppen mit %2 Duplikaten gefunden")
                              .arg(results.groups.size())
                              .arg(results.duplicateFiles));
    }
    
    // üî• GUARD: Emittiere nur wenn noch nicht emittiert
    if (!m_scanCompletedEmitted.exchange(true)) {
        emit scanCompleted(results);
        qDebug() << "[Scanner] üî• EMIT scanCompleted (NORMAL) - groups:" << results.groups.size() 
                 << "totalFiles:" << results.totalFiles;
    }
}

void Scanner::onFtpFilesReceived(const QString &directory, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üìÑ FTP-Dateien empfangen f√ºr:" << directory << "Files:" << files.size() << "Success:" << success;
    
    // üéØ SOFORTIGE QUEUE-INFO: Emittiere BEVOR fr√ºhe returns passieren!
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    int completedDirs = completedFtpDirectories.size();
    QString ftpProgressWithQueue = QString("FTP %1/%2").arg(completedDirs).arg(totalFtpDirs);
    if (pendingFtpDirectories.size() > 0) {
        ftpProgressWithQueue += QString(" | Verbleibend: %1").arg(pendingFtpDirectories.size());
    }
    
    qDebug() << "[Scanner] üéØ EMIT currentFileProcessing (SLOT1):" << ftpProgressWithQueue << "(" << completedDirs << "/" << totalFtpDirs << ")";
    
    emit currentFileProcessing(
        ftpProgressWithQueue,  // ‚úÖ Mit Queue-Info f√ºr GUI!
        "üì° FTP-Scan l√§uft",
        completedDirs,
        totalFtpDirs
    );
    
    if (!success) {
        qWarning() << "[Scanner] ‚ö†Ô∏è FTP-Fehler beim Laden von:" << directory;
        return;
    }
    
    // üõ°Ô∏è KRITISCHER SICHERHEITSCHECK: Verhindere QHash-Crash bei sehr gro√üen Datens√§tzen
        if (files.size() > 25000) {
        qDebug() << "[Scanner] üö® KRITISCH: Zu viele Dateien (" << files.size() << ") - Chunked Processing aktiviert";
            // Versuche die vollst√§ndige FTP-URL f√ºr dieses Verzeichnis zu ermitteln
            QString baseUrl = directory;
            if (!baseUrl.startsWith("ftp://")) {
                // Aufl√∂sen anhand pendingFtpDirectories
                auto normalizePath = [](QString p) {
                    if (p.isEmpty()) return p;
                    if (!p.startsWith('/')) p.prepend('/');
                    if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                    return p;
                };
                const QString dirNorm = normalizePath(directory);
                for (const QString &pendingUrl : pendingFtpDirectories) {
                    QUrl url(pendingUrl);
                    const QString pendNorm = normalizePath(url.path());
                    if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                        baseUrl = pendingUrl;
                        break;
                    }
                }
            }
            processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    if (files.size() > 100000) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Zu viele Dateien (" << files.size() << ") - √ºberspringe zur Sicherheit";
        pendingFtpDirectories.removeOne(directory); // ‚úÖ FIX: Use removeOne() instead of remove()
        checkScanProgress();
        return;
    }
    
    // üß† NPU-BILDVERARBEITUNG: F√ºr gro√üe Bilddatens√§tze optimiert
    // üöÄ PRODUCTION NPU: Aktiviert f√ºr mittlere bis gro√üe Bilddatens√§tze (>1.000 Dateien)
    if (files.size() > 1000 && npuManager) {  // NPU aktiviert ab 1.000 Dateien
        qDebug() << "[Scanner] üöÄ ULTRA-FAST NPU aktiviert f√ºr" << files.size() << "Dateien";
        
        // üé® Filtere ALLE Bilddateien f√ºr Ultra-Fast NPU-Verarbeitung (inkl. RAW)
        QStringList imageFiles;
        for (const QString &file : files) {
            if (file.endsWith(".jpg", Qt::CaseInsensitive) || 
                file.endsWith(".jpeg", Qt::CaseInsensitive) ||
                file.endsWith(".png", Qt::CaseInsensitive) ||
                file.endsWith(".gif", Qt::CaseInsensitive) ||
                file.endsWith(".cr2", Qt::CaseInsensitive) ||  // Canon RAW
                file.endsWith(".nef", Qt::CaseInsensitive) ||  // Nikon RAW
                file.endsWith(".arw", Qt::CaseInsensitive) ||  // Sony RAW
                file.endsWith(".dng", Qt::CaseInsensitive) ||  // Adobe RAW
                file.endsWith(".tiff", Qt::CaseInsensitive) || // TIFF
                file.endsWith(".bmp", Qt::CaseInsensitive)) {  // Bitmap
                imageFiles.append(file);
            }
        }
        
        qDebug() << "[Scanner] üìä BILDFILES ERKANNT:" << imageFiles.size() << "Bilder f√ºr NPU-Verarbeitung";
        
        if (imageFiles.size() > 50) {  // üöÄ SOFORTIGE NPU-AKTIVIERUNG bei 50+ Bildern
            qDebug() << "[Scanner] üöÄ NPU-ONLY Bildverarbeitung f√ºr" << imageFiles.size() << "Bilder (KEINE Hash-Methode)";
            
            // üß† NPU FEATURE-VECTOR-BASIERTE DUPLIKATERKENNUNG (ERSETZT Hash-basiert)
            qDebug() << "[Scanner] üß† Starte NPU Feature-Vector-Analyse (Hash-frei)...";
            QStringList processedImages = npuManager->processImagesWithNpuUltraFast(imageFiles);
            
            // üéØ Feature-Vector-Duplikate finden (OHNE Hash-Vergleich!)
            QList<QStringList> featureBasedDuplicates = npuManager->findFeatureBasedDuplicates(processedImages);
            
            qDebug() << "[Scanner] ‚úÖ NPU-Feature-Duplikate gefunden:" << featureBasedDuplicates.size() << "Gruppen";
            qDebug() << "[Scanner] üöÄ NPU-ONLY Verarbeitung abgeschlossen:" 
                     << processedImages.size() << "Bilder ohne Hash-Methode";
                     
            // üìä NPU-Counter setzen f√ºr Hash-Pipeline-Skip
            npuProcessedImages = imageFiles.size();
            qDebug() << "[Scanner] üéØ NPU-Counter gesetzt:" << npuProcessedImages << "verarbeitete Bilder";
                     
            // üìä NPU-Aktivit√§ts-Update f√ºr GUI
            emit npuActivityUpdate(imageFiles.size(), featureBasedDuplicates.size());
            
            // üöÄ WICHTIG: Entferne verarbeitete Bilder aus der Hash-Pipeline
            // ‚ö†Ô∏è FIX: Erstelle lokale Kopie da `files` const ist
            QStringList remainingFiles = files;
            for (const QString &img : imageFiles) {
                remainingFiles.removeAll(img);
            }
            qDebug() << "[Scanner] üéØ BILDER aus Hash-Pipeline entfernt:" << imageFiles.size() << "Dateien";
            qDebug() << "[Scanner] üìä Verbleibende Dateien f√ºr Hash-Verarbeitung:" << remainingFiles.size();
            
        } else {
            qDebug() << "[Scanner] üìä Zu wenig Bilder f√ºr NPU-Batch (" << imageFiles.size() << "/50) - verwende Hash-basierte Einzelverarbeitung";
        }
    }
    
    // üß† MEMORY-PROTECTION: F√ºr sehr gro√üe Datens√§tze (>25.000 Dateien) Batch-Verarbeitung
    if (files.size() > 25000) {
        qDebug() << "[Scanner] üß† MEMORY-PROTECTION: Aktiviere Batch-Verarbeitung f√ºr" << files.size() << "Dateien";
        // directory kann Pfad oder vollst√§ndige URL sein; vereinheitlichen
        QString baseUrl = directory;
        if (!baseUrl.startsWith("ftp://")) {
            auto normalizePath = [](QString p) {
                if (p.isEmpty()) return p;
                if (!p.startsWith('/')) p.prepend('/');
                if (p.length() > 1 && p.endsWith('/')) p.chop(1);
                return p;
            };
            const QString dirNorm = normalizePath(directory);
            for (const QString &pendingUrl : pendingFtpDirectories) {
                QUrl url(pendingUrl);
                const QString pendNorm = normalizePath(url.path());
                if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                    baseUrl = pendingUrl;
                    break;
                }
            }
        }
        processFtpFilesBatch(baseUrl, files, success);
        return;
    }
    
    // Find the full FTP URL for this directory path (robust against trailing slashes)
    QString fullFtpUrl;
    auto normalizePath = [](QString p) {
        if (p.isEmpty()) return p;
        // Ensure path starts with '/'
        if (!p.startsWith('/')) p.prepend('/');
        // Remove single trailing '/'
        if (p.length() > 1 && p.endsWith('/')) p.chop(1);
        return p;
    };
    const QString dirNorm = normalizePath(directory);
    for (const QString &pendingUrl : pendingFtpDirectories) {
        QUrl url(pendingUrl);
        const QString pendNorm = normalizePath(url.path());
        if (pendNorm == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
        // Also allow match if directory had an extra '/' when emitted
        if (normalizePath(url.path() + "/") == dirNorm) {
            fullFtpUrl = pendingUrl;
            break;
        }
    }
    
    if (fullFtpUrl.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Keine entsprechende FTP-URL gefunden f√ºr:" << directory;
        return;
    }
    
    // Extract host from full FTP URL for file path construction
    QUrl ftpUrl(fullFtpUrl);
    QString host = ftpUrl.host();
    QString basePath = ftpUrl.path();
    // Normalize basePath to '/path' without trailing '/'
    if (!basePath.startsWith('/')) basePath.prepend('/');
    if (basePath.length() > 1 && basePath.endsWith('/')) basePath.chop(1);
    
    // Add all files to allFiles list
    QSet<QString> processedFileNames; // üöÄ Prevent size-variant duplicates
    
    for (const QString &encodedFile : files) {
        // ‚úÖ FIX: Parse encoded "path/filename|size" format (now with FULL PATH from recursive scan!)
        QStringList parts = encodedFile.split('|');
        QString fullFilePath = parts.size() > 0 ? parts[0] : encodedFile; // JETZT mit vollst√§ndigem Pfad!
        qint64 fileSize = parts.size() > 1 ? parts[1].toLongLong() : 0;
        
        // Extrahiere nur den Dateinamen f√ºr Duplikat-Check
        QString fileName = fullFilePath;
        if (fullFilePath.contains('/')) {
            fileName = fullFilePath.mid(fullFilePath.lastIndexOf('/') + 1);
        }
        
        // üöÄ CRITICAL FIX: Skip if we already processed this filename (prevent size variants)
        if (processedFileNames.contains(fileName)) {
            qDebug() << "[Scanner] ‚ö†Ô∏è √úberspringe Gr√∂√üen-Variante:" << fileName;
            continue;
        }
        processedFileNames.insert(fileName);
        
        // ‚úÖ URL-KODIERUNG: Spaces und Sonderzeichen f√ºr FTP-URLs kodieren
        QString encodedFullPath = QUrl::toPercentEncoding(fullFilePath);
        
        FileInfo fileInfo;
        // üîÑ NEU: Verwende vollst√§ndigen Pfad (rekursiv von FtpClient)
        fileInfo.filePath = QString("ftp://%1:21%2").arg(host, encodedFullPath);
        fileInfo.fileName = fileName; // Nur Dateiname f√ºr Anzeige
        fileInfo.size = fileSize; // ‚úÖ FIX: Use real file size from FTP LIST
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = "";
        fileInfo.isLocal = false; // ‚úÖ NEU: Markiere als Netzwerk-Datei
        fileInfo.networkType = "FTP"; // ‚úÖ NEU: Netzwerk-Typ
        
        allFiles.append(fileInfo);
        qDebug() << "[Scanner] ‚úÖ Added FTP file (REKURSIV):" << fileInfo.filePath << "Size:" << fileSize << "bytes";
    }
    
    // ‚úÖ CRITICAL FIX: Remove directory from pending list
    pendingFtpDirectories.removeAll(directory);
    
    // Mark this directory as completed
    completedFtpDirectories.append(directory);
    ftpDirectoriesProcessed++;
    
    // ‚úÖ NEU: Z√§hle lokale und FTP-Dateien separat f√ºr bessere Anzeige
    int localFiles = 0;
    int ftpFiles = 0;
    for (const FileInfo &file : allFiles) {
        if (file.isLocal) {
            localFiles++;
        } else {
            ftpFiles++;
        }
    }
    
    emit scanStatusChanged(QString("Parallel: Lokal %1, FTP %2/%3 (%4 Dateien)")
                          .arg(localFiles)
                          .arg(ftpDirectoriesProcessed)
                          .arg(pendingFtpDirectories.size())
                          .arg(ftpFiles));
    
    // ‚úÖ UNIFIED LOGIC: Use checkScanProgress() instead of duplicate check
    qDebug() << "[Scanner] üìä onFtpFilesReceived abgeschlossen f√ºr" << directory << "- pr√ºfe Gesamtfortschritt";
    checkScanProgress();
}

void Scanner::collectFtpFiles(const QString &ftpDirectory, QSet<QString> &processedFiles, bool isFromQueue)
{
    // üîß NORMALIZE URL at entry: Always include port for consistent comparison throughout function
    QUrl normalizedEntryUrl(ftpDirectory);
    if (normalizedEntryUrl.port() == -1) {
        normalizedEntryUrl.setPort(21);  // Add default FTP port if missing
    }
    QString normalizedFtpDir = normalizedEntryUrl.toString();  // Use this throughout function
    
    qDebug() << "[Scanner] üì° FTP-Optimiert: Sammle Dateien f√ºr:" << normalizedFtpDir;
    
    // üéØ PROGRESS UPDATE: Zeige aktuelles Verzeichnis sofort!
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    int completedDirs = completedFtpDirectories.size();
    emit currentFileProcessing(
        QString("FTP-Verzeichnis %1/%2 | Verbleibend: %3").arg(completedDirs).arg(totalFtpDirs).arg(pendingFtpDirectories.size()),
        "üì° Lade Netzwerk-Dateien",
        completedDirs,
        totalFtpDirs
    );
    
    // ‚ö° PERFORMANCE: Cache f√ºr gro√üe Datens√§tze 
    static QHash<QString, QStringList> ftpFileCache;
    static QDateTime lastCacheUpdate;
    
    // Cache-Check: Verwende gecachte Daten wenn < 5 Min alt
    if (ftpFileCache.contains(normalizedFtpDir) && 
        lastCacheUpdate.secsTo(QDateTime::currentDateTime()) < 300) {
        qDebug() << "[Scanner] ‚ö° FTP-Cache-Hit f√ºr:" << normalizedFtpDir;
        processCachedFtpFiles(normalizedFtpDir, ftpFileCache[normalizedFtpDir], processedFiles);
        return;
    }
    
    // Extract IP and path from FTP URL: ftp://192.168.1.224/sdb/Comedy/
    QUrl ftpUrl(normalizedFtpDir);
    if (!ftpUrl.isValid()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltige FTP-URL:" << normalizedFtpDir;
        return;
    }
    QString host = ftpUrl.host();
    QString path = ftpUrl.path();
    if (host.isEmpty()) {
        qWarning() << "[Scanner] ‚ö†Ô∏è Ung√ºltiger FTP-Pfad (Host leer):" << normalizedFtpDir;
        return;
    }
    if (path.isEmpty()) path = "/"; // ensure non-empty directory path
    
    // ‚ö° OPTIMIERT: Wiederverwendung bestehender FTP-Connections
    FtpClient *urlSpecificClient = getOrCreateFtpClient(host);
    if (!urlSpecificClient) {
        qCritical() << "[Scanner] ‚ùå Konnte keinen FTP-Client erstellen f√ºr Host:" << host;
        return;
    }
    
    // ‚úÖ BULLETPROOF: PresetManager Null-Check mit Fallback
    if (!presetManager) {
        qCritical() << "[Scanner] ‚ùå FATAL: PresetManager null! Verwende Default-Credentials";
        useDefaultFtpCredentials(urlSpecificClient, host);
    } else {
        // Hole Credentials aus PresetManager f√ºr gespeicherte Logins
        LoginData login = presetManager->getLogin(host, 21);
        if (!login.isValid()) {
            qWarning() << "[Scanner] ‚ö†Ô∏è Keine Login-Daten f√ºr" << host << ":21 ‚Üí Verwende Default";
            useDefaultFtpCredentials(urlSpecificClient, host);
        } else {
            qDebug() << "[Scanner] üîê Verwende Credentials:" << login.username << "f√ºr" << host;
            urlSpecificClient->setCredentials(host, 21, login.username, login.password);
        }
    }
    
    // üéØ REDUNDANCY CHECK: Pr√ºfe ob ein Child-Verzeichnis dieses Parent bereits ersetzt
    QString normalizedFtp = normalizedFtpDir;
    if (normalizedFtp.endsWith('/') && normalizedFtp.length() > 1) {
        normalizedFtp.chop(1);
    }
    
    // Pr√ºfe gegen alle bereits pending FTP-Verzeichnisse
    for (const QString &existingFtp : pendingFtpDirectories) {
        QString normalizedExisting = existingFtp;
        if (normalizedExisting.endsWith('/') && normalizedExisting.length() > 1) {
            normalizedExisting.chop(1);
        }
        
        // Ist das neue Verzeichnis ein PARENT des existierenden? ‚Üí Skip!
        if (normalizedExisting.startsWith(normalizedFtp + "/")) {
            qDebug() << "[Scanner] üö´ REDUNDANT: FTP-Parent √ºbersprungen (Child bereits ausgew√§hlt)";
            return;
        }
        
        // Ist das neue Verzeichnis ein CHILD des existierenden? ‚Üí Entferne Parent!
        if (normalizedFtp.startsWith(normalizedExisting + "/")) {
            // üî• CRITICAL MEMORY-FIX: Parent-Removal KOMPLETT DEAKTIVIERT!
            // removeAll() auf gro√üen Listen (10k+) verursacht std::bad_alloc Crash
            // Lieber redundante Scans als Memory-Crash bei 99% Completion!
            qDebug() << "[Scanner] ‚è≠Ô∏è Parent-Child erkannt, aber Skip Removal (Memory-Schutz)";
            // Falls Parent bereits aktiv scannt, werden beide gescannt - kein Problem
        }
    }
    
    // Add to pending directories list for tracking; skip duplicate setup if already pending
    bool newlyAdded = false;
    if (!isFromQueue) {
        // Nur bei NEUEN Aufrufen pr√ºfen - aus Queue kommende sind schon pending!
        if (!pendingFtpDirectories.contains(normalizedFtpDir)) {
            pendingFtpDirectories.append(normalizedFtpDir);
            newlyAdded = true;
        } else {
            qDebug() << "[Scanner] ‚è≠Ô∏è FTP-Verzeichnis bereits pending, √ºberspringe erneute Verbindung:" << normalizedFtpDir;
            return;
        }
    }
    
    // Wiederverwendung bestehender FTP-Connections
    FtpClient *urlSpecificClient = getOrCreateFtpClient(host);
    if (!urlSpecificClient) {
        qCritical() << "[Scanner] Konnte keinen FTP-Client erstellen fuer Host:" << host;
        return;
    }
    
    // Hole Credentials aus PresetManager fuer gespeicherte Logins
    LoginData login = presetManager->getLogin(host, 21);
    if (!login.isValid()) {
        qWarning() << "[Scanner] Keine Login-Daten fuer" << host << ":21";
        return;
    } else {
        qDebug() << "[Scanner] Verwende Credentials:" << login.username << "fuer" << host;
        urlSpecificClient->setCredentials(host, 21, login.username, login.password);
    }
    
    ftpActiveHosts.insert(host);
    
    // Verbinde Signal fuer aktuellen Scan-Status
    connect(urlSpecificClient, &FtpClient::filesListFinished,
            this, [this, urlSpecificClient, normalizedFtpDir](const QString &dir, const QStringList &files, bool success) {
        
        // CONNECTION POOLING: Client SOFORT freigeben fuer naechsten Scan
        if (urlSpecificClient) {
            urlSpecificClient->setProperty("busy", false);
        }
        
        qDebug() << "[Scanner] FTP-Dateien empfangen fuer:" << dir << "Files:" << files.size() << "Success:" << success;
        
        if (success) {
            for (const QString &file : files) {
                QString baseFileName = file;
                qint64 fileSize = 0;
                
                if (file.contains("|")) {
                    QStringList fileNameParts = file.split("|");
                    baseFileName = fileNameParts[0];
                    fileSize = fileNameParts[1].toLongLong();
                }
                
                QUrl ftpUrl;
                ftpUrl.setScheme("ftp");
                ftpUrl.setHost(QUrl(normalizedFtpDir).host());
                ftpUrl.setPort(21);
                ftpUrl.setPath(QUrl(normalizedFtpDir).path() + "/" + baseFileName);
                QString fullPath = ftpUrl.toString();
                
                QString canonicalPath = QUrl(fullPath).toString();
                if (this->processedFiles.contains(canonicalPath)) {
                    continue;
                }
                this->processedFiles.insert(canonicalPath);
                
                FileInfo ftpFile;
                ftpFile.filePath = fullPath;
                ftpFile.fileName = baseFileName;
                ftpFile.size = fileSize;
                ftpFile.lastModified = QDateTime::currentDateTime().toSecsSinceEpoch();
                ftpFile.hash = "";
                ftpFile.isLocal = false;
                ftpFile.networkType = "FTP";
                
                allFiles.append(ftpFile);
            }
        }
        
        pendingFtpDirectories.removeAll(normalizedFtpDir);
        completedFtpDirectories.append(normalizedFtpDir);
        
        checkScanProgress();
    });
    
    // Starte die FTP-Verbindung und Dateiliste
    urlSpecificClient->connectToHost();
    if (!path.endsWith('/')) path += '/';
    urlSpecificClient->listFiles(path);
    
    qDebug() << "[Scanner] FTP-Collection gestartet fuer" << normalizedFtpDir;
}

void Scanner::checkScanProgress()
{
    qDebug() << "[Scanner] Pruefe Scan-Fortschritt - Pending FTP:" << pendingFtpDirectories.size();
    
    // Pruefe ob alle Scans abgeschlossen sind
    if (pendingFtpDirectories.isEmpty() && allFiles.isEmpty()) {
        qDebug() << "[Scanner] Alle Scans abgeschlossen";
        emit scanCompleted();
    }
}
        }
        
        qDebug() << "[Scanner] üìä FTP-Queue f√ºr" << host << "hat jetzt" << ftpQueuePerHost[host].size() << "Verzeichnisse";
        qDebug() << "[Scanner] üîç Aktive Scans f√ºr" << host << ":" << activeFtpScansPerHost.value(host, 0) << "/" << maxParallelFtpScans;
        
    });
    
    // FtpClient macht jetzt den NON-REKURSIVEN Scan (Subdirectories werden separat gehandhabt)!
    // Verbinde Signal f√ºr Dateien im aktuellen Verzeichnis
    // üî• CRITICAL FIX: Jeder Scan braucht eigene Lambda - keine Disconnects!
    // Lambdas checken normalizedFtpDir und returnen fr√ºh bei Mismatch
    
    // üî• FIX: Single-Shot ist FALSCH - jeder Scan braucht sein eigenes Callback!
    // L√∂sung: Track diesen spezifischen Scan mit normalizedFtpDir als Key
    
    connect(urlSpecificClient, &FtpClient::filesListFinished,
            this, [this, urlSpecificClient, normalizedFtpDir](const QString &dir, const QStringList &files, bool success) {
        
        // ÔøΩ CONNECTION POOLING: Client SOFORT freigeben f√ºr n√§chsten Scan
        if (urlSpecificClient) {
            urlSpecificClient->setProperty("busy", false);
        }
        
        // ÔøΩüî• KEIN Lambda-Filter mehr n√∂tig - jeder Scan hat eigenen Client!
        // Neue Client-Pro-Scan-Strategie verhindert Lambda-Accumulation
        
        // üî• DEDUPLICATE: Pr√ºfe ob dieser spezifische Scan bereits completed wurde
        if (completedFtpDirectories.contains(normalizedFtpDir)) {
            qDebug() << "[Scanner] ‚è≠Ô∏è Scan bereits abgeschlossen (Skip) - Counter DEC:" << normalizedFtpDir;
            // ‚ö° Counter-Decrement auch bei Duplikaten!
            QString host = QUrl(normalizedFtpDir).host();
            int currentActive = activeFtpScansPerHost.value(host, 1);
            // Counter entfernt - ThreadPool regelt Parallelitaet
            return;
        }
        
        qDebug() << "[Scanner] üìÑ FTP-Dateien empfangen f√ºr:" << dir << "Files:" << files.size() << "Success:" << success;
        
        // ÔøΩ 2-PHASEN-STRATEGIE: Im Discovery-Modus KEINE Dateien sammeln!
        if (ftpDiscoveryPhase) {
            qDebug() << "[Scanner] üåê DISCOVERY-MODUS: Verzeichnis erfasst, Dateien ignoriert:" << normalizedFtpDir;
            discoveredFtpDirectories.insert(normalizedFtpDir);
            
            // Counter f√ºr Discovery-Progress
            ftpDiscoveryCompleted++;
            int totalDiscovered = discoveredFtpDirectories.size();
            
            emit currentFileProcessing(
                QString("Discovery: %1 Verzeichnisse gefunden").arg(totalDiscovered),
                QString("üåê Phase 1/2: FTP-Discovery (%1/%2)").arg(ftpDiscoveryCompleted).arg(ftpDiscoveryTotal),
                ftpDiscoveryCompleted,
                ftpDiscoveryTotal
            );
            
            // Pr√ºfe ob Discovery abgeschlossen
            if (ftpDiscoveryCompleted >= ftpDiscoveryTotal && ftpQueuePerHost.value(QUrl(normalizedFtpDir).host()).isEmpty()) {
                qDebug() << "[Scanner] ‚úÖ DISCOVERY ABGESCHLOSSEN:" << totalDiscovered << "Verzeichnisse gefunden";
                onFtpDiscoveryCompleted();
            }
            
            // WICHTIG: Counter decrementieren auch im Discovery-Modus!
            QString host = QUrl(normalizedFtpDir).host();
            int currentActive = activeFtpScansPerHost.value(host, 1);
            // Counter entfernt - ThreadPool regelt Parallelitaet
            
            return;  // Keine Dateien sammeln im Discovery-Modus
        }
        
        // ÔøΩüéØ LIVE QUEUE-INFO: Emittiere SOFORT f√ºr GUI!
        int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
        int completedDirs = completedFtpDirectories.size();
        QString ftpProgressWithQueue = QString("FTP %1/%2").arg(completedDirs).arg(totalFtpDirs);
        if (pendingFtpDirectories.size() > 0) {
            ftpProgressWithQueue += QString(" | Verbleibend: %1").arg(pendingFtpDirectories.size());
        }
        
        qDebug() << "[Scanner] üéØ EMIT currentFileProcessing (LAMBDA):" << ftpProgressWithQueue << "Queue:" << pendingFtpDirectories.size();
        
        emit currentFileProcessing(
            ftpProgressWithQueue,  // ‚úÖ Mit Queue-Info!
            "üì° FTP-Scan",
            completedDirs,
            totalFtpDirs
        );
        
        // üö® CRITICAL MEMORY PROTECTION: Prevent QSet crash for large datasets
        if (files.size() > 25000) {
            qWarning() << "[Scanner] üö® KRITISCH: Gro√üe Datenmenge (" << files.size() << ") - verwende sichere Batch-Verarbeitung";
            // ‚ö° CRITICAL: Counter-Decrement BEFORE return!
            QString host = QUrl(normalizedFtpDir).host();
            int currentActive = activeFtpScansPerHost.value(host, 1);
            // Counter entfernt - ThreadPool regelt Parallelitaet
            processFtpFilesBatch(dir, files, success);
            return;
        }
        
        if (success) {
            // üõ°Ô∏è CRASH-SAFE: Use member variable instead of reference capture
            if (this->processedFiles.size() > 20000) {
                qWarning() << "[Scanner] üö® ProcessedFiles-Cache zu gro√ü (" << this->processedFiles.size() << ") - l√∂sche f√ºr Stabilit√§t";
                this->processedFiles.clear();
            }
            
            // Einheitliche Gro√üdatei-Politik (FTP): env-basiert
            bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
            qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;

            for (const QString &file : files) {
                QString baseFileName = file;
                qint64 fileSize = 0;
                
                // üéØ KRITISCHER FIX: Parse FTP-Dateien mit |Gr√∂√üe-Anhang und verwende base filename!
                if (file.contains("|")) {
                    QStringList fileNameParts = file.split("|");
                    baseFileName = fileNameParts[0];
                    fileSize = fileNameParts[1].toLongLong();
                    // Einheitliche Gro√üdatei-Politik anwenden
                    if (skipLarge && maxSizeMb > 0) {
                        qint64 maxBytes = maxSizeMb * 1024 * 1024;
                        if (fileSize > maxBytes) {
                            qDebug() << "[Scanner] üö´ GROSSE FTP-Datei √ºbersprungen (" << maxSizeMb << "MB):" << baseFileName;
                            continue;
                        }
                    }
                    
                    qDebug() << "[Scanner] üõ°Ô∏è DUPLIKAT-FIX: √úberspringe Gr√∂√üe-Variante:" << file << "‚Üí verwende nur:" << baseFileName;
                    // ‚úÖ KRITISCHER FIX: CONTINUE ENTFERNT - wir verwenden baseFileName weiter!
                }
                
                // üî• REKURSIV-FIX: baseFileName enth√§lt BEREITS vollst√§ndigen Pfad vom rekursiven Scanner!
                // Format: "/share/Jan/Jana/Bilder/Subdir/file.jpg|size"
                // Wir m√ºssen NUR den FTP-Host davor setzen!
                QUrl ftpUrl;
                ftpUrl.setScheme("ftp");
                // ‚úÖ CRITICAL FIX: Extract host from normalizedFtpDir (full URL), not dir (path only)!
                QUrl ftpDirUrl(normalizedFtpDir);
                ftpUrl.setHost(ftpDirUrl.host());  // Get host from full URL
                ftpUrl.setPort(ftpDirUrl.port(21));  // Get port from full URL or default to 21
                
                // baseFileName ist bereits vollst√§ndiger Pfad (z.B. "/share/Jan/Jana/Bilder/Weser_Radtour2010/file.jpg")
                ftpUrl.setPath(baseFileName);
                QString fullPath = ftpUrl.toString();
                
                qDebug() << "[Scanner] üî• REKURSIV: baseFileName:" << baseFileName << "‚Üí fullPath:" << fullPath;
                
                // ÔøΩ Extrahiere NUR den Dateinamen (ohne Pfad) f√ºr Anzeige
                QString justFileName = baseFileName;
                if (baseFileName.contains('/')) {
                    justFileName = baseFileName.mid(baseFileName.lastIndexOf('/') + 1);
                }
                
                // ÔøΩüõ°Ô∏è CRASH-SAFE: Use member variable instead of dangling reference
                QString canonicalPath = QUrl(fullPath).toString();  // FTP-URLs normalisieren
                if (this->processedFiles.contains(canonicalPath)) {
                    qDebug() << "[Scanner] ‚è≠Ô∏è FTP-Datei bereits in diesem Scan verarbeitet (√ºbersprungen):" << canonicalPath.right(50);
                    continue;
                }
                this->processedFiles.insert(canonicalPath);
                
                // ‚úÖ F√ºge FTP-Datei zur Sammlung hinzu mit korrekter Gr√∂√üe
                FileInfo ftpFile;
                ftpFile.filePath = fullPath;
                ftpFile.fileName = justFileName; // üî• NUR Dateiname ohne Pfad!
                ftpFile.size = fileSize;
                ftpFile.lastModified = QDateTime::currentDateTime().toSecsSinceEpoch();
                ftpFile.hash = "";  // Wird sp√§ter berechnet
                ftpFile.isLocal = false;  // FTP-Datei
                ftpFile.networkType = "FTP";
                
                allFiles.append(ftpFile);
                qDebug() << "[Scanner] ‚úÖ FTP-Datei hinzugef√ºgt (ohne |Gr√∂√üe):" << baseFileName << "Size:" << fileSize;
            }
        } else {
            qWarning() << "[Scanner] ‚ö†Ô∏è FTP-Fehler beim Laden von:" << dir;
        }
        
        // ‚úÖ CRITICAL FIX: Mark directory as completed for duplicate prevention
        // normalizedFtpDir is already normalized at function entry (always has port)
        pendingFtpDirectories.removeAll(normalizedFtpDir);
        completedFtpDirectories.append(normalizedFtpDir);
        ftpDirectoriesProcessed++;  // Increment counter
        
        // üöÄ PERFORMANCE: Debug nur alle 25 abgeschlossene Verzeichnisse
        if (ftpDirectoriesProcessed % 25 == 0) {
            qDebug() << "[Scanner] ‚úÖ FTP-Progress:" << completedFtpDirectories.size() 
                     << "completed | Queue:" << pendingFtpDirectories.size();
        }

        // Per-host queue: start next directory for same host if queued
        QString host = QUrl(normalizedFtpDir).host();  // üîß FIX: Use normalizedFtpDir (full URL) not dir (path only)
        // Decrement active scan counter for this host
        int currentActive = activeFtpScansPerHost.value(host, 1);
        // Counter entfernt - ThreadPool regelt Parallelitaet
        
        // üöÄ PERFORMANCE: Debug nur alle 50 Scans (reduziert Output-Overhead)
        static int debugCounter = 0;
        if (++debugCounter % 50 == 0) {
            qDebug() << "[Scanner] Queue-Check Host:" << host << "| Queue:" << ftpQueuePerHost.value(host).size();
        }
        
        // MASSIVE PARALLEL BATCH: Starte ALLE queued Scans sofort!
        int queueSize = ftpQueuePerHost.value(host).size();
        
        // üöÄ ULTRA PARALLEL: Starte bis zu 200 Scans gleichzeitig!
        int maxBatch = (queueSize > 2000) ? 200 : (queueSize > 1000) ? 150 : (queueSize > 500) ? 100 : 50;
        int batchSize = qMin(queueSize, maxBatch);
        
        if (batchSize > 0 && ftpQueuePerHost.contains(host) && !ftpQueuePerHost[host].isEmpty() && urlSpecificClient) {
            if (batchSize >= 10 || queueSize % 200 == 0) {
                qDebug() << "[Scanner] Batch-Drain (" << batchSize << "x parallel) Queue:" << queueSize 
                         << "‚Üí" << (queueSize - batchSize);
            }
            
            for (int i = 0; i < batchSize && !ftpQueuePerHost[host].isEmpty(); ++i) {
                QString nextDir = ftpQueuePerHost[host].takeFirst();
                
                QUrl nextUrl(nextDir);
                QString nextPath = nextUrl.path();
                if (!nextPath.endsWith('/')) nextPath += "/";
                
                collectFtpFiles(nextDir, this->processedFiles, true);
            }
            
            // ‚úÖ CRITICAL FIX: checkScanProgress() NACH jedem Batch (nicht nur bei leerer Queue!)
            checkScanProgress();
            return;
        }

        // No more scans for this host - cleanup
        qDebug() << "[Scanner] Keine Queue mehr f√ºr Host" << host;
        ftpActiveHosts.remove(host);
        activeFtpScansPerHost.remove(host);

        // Disconnect signals to prevent lambda accumulation
        if (urlSpecificClient) {
            QObject::disconnect(urlSpecificClient, nullptr, this, nullptr);
        }

        // Pruefe ob alle FTP-Verzeichnisse fertig sind
        checkScanProgress();
    });
    
    // Starte die Verbindung und Dateiliste (idempotent)
    urlSpecificClient->connectToHost();
    // Ensure path points to a directory
    if (!path.endsWith('/')) path += '/';
    urlSpecificClient->listFiles(path);
    
    qDebug() << "[Scanner] FTP-Collection gestartet fuer" << normalizedFtpDir;
}

void Scanner::checkScanProgress()
{
    qDebug() << "[Scanner] üîç Pr√ºfe Scan-Fortschritt - Pending FTP:" << pendingFtpDirectories.size();
    
    // üìä PROGRESS-UPDATE: FTP-Verarbeitung
    int totalFtpDirs = pendingFtpDirectories.size() + completedFtpDirectories.size();
    if (totalFtpDirs > 0) {
        int progressPercent = (completedFtpDirectories.size() * 100) / totalFtpDirs;
        emit scanProgress(progressPercent, completedFtpDirectories.size(), totalFtpDirs);
        
        // üéØ QUEUE-INFO: Zeige verbleibende FTP-Verzeichnisse
        QString ftpProgressText = QString("FTP-Verzeichnis %1/%2").arg(completedFtpDirectories.size()).arg(totalFtpDirs);
        if (pendingFtpDirectories.size() > 0) {
            ftpProgressText += QString(" | Verbleibend: %1").arg(pendingFtpDirectories.size());
        }
        
        emit currentFileProcessing(
            ftpProgressText,  // ‚úÖ Mit Queue-Info!
            "üì° Lade Netzwerk-Dateien",
            completedFtpDirectories.size(),
            totalFtpDirs
        );
    }
    
    // Wenn alle FTP-Operationen abgeschlossen sind, starte die Hash-Berechnung
    if (pendingFtpDirectories.isEmpty()) {
        qDebug() << "[Scanner] ‚úÖ Alle FTP-Verzeichnisse geladen - starte Hash-Berechnung";
        
        // üõë STOP FTP QUEUE DRAIN TIMER: Alle FTP-Scans abgeschlossen
        if (ftpQueueDrainTimer && ftpQueueDrainTimer->isActive()) {
            ftpQueueDrainTimer->stop();
            qDebug() << "[Scanner] ‚è∞ FTP-Queue-Drain-Timer gestoppt (alle Scans fertig)";
        }
        
        // ‚úÖ FIX: Group files by size BEFORE starting hash calculation
        emit scanProgress(0, 0, allFiles.size());
        emit scanStatusChanged("üìè Sortiere nach Dateigr√∂√üe...");
        emit currentFileProcessing("Dateigruppierung", "üìè Gr√∂√üen-Filterung", 0, allFiles.size());
        currentPhase = SIZE_FILTERING;

        // Group files by size (required for progress calculation)
        for (const FileInfo &file : allFiles)
        {
            fileSizeGroups[file.size].append(file);
        }
        
        qDebug() << "[Scanner] üìä Size-Groups erstellt:" << fileSizeGroups.size() << "verschiedene Gr√∂√üen f√ºr" << allFiles.size() << "Dateien";
        
        // ÔøΩ SPEICHERE Anzahl gesammelter Dateien f√ºr sp√§tere scanCompleted-Emissionen
        m_totalCollectedFiles = allFiles.size();
        qDebug() << "[Scanner] üìä GESPEICHERT (FTP-Path): m_totalCollectedFiles =" << m_totalCollectedFiles;
        
        // ÔøΩüìä SIZE-FILTERING ABGESCHLOSSEN
        emit scanProgress(100, allFiles.size(), allFiles.size());
        emit scanStatusChanged(QString("üìÅ %1 eindeutige Dateien gesammelt (lokal: ‚úÖ, netzwerk: ‚úÖ)").arg(allFiles.size()));
        emit currentFileProcessing(
            QString("%1 Dateien gruppiert").arg(allFiles.size()),
            "‚úÖ Gr√∂√üen-Filterung abgeschlossen",
            allFiles.size(),
            allFiles.size()
        );
        
        // Start hash calculation phase
        if (!allFiles.isEmpty()) {
            emit scanProgress(0, 0, allFiles.size());
            emit scanStatusChanged("üîê Berechne Hash-Werte...");
            emit currentFileProcessing("Hash-Vorbereitung", "üîê Starte Hash-Berechnung", 0, allFiles.size());
            qDebug() << "[Scanner] üîç Starte Hash-Berechnung f√ºr" << allFiles.size() << "Dateien";
            startHashing();
        } else {
            qDebug() << "[Scanner] ‚ö†Ô∏è Keine Dateien zum Hashen gefunden";
            emit scanProgress(100, 0, 0);
            emit scanStatusChanged("‚ö†Ô∏è Keine Dateien gefunden - Verzeichnis ist leer oder unzug√§nglich");
            
            // üî• GUARD: Emittiere nur wenn noch nicht emittiert
            if (!m_scanCompletedEmitted.exchange(true)) {
                DuplicateGroups emptyGroups;
                emit scanCompleted(emptyGroups);
                qDebug() << "[Scanner] üî• EMIT scanCompleted (NO FILES) - totalFiles: 0";
            }
        }
    }
}

// üß† NPU-CALLBACK: NPU-Bildverarbeitung abgeschlossen
void Scanner::onNpuImageBatchProcessed(const QStringList &processedImages)
{
    qDebug() << "[Scanner] üé® NPU-Bildverarbeitung abgeschlossen:" << processedImages.size() << "Bilder verarbeitet";
    
    // üéØ LIVE-NPU-UPDATES f√ºr jedes verarbeitete Bild
    for (int i = 0; i < processedImages.size(); ++i) {
        QString imagePath = processedImages.at(i);
        QString fileName = QFileInfo(imagePath).fileName();
        
        // üìä LIVE-AKTIVIT√ÑTS-UPDATE an GUI senden
        emit currentFileProcessing(fileName, "NPU-Bildanalyse", i + 1, processedImages.size());
        emit processActivityUpdate("NPU-Bildverarbeitung", 
                                   QString("Feature-Extraktion: %1").arg(fileName));
    }
    
    // Statistiken f√ºr NPU-Verarbeitung
    emit scanStatusChanged(QString("üß† NPU-Bildverarbeitung: %1 Bilder analysiert").arg(processedImages.size()));
    
    // üöÄ NPU-AKTIVIT√ÑTS-UPDATE f√ºr Activity-Indicator
    emit npuActivityUpdate(processedImages.size(), 0); // Noch keine Duplikate gefunden
    
    // Hier k√∂nnten wir die NPU-Ergebnisse weiterverarbeiten
    // z.B. f√ºr intelligente Duplikatserkennung basierend auf Bild√§hnlichkeit
}

// üóëÔ∏è FTP-Remove Callback
void Scanner::onFtpRemoveFinished(const QString &remoteFile, bool ok)
{
    deleteAttempted++;
    if (ok) deleteSucceeded++;
    emit deleteProgress(remoteFile, ok, ok ? "FTP gel√∂scht" : "FTP l√∂schen fehlgeschlagen");
    if (deleteAttempted == 0) return; // shouldn‚Äôt happen
}

// üóëÔ∏è Duplikate l√∂schen (Batch)
void Scanner::deleteDuplicateFiles(const QList<FileInfo> &filesToDelete)
{
    deleteAttempted = 0;
    deleteSucceeded = 0;
    for (const auto &fi : filesToDelete) {
        QString msg;
        if (fi.isLocal) {
            bool ok = deleteLocalFile(fi.filePath, msg);
            deleteAttempted++;
            if (ok) deleteSucceeded++;
            emit deleteProgress(fi.filePath, ok, msg);
        } else if (fi.filePath.startsWith("ftp://")) {
            // Sicherheitsnetz: Verzeichnisse nicht l√∂schen
            if (fi.filePath.endsWith('/')) {
                emit deleteProgress(fi.filePath, false, "Verzeichnis-L√∂schen blockiert");
                continue;
            }
            // FTP: Host + Remote Pfad extrahieren
            QUrl u(fi.filePath);
            QString remote = u.path();
            if (remote.startsWith('/')) remote.remove(0,1);
            if (!ftpClient) {
                emit deleteProgress(fi.filePath, false, "Kein FTP-Client verf√ºgbar");
                continue;
            }
            // Anmeldedaten werden vom FtpClient verwaltet; wir rufen remove() auf
            connect(ftpClient, &FtpClient::removeFinished, this, &Scanner::onFtpRemoveFinished, Qt::UniqueConnection);
            ftpClient->remove(remote);
        } else {
            emit deleteProgress(fi.filePath, false, "Unbekannter Netzwerktyp");
        }
    }
    emit deleteBatchFinished(deleteAttempted, deleteSucceeded);
}

// üóëÔ∏è Lokale Datei l√∂schen ‚Üí Papierkorb wenn m√∂glich, sonst hart
bool Scanner::deleteLocalFile(const QString &path, QString &msg)
{
    QFileInfo info(path);
    if (!info.exists() || !info.isFile()) {
        msg = "Nicht gefunden oder keine Datei";
        return false;
    }
    // Versuch: direkt l√∂schen (send2trash w√§re extern, hier Fallback)
    if (QFile::remove(path)) {
        msg = "Gel√∂scht";
        return true;
    }
    msg = "L√∂schen fehlgeschlagen";
    return false;
}

// üõ°Ô∏è NEUE FUNKTION: Deduplication-Caches leeren
void Scanner::clearDeduplicationCaches()
{
    globalProcessedFiles.clear();
    globalHashedFiles.clear();
    processedFiles.clear();  // üõ°Ô∏è KRITISCH: Member-Variable auch leeren!
    
    // üßπ ERWEITERTE MEMORY-BEREINIGUNG
    // Nur leeren wenn bereits verarbeitet (nicht w√§hrend aktiver Scan)
    if (!scanning.load()) {
        allFiles.clear();
        allFiles.squeeze(); // Force deallocation
        
        fileSizeGroups.clear();
        hashGroups.clear();
        dateSizeGroups.clear();
        
        extractedFeatures.clear();
        extractedFeatures.squeeze(); // Force deallocation
        
        imageDuplicateGroups.clear();
        imageDuplicateGroups.squeeze(); // Force deallocation
        
        // Directory iterators cleanup
        currentDirIterators.clear();
        
        qDebug() << "[Scanner] üßπ ERWEITERTE Memory-Bereinigung durchgef√ºhrt";
    }
    
    qDebug() << "[Scanner] üõ°Ô∏è Deduplication-Caches geleert (inkl. processedFiles)";
}

// üõ°Ô∏è NEUE FUNKTION: Pr√ºfung ob Datei bereits verarbeitet wurde
bool Scanner::isFileAlreadyProcessed(const QString &filePath)
{
    QString canonicalPath = QFileInfo(filePath).canonicalFilePath();
    return globalProcessedFiles.contains(canonicalPath);
}

// üß† MEMORY-SAFE: Batch-Verarbeitung f√ºr gro√üe FTP-Datens√§tze (>25.000 Dateien)
void Scanner::processFtpFilesBatch(const QString &directoryOrUrl, const QStringList &files, bool success)
{
    qDebug() << "[Scanner] üß† BATCH-VERARBEITUNG f√ºr" << files.size() << "Dateien gestartet";
    
    const int batchSize = 5000; // 5K Dateien pro Batch
    int totalBatches = (files.size() + batchSize - 1) / batchSize;
    // Ermittele Basis-URL f√ºr korrekte Pfadkonstruktion
    QString baseUrl = directoryOrUrl;
    if (!baseUrl.startsWith("ftp://")) {
        auto normalizePath = [](QString p) {
            if (p.isEmpty()) return p;
            if (!p.startsWith('/')) p.prepend('/');
            if (p.length() > 1 && p.endsWith('/')) p.chop(1);
            return p;
        };
        const QString dirNorm = normalizePath(directoryOrUrl);
        for (const QString &pendingUrl : pendingFtpDirectories) {
            QUrl url(pendingUrl);
            const QString pendNorm = normalizePath(url.path());
            if (pendNorm == dirNorm || normalizePath(url.path() + "/") == dirNorm) {
                baseUrl = pendingUrl;
                break;
            }
        }
    }
    
    for (int batch = 0; batch < totalBatches; batch++) {
        int startIdx = batch * batchSize;
        int endIdx = qMin(startIdx + batchSize, files.size());
        
        QStringList batchFiles = files.mid(startIdx, endIdx - startIdx);
        qDebug() << "[Scanner] üß† Verarbeite Batch" << (batch + 1) << "/" << totalBatches 
                 << ":" << batchFiles.size() << "Dateien";
        
        // ‚úÖ Direkte Verarbeitung ohne rekursiven Aufruf mit korrekter Basis-URL
        processSingleFtpBatch(baseUrl, batchFiles);
        
        // üõ°Ô∏è Memory-Cleanup zwischen Batches
        if (batch % 2 == 0) { // Every 2nd batch
            clearDeduplicationCaches();
            
            // üßπ AGGRESSIVE Memory-Cleanup f√ºr gro√üe Datens√§tze
            if (batch % 10 == 0 && allFiles.size() > 5000) {
                // Periodisches Memory-Defragmentierung bei gro√üen Datens√§tzen
                allFiles.squeeze();
                qDebug() << "[Scanner] üíæ Aggressive Memory-Defragmentierung bei" << allFiles.size() << "Dateien";
            }
            
            qDebug() << "[Scanner] üßπ Batch-Memory-Cleanup durchgef√ºhrt";
        }
        
        // Kurze Pause zwischen Batches um Memory-Pressure zu reduzieren
        QThread::msleep(50);
    }
    
    // Mark directory as completed after all batches
    pendingFtpDirectories.removeOne(directoryOrUrl);
    checkScanProgress();
    
    qDebug() << "[Scanner] ‚úÖ BATCH-VERARBEITUNG abgeschlossen:" << totalBatches << "Batches verarbeitet";
}

// üß† MEMORY-SAFE: Einzelner Batch ohne Rekursion
void Scanner::processSingleFtpBatch(const QString &baseUrl, const QStringList &files)
{
    // ‚úÖ Einfache Batch-Verarbeitung ohne komplexe NPU-Logik
    // Einheitliche Gro√üdatei-Politik (FTP): env-basiert
    bool skipLarge = qEnvironmentVariableIsSet("FILEDUPER_SKIP_LARGE") && (qgetenv("FILEDUPER_SKIP_LARGE") == "1");
    qint64 maxSizeMb = qEnvironmentVariableIsSet("FILEDUPER_MAX_SIZE_MB") ? qgetenv("FILEDUPER_MAX_SIZE_MB").toLongLong() : 0;
    for (const QString &fileName : files) {
        // ‚úÖ Erstelle FileInfo ohne QSet-Overhead
        QString filePath;
        qint64 fileSize = 0;
        
        // Parse file info (name|size format)
        if (fileName.contains('|')) {
            QStringList parts = fileName.split('|');
            QString name = parts[0];
            if (parts.size() > 1) {
                fileSize = parts[1].toLongLong();
            }
            // Einheitliche Gro√üdatei-Politik anwenden
            if (skipLarge && maxSizeMb > 0) {
                qint64 maxBytes = maxSizeMb * 1024 * 1024;
                if (fileSize > maxBytes) {
                    qDebug() << "[Scanner] üö´ GROSSE FTP-Datei √ºbersprungen (Batch) (" << maxSizeMb << "MB):" << name;
                    continue;
                }
            }
            filePath = name;
        } else {
            filePath = fileName;
        }
        
        // ‚úÖ Create FTP FileInfo - extract host from directory context
        FileInfo fileInfo;
        fileInfo.fileName = QFileInfo(filePath).fileName();
        
        // ‚úÖ Proper URL construction: baseUrl is a full FTP URL already
        QString url = baseUrl;
        if (!url.endsWith('/')) url += '/';
        fileInfo.filePath = url + QUrl::toPercentEncoding(fileInfo.fileName);
        
        fileInfo.size = fileSize;
        fileInfo.lastModified = QDateTime::currentSecsSinceEpoch();
        fileInfo.hash = "";
        fileInfo.isLocal = false;
        fileInfo.networkType = "FTP";
        
        // ‚úÖ Add to main file list (thread-safe)
        allFiles.append(fileInfo);
    }
    
    qDebug() << "[Scanner] ‚úÖ Batch-Dateien hinzugef√ºgt:" << files.size() << "Total:" << allFiles.size();
}

// üéØ NPU-BILDVERARBEITUNG: Feature-basierte √Ñhnlichkeitsanalyse
void Scanner::startNpuImageAnalysis(const QStringList &imagePaths) {
    if (!npuManager) {
        qWarning() << "[Scanner] ‚ùå NPU-Manager nicht verf√ºgbar - √ºberspringe Bildanalyse";
        return;
    }
    
    qDebug() << "[Scanner] üéØ NPU-Bildanalyse startet f√ºr" << imagePaths.size() << "Bilder";
    emit npuAnalysisProgress("Extrahiere Bildfeatures mit NPU...");
    
    // Extrahiere Features f√ºr alle Bilder
    extractedFeatures = npuManager->extractImageFeatures(imagePaths);
    emit imageFeaturesExtracted(extractedFeatures);
    
    // F√ºhre √Ñhnlichkeitsanalyse durch
    emit npuAnalysisProgress("Analysiere Bild√§hnlichkeiten...");
    processImageFeatures(extractedFeatures);
}

void Scanner::processImageFeatures(const QList<NpuManager::ImageFeature> &features) {
    if (features.isEmpty()) {
        qDebug() << "[Scanner] ‚ö†Ô∏è Keine g√ºltigen Bildfeatures - √ºberspringe NPU-Analyse";
        return;
    }
    
    qDebug() << "[Scanner] üîç Verarbeite" << features.size() << "Bildfeatures";
    
    // Verwende konfigurierbaren √Ñhnlichkeitsmodus (Standard: NEAR_DUPLICATES)
    QList<NpuManager::NpuDuplicateGroup> npuGroups = npuManager->findSimilarImages(features, currentSimilarityMode);
    
    // Konvertiere NPU-Gruppen zu Scanner-Format
    imageDuplicateGroups.clear();
    for (const auto &npuGroup : npuGroups) {
        ImageDuplicateGroup scannerGroup;
        scannerGroup.originalImage = npuGroup.originalImage;
        scannerGroup.duplicateImages = npuGroup.similarImages;
        scannerGroup.averageSimilarity = npuGroup.avgSimilarity;
        
        // Bestimme Gruppen-Typ basierend auf √Ñhnlichkeit
        if (npuGroup.avgSimilarity >= 0.95f) scannerGroup.groupType = "STRICT";
        else if (npuGroup.avgSimilarity >= 0.85f) scannerGroup.groupType = "NEAR";
        else if (npuGroup.avgSimilarity >= 0.70f) scannerGroup.groupType = "SIMILAR";
        else scannerGroup.groupType = "LOOSE";
        
        imageDuplicateGroups.append(scannerGroup);
    }
    
    qDebug() << "[Scanner] ‚úÖ NPU-Analyse abgeschlossen:" << imageDuplicateGroups.size() << "Bild-Duplikat-Gruppen";
    emit imageDuplicatesFound(imageDuplicateGroups);
}

// Filtere Bilddateien aus allen gefundenen Dateien
QStringList Scanner::filterImageFiles(const QList<FileInfo> &allFiles) {
    QStringList imagePaths;
    QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp"};
    
    for (const FileInfo &file : allFiles) {
        if (isImageFile(file.filePath)) {
            imagePaths.append(file.filePath);
        }
    }
    
    qDebug() << "[Scanner] üñºÔ∏è " << imagePaths.size() << "Bilddateien von" << allFiles.size() << "Dateien gefiltert";
    return imagePaths;
}

// Pr√ºfe ob Datei ein Bild ist
bool Scanner::isImageFile(const QString &filePath) const {
    static QStringList imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".svg"};
    
    QString lowerPath = filePath.toLower();
    for (const QString &ext : imageExtensions) {
        if (lowerPath.endsWith(ext)) {
            return true;
        }
    }
    return false;
}

// Kombiniere Hash- und NPU-basierte Ergebnisse
CombinedDuplicateResult Scanner::combineHashAndImageResults() {
    CombinedDuplicateResult combined;
    
    // Hash-basierte Duplikate aus aktuellen Gruppen
    for (const auto &sizeGroup : fileSizeGroups) {
        if (sizeGroup.size() > 1) {
            QHash<QString, QList<FileInfo>> hashMap;
            for (const FileInfo &file : sizeGroup) {
                if (!file.hash.isEmpty()) {
                    hashMap[file.hash].append(file);
                }
            }
            
            for (auto it = hashMap.begin(); it != hashMap.end(); ++it) {
                if (it.value().size() > 1) {
                    DuplicateGroup group;
                    group.hash = it.key();
                    group.size = it.value().first().size;
                    group.original = it.value().first();
                    
                    for (int i = 1; i < it.value().size(); ++i) {
                        group.duplicates.append(it.value()[i]);
                    }
                    
                    combined.hashDuplicates.append(group);
                }
            }
        }
    }
    
    // NPU-basierte Bild-Duplikate hinzuf√ºgen
    combined.imageDuplicates = imageDuplicateGroups;
    
    qDebug() << "[Scanner] üîó Kombinierte Ergebnisse:" << combined.hashDuplicates.size() << "Hash-Gruppen," << combined.imageDuplicates.size() << "Bild-Gruppen";
    return combined;
}

// Erweiterte Duplikatserkennung: Hash + NPU kombiniert
void Scanner::startAdvancedDuplicateDetection() {
    qDebug() << "[Scanner] üöÄ Erweiterte Duplikatserkennung startet (Hash + NPU)";
    
    // Phase 1: Traditionelle Hash-basierte Duplikaterkennung
    emit scanStatusChanged("Berechne File-Hashes...");
    compareHashes();
    
    // Phase 2: NPU-basierte Bild√§hnlichkeitsanalyse
    if (npuManager) {
        QStringList imagePaths = filterImageFiles(allFiles);
        if (!imagePaths.isEmpty()) {
            emit scanStatusChanged("NPU analysiert Bild√§hnlichkeiten...");
            currentSimilarityMode = NpuManager::NEAR_DUPLICATES; // Konfigurierbar
            startNpuImageAnalysis(imagePaths);
        }
    }
    
    // Phase 3: Kombiniere Ergebnisse
    emit scanStatusChanged("Kombiniere Duplikat-Ergebnisse...");
    CombinedDuplicateResult combined = combineHashAndImageResults();
    emit combinedScanCompleted(combined);
}

// Implementierung f√ºr CombinedDuplicateResult::totalDuplicates()
int CombinedDuplicateResult::totalDuplicates() const {
    int total = 0;
    for (const DuplicateGroup &group : hashDuplicates) {
        total += group.duplicates.size();
    }
    for (const ImageDuplicateGroup &group : imageDuplicates) {
        total += group.duplicateImages.size();
    }
    return total;
}

void Scanner::processNextFile()
{
    // No longer used - processing is handled by HashEngine callbacks
    // This method is kept for compatibility but should not be called
    qDebug() << "[Scanner] ‚ö†Ô∏è processNextFile() called - should use HashEngine callbacks instead";
}

// ‚ö° OPTIMIERUNG: Erstelle partielle Results f√ºr Anti-Hang Mechanismus
DuplicateGroups Scanner::buildPartialResults() {
    DuplicateGroups partialResults;
    
    qDebug() << "[Scanner] üîß Erstelle partielle Results f√ºr Anti-Hang...";
    
    // Sammle alle bereits gehashten Dateien mit identischen Hashes
    QHash<QString, QList<FileInfo>> hashGroups;
    
    for (auto groupIt = fileSizeGroups.begin(); groupIt != fileSizeGroups.end(); ++groupIt) {
        const QList<FileInfo> &filesInGroup = groupIt.value();
        for (const FileInfo &file : filesInGroup) {
            if (!file.hash.isEmpty() && 
                file.hash != "FTP_SKIPPED" && 
                file.hash != "FTP_DOWNLOAD_FAILED" &&
                file.hash != "GPU_ERROR") {
                hashGroups[file.hash].append(file);
            }
        }
    }
    
    // Erstelle DuplicateGroups aus Hash-Matches
    for (auto hashIt = hashGroups.begin(); hashIt != hashGroups.end(); ++hashIt) {
        const QString &hash = hashIt.key();
        const QList<FileInfo> &files = hashIt.value();
        if (files.size() > 1) {
            DuplicateGroup group;
            group.hash = hash;
            group.size = files.first().size;
            
            // Bestimme Original (√§lteste Datei)
            FileInfo oldest = files.first();
            for (const FileInfo &file : files) {
                if (file.lastModified < oldest.lastModified) {
                    oldest = file;
                }
            }
            
            group.original = oldest;
            for (const FileInfo &file : files) {
                if (file.filePath != oldest.filePath) {
                    group.duplicates.append(file);
                }
            }
            
            if (!group.duplicates.isEmpty()) {
                partialResults.groups.append(group);
            }
        }
    }
    
    // üî• KRITISCH: Setze totalFiles f√ºr korrekte GUI-Anzeige
    partialResults.totalFiles = hashGroups.size();
    
    qDebug() << "[Scanner] ‚úÖ Partielle Results:" << partialResults.groups.size() << "Duplikat-Gruppen erstellt";
    return partialResults;
}

// ‚ö° OPTIMIERUNG: Cache-Processing f√ºr FTP-Dateien
void Scanner::processCachedFtpFiles(const QString &ftpDirectory, const QStringList &files, QSet<QString> &processedFiles) {
    qDebug() << "[Scanner] ‚ö° Verarbeite" << files.size() << "gecachte FTP-Dateien f√ºr:" << ftpDirectory;
    
    for (const QString &file : files) {
        // Skip bereits verarbeitete Dateien
        if (processedFiles.contains(file)) continue;
        
        // ‚úÖ KRITISCH: Filter FTP-|size Variants
        if (file.contains("|")) {
            qDebug() << "[Scanner] üîß DUPLIKAT-FIX: Filtere |size variant:" << file;
            continue;
        }
    // FTP cached entries are names, not local paths; build proper URL
    QString fullPath = ftpDirectory;
    if (!fullPath.endsWith('/')) fullPath += '/';
    fullPath += file;

    FileInfo info;
    info.filePath = fullPath;
    info.fileName = file;
    info.size = 0; // unknown from cache (will be set later)
    info.lastModified = QDateTime::currentSecsSinceEpoch();
    info.hash = "";
    info.isLocal = false;
    info.networkType = "FTP";

    allFiles.append(info);
    processedFiles.insert(file);
    }
}

// ‚ö° OPTIMIERUNG: FTP-Client Pool f√ºr Connection-Reuse
FtpClient* Scanner::getOrCreateFtpClient(const QString &host) {
    static QHash<QString, QList<FtpClient*>> clientPool;
    static const int MAX_CLIENTS_PER_HOST = 150;  // üöÄ ULTRA: 150 parallele Verbindungen!
    
    // üöÄ CONNECTION POOLING: Wiederverwendung bis zu 150 Clients pro Host
    if (clientPool.contains(host) && !clientPool[host].isEmpty()) {
        // Finde ersten nicht-busy Client
        for (FtpClient *client : clientPool[host]) {
            if (!client->property("busy").toBool()) {
                client->setProperty("busy", true);
                qDebug() << "[Scanner] ‚ôªÔ∏è Wiederverwendeter Client #" << clientPool[host].indexOf(client) << "f√ºr:" << host;
                return client;
            }
        }
    }
    
    // Erstelle neuen Client wenn Pool noch nicht voll
    if (!clientPool.contains(host) || clientPool[host].size() < MAX_CLIENTS_PER_HOST) {
        FtpClient *client = new FtpClient(this);
        client->setProperty("busy", true);
        client->setProperty("host", host);
        
        if (!clientPool.contains(host)) {
            clientPool[host] = QList<FtpClient*>();
        }
        clientPool[host].append(client);
        
        qDebug() << "[Scanner] üÜï Neuer Client #" << clientPool[host].size() << "/" << MAX_CLIENTS_PER_HOST << "f√ºr:" << host;
        return client;
    }
    
    // Pool voll - warte und verwende ersten verf√ºgbaren (sollte nie passieren mit ThreadPool)
    qWarning() << "[Scanner] ‚ö†Ô∏è Client-Pool voll (" << MAX_CLIENTS_PER_HOST << "), verwende ersten";
    FtpClient *client = clientPool[host].first();
    client->setProperty("busy", true);
    return client;
}

// ‚ö° FALLBACK: Default-Credentials wenn PresetManager fehlt
void Scanner::useDefaultFtpCredentials(FtpClient *client, const QString &host) {
    qDebug() << "[Scanner] üîë Verwende Default-Credentials f√ºr:" << host;
    
    // Standard FTP-Credentials (Anonymous oder h√§ufige Kombinationen)
    QStringList commonUsers = {"ftp", "anonymous", "guest", "user", "admin"};
    QStringList commonPasses = {"", "anonymous", "guest", "password", "admin"};
    
    // Verwende erste Kombination als Default
    client->setCredentials(host, 21, commonUsers.first(), commonPasses.first());
}

// ‚úÖ Asynchrone Dateisammlung - GUI-responsive und crash-sicher
void Scanner::startAsyncFileCollection() {
    qDebug() << "[Scanner] üöÄ Starte asynchrone Dateisammlung f√ºr" << scanDirectories.size() << "Verzeichnisse";
    
    // Reset state
    directoriesToProcess.clear();
    cleanupFileCollection();
    allFiles.clear();
    processedFiles.clear();
    currentDirectoryIndex = 0;
    filesFoundInCurrentDir = 0;
    
    // üéØ SMART REDUNDANCY FILTER: Entferne Parent-Verzeichnisse wenn Child bereits ausgew√§hlt
    QStringList filteredDirectories;
    
    for (const QString &dir : scanDirectories) {
        bool isRedundant = false;
        
        // Normalisiere Pfad (entferne trailing slash f√ºr Vergleich)
        QString normalizedDir = dir;
        if (normalizedDir.endsWith('/') && normalizedDir.length() > 1) {
            normalizedDir.chop(1);
        }
        
        // Pr√ºfe ob ein anderes Verzeichnis ein CHILD von diesem ist
        for (const QString &otherDir : scanDirectories) {
            if (dir == otherDir) continue; // Skip sich selbst
            
            QString normalizedOther = otherDir;
            if (normalizedOther.endsWith('/') && normalizedOther.length() > 1) {
                normalizedOther.chop(1);
            }
            
            // Ist otherDir ein Child von dir? (otherDir startet mit dir/)
            if (normalizedOther.startsWith(normalizedDir + "/")) {
                qDebug() << "[Scanner] üîç REDUNDANT: Parent" << normalizedDir 
                         << "wird √ºbersprungen weil Child" << normalizedOther << "ausgew√§hlt ist";
                isRedundant = true;
                break;
            }
        }
        
        if (!isRedundant) {
            filteredDirectories.append(dir);
            qDebug() << "[Scanner] ‚úÖ Verzeichnis zur Scan-Queue hinzugef√ºgt:" << dir;
        }
    }
    
    // F√ºlle Queue mit gefilterten Verzeichnissen
    for (const QString &dir : filteredDirectories) {
        directoriesToProcess.enqueue(dir);
    }
    
    int removedCount = scanDirectories.size() - filteredDirectories.size();
    if (removedCount > 0) {
        qDebug() << "[Scanner] üéØ Redundanz-Filter: Entfernt" << removedCount 
                 << "Parent-Verzeichnisse (behalten:" << filteredDirectories.size() << ")";
    }
    
    qDebug() << "[Scanner] üìä Scan-Queue:" << directoriesToProcess.size() 
             << "Verzeichnisse (nach Redundanz-Filterung)";
    
    emit scanStatusChanged(QString("Sammle Dateien aus %1 Verzeichnissen...").arg(directoriesToProcess.size()));
    
    // MASSIVE PARALLELITAET: Starte ALLE FTP-Verzeichnisse SOFORT!
    QStringList ftpDirs;
    QStringList localDirs;
    
    while (!directoriesToProcess.isEmpty()) {
        QString dir = directoriesToProcess.dequeue();
        if (dir.startsWith("ftp://") || dir.startsWith("sftp://") || dir.startsWith("smb://")) {
            ftpDirs.append(dir);
        } else {
            localDirs.append(dir);
        }
    }
    
    qDebug() << "[Scanner] BATCH START:" << ftpDirs.size() << "FTP-Dirs +" << localDirs.size() << "local Dirs";
    
    // FTP: Starte ALLE parallel (200 ThreadPool!)
    for (const QString &ftpDir : ftpDirs) {
        collectFtpFiles(ftpDir, processedFiles, false);
    }
    
    // Local: Re-queue f√ºr Timer
    for (const QString &localDir : localDirs) {
        directoriesToProcess.enqueue(localDir);
    }
    
    // Starte Timer nur f√ºr lokale Verzeichnisse
    if (!directoriesToProcess.isEmpty()) {
        fileCollectionTimer->start();
    } else if (ftpDirs.isEmpty()) {
        // Keine Verzeichnisse -> direkt zur Size-Filtering Phase
        filterBySize();
    }
}

void Scanner::processNextDirectoryChunk() {
    if (!scanning.load() || directoriesToProcess.isEmpty()) {
        // Sammlung abgeschlossen
        cleanupFileCollection();
        
        if (scanning.load()) {
            qDebug() << "[Scanner] ‚úÖ Dateisammlung abgeschlossen:" << allFiles.size() << "Dateien gefunden";
            emit scanStatusChanged(QString("Sammlung abgeschlossen: %1 Dateien gefunden").arg(allFiles.size()));
            
            // üî• KRITISCH: Rufe filterBySize() NUR wenn KEIN FTP-Scan aktiv!
            // Bei FTP-Scans wird der Workflow von checkScanProgress() fortgesetzt
            if (pendingFtpDirectories.isEmpty()) {
                qDebug() << "[Scanner] ‚úÖ Kein FTP-Scan aktiv - starte Size-Filtering direkt";
                QTimer::singleShot(100, this, &Scanner::filterBySize);
            } else {
                qDebug() << "[Scanner] ‚è≥ FTP-Scan aktiv (" << pendingFtpDirectories.size() 
                         << "pending) - warte auf checkScanProgress() f√ºr Size-Filtering";
                emit scanStatusChanged(QString("Warte auf %1 FTP-Verzeichnisse...").arg(pendingFtpDirectories.size()));
            }
        }
        return;
    }
    
    // Verarbeite das n√§chste Verzeichnis oder chunk
    if (!currentDirIterator) {
        // Starte neues Verzeichnis
        QString currentDir = directoriesToProcess.dequeue();
        currentDirectoryIndex++;
        filesFoundInCurrentDir = 0;
        
        qDebug() << "[Scanner] üìÇ Bearbeite Verzeichnis" << currentDirectoryIndex << "/" 
                 << (currentDirectoryIndex + directoriesToProcess.size()) << ":" << currentDir;
        
        emit currentFileProcessing(
            QFileInfo(currentDir).fileName(),
            "üìÅ Sammle Dateien",
            currentDirectoryIndex,
            currentDirectoryIndex + directoriesToProcess.size()
        );
        
        if (currentDir.startsWith("ftp://")) {
            // FTP-Verzeichnis - verwende bestehende FTP-Logik
            collectFtpFiles(currentDir, processedFiles);
            // FTP ist asynchron - warte auf Completion
            return;
        } else {
            // Lokales Verzeichnis - erstelle Iterator
            currentDirIterator = new QDirIterator(currentDir, QDir::Files | QDir::Readable, QDirIterator::Subdirectories);
        }
    }
    
    // Verarbeite Chunk von Dateien (z.B. 20 Dateien pro Timer-Event)
    int filesProcessedInChunk = 0;
    const int MAX_FILES_PER_CHUNK = 20;
    
    while (currentDirIterator && currentDirIterator->hasNext() && filesProcessedInChunk < MAX_FILES_PER_CHUNK) {
        if (!scanning.load()) return;
        
        QString filePath = currentDirIterator->next();
        QFileInfo fileInfo(filePath);
        
        // Normale Dateiverarbeitung
        QString canonicalPath = fileInfo.canonicalFilePath();
        if (canonicalPath.isEmpty()) {
            canonicalPath = fileInfo.absoluteFilePath();
        }
        
        if (processedFiles.contains(canonicalPath)) {
            filesProcessedInChunk++;
            continue;  // Skip duplicate
        }
        
        processedFiles.insert(canonicalPath);
        filesFoundInCurrentDir++;
        
        // Erstelle FileInfo
        FileInfo file;
        file.filePath = canonicalPath;
        file.fileName = fileInfo.fileName();
        file.size = fileInfo.size();
        file.lastModified = fileInfo.lastModified().toSecsSinceEpoch();
        file.isLocal = true;
        
        allFiles.append(file);
        filesProcessedInChunk++;
        
        // Progress update alle 100 Dateien
        if (allFiles.size() % 100 == 0) {
            emit processActivityUpdate(
                QString("üìä %1 Dateien gefunden").arg(allFiles.size()),
                QString("Aktuell: %1").arg(fileInfo.fileName())
            );
        }
    }
    
    // Pr√ºfe ob aktuelles Verzeichnis abgeschlossen ist
    if (currentDirIterator && !currentDirIterator->hasNext()) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
        
        qDebug() << "[Scanner] ‚úÖ Verzeichnis abgeschlossen:" << filesFoundInCurrentDir << "Dateien gefunden";
    }
}

void Scanner::cleanupFileCollection() {
    if (fileCollectionTimer) {
        fileCollectionTimer->stop();
    }
    
    if (currentDirIterator) {
        delete currentDirIterator;
        currentDirIterator = nullptr;
    }
    
    directoriesToProcess.clear();
}

// üîê PERSISTENTE SCAN-HISTORY: Verhindert mehrfaches Scannen
void Scanner::loadScanHistory() {
    QFile file(scanHistoryFile);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qDebug() << "[Scanner] üìú Keine Scan-History gefunden - erstelle neue";
        return;
    }
    
    QTextStream in(&file);
    QString section;
    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();
        
        if (line.isEmpty()) continue;
        
        if (line == "[DIRECTORIES]") {
            section = "dirs";
            continue;
        } else if (line == "[FILES]") {
            section = "files";
            continue;
        }
        
        if (section == "dirs") {
            scannedDirectoriesHistory.insert(line);
        } else if (section == "files") {
            scannedFilesHistory.insert(line);
        }
    }
    
    file.close();
    qDebug() << "[Scanner] ‚úÖ Scan-History geladen:" << scannedDirectoriesHistory.size() 
             << "Verzeichnisse," << scannedFilesHistory.size() << "Dateien";
}

void Scanner::saveScanHistory() {
    QFile file(scanHistoryFile);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "[Scanner] ‚ùå Konnte Scan-History nicht speichern:" << scanHistoryFile;
        return;
    }
    
    QTextStream out(&file);
    
    // Schreibe Verzeichnisse
    out << "[DIRECTORIES]\n";
    for (const QString &dir : scannedDirectoriesHistory) {
        out << dir << "\n";
    }
    
    out << "\n[FILES]\n";
    // Schreibe nur die letzten 10000 Dateien (Speicheroptimierung)
    QStringList filesList = scannedFilesHistory.values();
    int startIdx = qMax(0, filesList.size() - 10000);
    for (int i = startIdx; i < filesList.size(); ++i) {
        out << filesList[i] << "\n";
    }
    
    file.close();
    qDebug() << "[Scanner] üíæ Scan-History gespeichert:" << scannedDirectoriesHistory.size() 
             << "Verzeichnisse," << qMin(10000, scannedFilesHistory.size()) << "Dateien";
}

void Scanner::clearScanHistory() {
    scannedDirectoriesHistory.clear();
    scannedFilesHistory.clear();
    
    QFile::remove(scanHistoryFile);
    qDebug() << "[Scanner] üóëÔ∏è Scan-History gel√∂scht";
}

bool Scanner::isDirectoryInHistory(const QString &dir) const {
    QString canonical = QDir(dir).canonicalPath();
    
    // Pr√ºfe exakte √úbereinstimmung
    if (scannedDirectoriesHistory.contains(canonical)) {
        return true;
    }
    
    // Pr√ºfe ob Elternverzeichnis bereits gescannt wurde
    for (const QString &scannedDir : scannedDirectoriesHistory) {
        if (canonical.startsWith(scannedDir + "/")) {
            qDebug() << "[Scanner] üîç Verzeichnis bereits in History (als Subdir von:" << scannedDir << ")";
            return true;
        }
    }
    
    return false;
}

bool Scanner::isFileInHistory(const QString &filePath) const {
    QString canonical = QFileInfo(filePath).canonicalFilePath();
    return scannedFilesHistory.contains(canonical);
}

void Scanner::addToScanHistory(const QString &path, bool isDirectory) {
    if (isDirectory) {
        QString canonical = QDir(path).canonicalPath();
        scannedDirectoriesHistory.insert(canonical);
        qDebug() << "[Scanner] üìù Verzeichnis zur History hinzugef√ºgt:" << canonical;
    } else {
        QString canonical = QFileInfo(path).canonicalFilePath();
        scannedFilesHistory.insert(canonical);
    }
}

bool Scanner::isScanning() const { return scanning.load(); }
bool Scanner::isPaused() const { return paused.load(); }

// üåê FTP 2-PHASEN-STRATEGIE: Discovery Phase
void Scanner::startFtpDiscovery(const QStringList &ftpRootDirectories) {
    qDebug() << "[Scanner] üåê VEREINFACHTE STRATEGIE: Nutze normalen Scan-Flow";
    qDebug() << "[Scanner] ÔøΩ FTP-Verzeichnisse werden w√§hrend Scan dynamisch entdeckt";
    
    // ‚úÖ EINFACHERE L√ñSUNG: Statt 2 Phasen - zeige einfach besseres Progress-Feedback
    // Die Verzeichnis-Anzahl wird sich w√§hrend Scan erh√∂hen (z.B. 11 ‚Üí 35765)
    // Das ist NORMAL und OK - wichtig ist dass Counter stabil bleibt
    
    emit scanStatusChanged(QString("üì° Starte FTP-Scan mit %1 root directories (rekursiv)").arg(ftpRootDirectories.size()));
    
    // Nutze bestehenden Flow - kein Bedarf f√ºr separate Discovery
    onFtpDiscoveryCompleted();
}

void Scanner::onFtpDiscoveryCompleted() {
    qDebug() << "[Scanner] üöÄ PHASE 2: FTP-Discovery abgeschlossen -" << discoveredFtpDirectories.size() << "Verzeichnisse gefunden";
    emit scanStatusChanged(QString("‚úÖ Phase 1/2 abgeschlossen: %1 FTP-Verzeichnisse gefunden").arg(discoveredFtpDirectories.size()));
    
    // Wechsel zu Scan-Modus
    ftpDiscoveryPhase = false;
    
    // Setze pendingFtpDirectories auf alle entdeckten Verzeichnisse
    pendingFtpDirectories.clear();
    completedFtpDirectories.clear();
    
    for (const QString &dir : discoveredFtpDirectories) {
        pendingFtpDirectories.append(dir);
    }
    
    qDebug() << "[Scanner] üìä PHASE 2: Starte Datei-Scan mit" << pendingFtpDirectories.size() << "FTP-Verzeichnissen";
    emit scanStatusChanged(QString("üöÄ Phase 2/2: Scanne %1 FTP-Verzeichnisse...").arg(pendingFtpDirectories.size()));
    
    // Kombiniere mit lokalen Verzeichnissen
    QStringList allDirectories = localDirectoriesForLaterScan;
    allDirectories.append(pendingFtpDirectories);
    
    qDebug() << "[Scanner] üìÇ Gesamt:" << localDirectoriesForLaterScan.size() << "lokal +" << pendingFtpDirectories.size() << "FTP";
    
    // Jetzt normale Scan-Pipeline fortsetzen
    scanDirectories = allDirectories;
    
    // Starte asynchrone Dateisammlung
    startAsyncFileCollection();
}

void Scanner::startFtpScan() {
    qDebug() << "[Scanner] üì° Scan l√§uft bereits via collectFtpFiles()";
    // Dummy - wird durch normalen Flow ersetzt
}
