// FileDuper - ImGui Version
// Full-featured duplicate file scanner with GUI

#include <GLFW/glfw3.h>
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <sstream>
#include <ctime>
#include <sys/stat.h>
#include <dirent.h>
#include <algorithm>
#include <unistd.h>
#include <sys/types.h>
#include <mntent.h>
#include <sys/statvfs.h>
#include <cstring>

// Server Preset Structure
struct ServerPreset {
    std::string name;        // Benutzerfreundlicher Name
    std::string ip;          // IP oder Hostname
    std::string type;        // "FTP", "SMB", "NFS"
    int port;                // Port (21 für FTP, 445 für SMB, 2049 für NFS)
    std::string username;
    std::string password;
};

// Application State
struct AppState {
    // Selected directories (unified for local and remote)
    std::set<std::string> selectedDirs;  // Format: "path" or "ftp://ip/path"
    
    // Server Presets
    std::vector<ServerPreset> savedServers;
    
    // Scan state
    bool scanning = false;
    float scanProgress = 0.0f;
    std::string scanStatus = "Bereit";
    int filesScanned = 0;
    int totalFiles = 0;
    long long totalBytes = 0;
    long long bytesProcessed = 0;
    
    // Performance metrics
    float hashSpeed = 0.0f; // MB/s
    float filesPerSecond = 0.0f;
    int threadsActive = 0;
    time_t scanStartTime = 0;
    time_t estimatedTimeRemaining = 0;
    
    // Results
    int duplicateGroups = 0;
    int duplicateFiles = 0;
    long long duplicateSize = 0;
    
    // UI State
    bool showAbout = false;
    bool showSettings = false;
    bool showLocalBrowser = false;
    bool showFtpBrowser = false;
    bool showResults = false;
    bool showNetworkScanner = false;
    
    // Network/FTP state
    std::vector<std::string> discoveredHosts;
    std::string selectedFtpHost = "";
    std::string ftpUsername = "anonymous";
    std::string ftpPassword = "";
    int ftpPort = 21;
    bool scanningNetwork = false;
    int switchToFtpTab = 0; // 0 = kein Wechsel, 1 = zur FTP-Verbindung wechseln
    
    // Settings
    int threadCount = 4;
    int minFileSize = 1024; // 1 KB
    bool scanHiddenFiles = false;
    bool followSymlinks = false;
    bool useGPU = false;
    bool useFastHash = true; // CRC32 vs MD5
    int bufferSize = 8192; // KB
    bool autoExportResults = false;
    std::string exportPath = "./duplicates.csv";
    
    // Theme
    int currentTheme = 3; // Quake 3 Light Blue als Default
    const char* themes[33] = {
        "Dark", "Light", "Classic", "Quake 3", "Nord Dark", 
        "Dracula", "Monokai", "Solarized Dark", "Solarized Light", "Gruvbox Dark",
        "Material Dark", "Material Light", "One Dark", "Atom Dark", "VS Dark",
        "VS Light", "GitHub Dark", "GitHub Light", "Oceanic Next", "Tomorrow Night",
        "Cyberpunk", "Synthwave", "Vaporwave", "Forest", "Desert",
        "Ocean", "Sunset", "Midnight", "Ice", "Fire",
        "Purple Haze", "Golden", "Matrix"
    };
};

static AppState appState;

// Save/Load Theme Settings
void saveThemeSettings() {
    std::ofstream file(std::string(getenv("HOME")) + "/.fileduper_theme.cfg");
    if (file.is_open()) {
        file << appState.currentTheme << std::endl;
        file.close();
        std::cout << "[Config] Theme saved: " << appState.themes[appState.currentTheme] << std::endl;
    }
}

void loadThemeSettings() {
    std::ifstream file(std::string(getenv("HOME")) + "/.fileduper_theme.cfg");
    if (file.is_open()) {
        int theme;
        file >> theme;
        if (theme >= 0 && theme < 33) {
            appState.currentTheme = theme;
            std::cout << "[Config] Theme loaded: " << appState.themes[appState.currentTheme] << std::endl;
        }
        file.close();
    } else {
        // Default: Quake 3
        appState.currentTheme = 3;
        std::cout << "[Config] Using default theme: " << appState.themes[appState.currentTheme] << std::endl;
    }
}

// Save/Load Server Presets
void saveServerPresets() {
    std::ofstream file(std::string(getenv("HOME")) + "/.fileduper_servers.cfg");
    if (file.is_open()) {
        for (const auto& server : appState.savedServers) {
            // Format: name|ip|type|port|username|password
            file << server.name << "|" << server.ip << "|" << server.type << "|" 
                 << server.port << "|" << server.username << "|" << server.password << std::endl;
        }
        file.close();
        std::cout << "[Servers] Saved " << appState.savedServers.size() << " servers" << std::endl;
    }
}

void loadServerPresets() {
    std::ifstream file(std::string(getenv("HOME")) + "/.fileduper_servers.cfg");
    if (file.is_open()) {
        std::string line;
        appState.savedServers.clear();
        while (std::getline(file, line)) {
            if (!line.empty()) {
                ServerPreset server;
                size_t pos = 0;
                size_t nextPos;
                
                // Parse: name|ip|type|port|username|password
                nextPos = line.find('|', pos);
                if (nextPos != std::string::npos) {
                    server.name = line.substr(pos, nextPos - pos);
                    pos = nextPos + 1;
                    
                    nextPos = line.find('|', pos);
                    if (nextPos != std::string::npos) {
                        server.ip = line.substr(pos, nextPos - pos);
                        pos = nextPos + 1;
                        
                        nextPos = line.find('|', pos);
                        if (nextPos != std::string::npos) {
                            server.type = line.substr(pos, nextPos - pos);
                            pos = nextPos + 1;
                            
                            nextPos = line.find('|', pos);
                            if (nextPos != std::string::npos) {
                                server.port = std::stoi(line.substr(pos, nextPos - pos));
                                pos = nextPos + 1;
                                
                                nextPos = line.find('|', pos);
                                if (nextPos != std::string::npos) {
                                    server.username = line.substr(pos, nextPos - pos);
                                    server.password = line.substr(nextPos + 1);
                                    
                                    appState.savedServers.push_back(server);
                                }
                            }
                        }
                    }
                }
            }
        }
        file.close();
        std::cout << "[Servers] Loaded " << appState.savedServers.size() << " servers" << std::endl;
    }
}

void addServerPreset(const ServerPreset& server) {
    // Prüfe ob bereits vorhanden (gleiche IP)
    for (const auto& s : appState.savedServers) {
        if (s.ip == server.ip && s.type == server.type) {
            std::cout << "[Servers] Server already exists: " << server.name << std::endl;
            return;
        }
    }
    appState.savedServers.push_back(server);
    saveServerPresets();
    std::cout << "[Servers] Added: " << server.name << " (" << server.type << "://" << server.ip << ")" << std::endl;
}

void removeServerPreset(size_t index) {
    if (index < appState.savedServers.size()) {
        std::cout << "[Servers] Removed: " << appState.savedServers[index].name << std::endl;
        appState.savedServers.erase(appState.savedServers.begin() + index);
        saveServerPresets();
    }
}

// Helper: Format file size
std::string formatSize(long long bytes) {
    const char* units[] = {"B", "KB", "MB", "GB", "TB"};
    int unit = 0;
    double size = (double)bytes;
    
    while (size >= 1024.0 && unit < 4) {
        size /= 1024.0;
        unit++;
    }
    
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "%.2f %s", size, units[unit]);
    return std::string(buffer);
}

// Get mounted drives/partitions
struct MountInfo {
    std::string device;
    std::string mountPoint;
    std::string fsType;
    long long totalSpace;
    long long freeSpace;
};

std::vector<MountInfo> getMountedDrives() {
    std::vector<MountInfo> drives;
    
    FILE* mtab = setmntent("/etc/mtab", "r");
    if (!mtab) return drives;
    
    struct mntent* entry;
    while ((entry = getmntent(mtab)) != nullptr) {
        // Filter nur echte Dateisysteme
        std::string fstype = entry->mnt_type;
        if (fstype == "ext4" || fstype == "ext3" || fstype == "ext2" || 
            fstype == "btrfs" || fstype == "xfs" || fstype == "ntfs" || 
            fstype == "vfat" || fstype == "exfat" || fstype == "f2fs") {
            
            MountInfo info;
            info.device = entry->mnt_fsname;
            info.mountPoint = entry->mnt_dir;
            info.fsType = entry->mnt_type;
            
            // Get space info
            struct statvfs vfs;
            if (statvfs(entry->mnt_dir, &vfs) == 0) {
                info.totalSpace = (long long)vfs.f_blocks * vfs.f_frsize;
                info.freeSpace = (long long)vfs.f_bavail * vfs.f_frsize;
            } else {
                info.totalSpace = 0;
                info.freeSpace = 0;
            }
            
            drives.push_back(info);
        }
    }
    
    endmntent(mtab);
    return drives;
}

// Scan directory recursively
std::vector<std::string> scanDirectory(const std::string& path, bool recursive = true, int maxDepth = 10) {
    std::vector<std::string> dirs;
    
    if (maxDepth <= 0) return dirs;
    
    DIR* dir = opendir(path.c_str());
    if (!dir) return dirs;
    
    struct dirent* entry;
    while ((entry = readdir(dir)) != nullptr) {
        std::string name = entry->d_name;
        if (name == "." || name == "..") continue;
        
        std::string fullPath = path + "/" + name;
        struct stat st;
        if (stat(fullPath.c_str(), &st) != 0) continue;
        
        if (S_ISDIR(st.st_mode)) {
            dirs.push_back(fullPath);
            if (recursive) {
                auto subdirs = scanDirectory(fullPath, true, maxDepth - 1);
                dirs.insert(dirs.end(), subdirs.begin(), subdirs.end());
            }
        }
    }
    
    closedir(dir);
    return dirs;
}

// Helper: Get directory tree
struct TreeNode {
    std::string name;
    std::string fullPath;
    bool isDir;
    std::vector<TreeNode*> children;
    bool expanded = false;
    
    ~TreeNode() {
        for (auto* child : children) delete child;
    }
};

TreeNode* buildDirectoryTree(const std::string& rootPath) {
    TreeNode* root = new TreeNode();
    root->name = rootPath;
    root->fullPath = rootPath;
    root->isDir = true;
    
    DIR* dir = opendir(rootPath.c_str());
    if (!dir) return root;
    
    struct dirent* entry;
    while ((entry = readdir(dir)) != nullptr) {
        std::string name = entry->d_name;
        if (name == "." || name == "..") continue;
        
        std::string fullPath = rootPath + "/" + name;
        struct stat st;
        if (stat(fullPath.c_str(), &st) != 0) continue;
        
        TreeNode* node = new TreeNode();
        node->name = name;
        node->fullPath = fullPath;
        node->isDir = S_ISDIR(st.st_mode);
        
        if (node->isDir && name[0] != '.') {  // Skip hidden dirs
            root->children.push_back(node);
        } else {
            delete node;
        }
    }
    closedir(dir);
    
    // Sort by name
    std::sort(root->children.begin(), root->children.end(),
              [](const TreeNode* a, const TreeNode* b) {
                  return a->name < b->name;
              });
    
    return root;
}

void renderTreeNode(TreeNode* node, std::set<std::string>& selectedDirs) {
    ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;
    if (node->children.empty()) {
        flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
    }
    
    bool isSelected = selectedDirs.count(node->fullPath) > 0;
    if (isSelected) {
        flags |= ImGuiTreeNodeFlags_Selected;
    }
    
    std::string label = (node->isDir ? "[DIR] " : "[FILE] ") + node->name;
    bool opened = ImGui::TreeNodeEx(node->fullPath.c_str(), flags, "%s", label.c_str());
    
    if (ImGui::IsItemClicked() && node->isDir) {
        if (isSelected) {
            selectedDirs.erase(node->fullPath);
        } else {
            selectedDirs.insert(node->fullPath);
        }
    }
    
    if (opened && !node->children.empty()) {
        for (auto* child : node->children) {
            renderTreeNode(child, selectedDirs);
        }
        ImGui::TreePop();
    }
}

// Apply theme
void applyTheme(int themeIndex) {
    ImGuiStyle& style = ImGui::GetStyle();
    ImVec4* colors = style.Colors;
    
    switch(themeIndex) {
        case 0: ImGui::StyleColorsDark(); break;
        case 1: ImGui::StyleColorsLight(); break;
        case 2: ImGui::StyleColorsClassic(); break;
        
        case 3: // Quake 3 Light Blue (Default)
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.60f, 0.80f, 0.95f, 0.95f);
            colors[ImGuiCol_TitleBg] = ImVec4(0.40f, 0.65f, 0.85f, 1.0f);
            colors[ImGuiCol_TitleBgActive] = ImVec4(0.50f, 0.75f, 0.95f, 1.0f);
            colors[ImGuiCol_Button] = ImVec4(0.45f, 0.70f, 0.90f, 1.0f);
            colors[ImGuiCol_ButtonHovered] = ImVec4(0.55f, 0.80f, 1.0f, 1.0f);
            colors[ImGuiCol_ButtonActive] = ImVec4(0.35f, 0.60f, 0.80f, 1.0f);
            colors[ImGuiCol_Text] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
            colors[ImGuiCol_Border] = ImVec4(0.30f, 0.50f, 0.70f, 1.0f);
            break;
            
        case 4: // Nord Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.18f, 0.20f, 0.25f, 0.95f);
            colors[ImGuiCol_TitleBg] = ImVec4(0.23f, 0.26f, 0.32f, 1.0f);
            colors[ImGuiCol_Button] = ImVec4(0.35f, 0.47f, 0.65f, 1.0f);
            break;
            
        case 5: // Dracula
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.16f, 0.16f, 0.21f, 0.95f);
            colors[ImGuiCol_TitleBg] = ImVec4(0.19f, 0.19f, 0.25f, 1.0f);
            colors[ImGuiCol_Button] = ImVec4(0.74f, 0.34f, 0.90f, 1.0f);
            break;
            
        case 6: // Monokai
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.16f, 0.15f, 0.14f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.98f, 0.96f, 0.24f, 1.0f);
            colors[ImGuiCol_Text] = ImVec4(0.97f, 0.97f, 0.95f, 1.0f);
            break;
            
        case 7: // Solarized Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.0f, 0.17f, 0.21f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.15f, 0.55f, 0.82f, 1.0f);
            break;
            
        case 8: // Solarized Light
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(0.99f, 0.96f, 0.89f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.15f, 0.55f, 0.82f, 1.0f);
            break;
            
        case 9: // Gruvbox Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.16f, 0.15f, 0.13f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.84f, 0.60f, 0.13f, 1.0f);
            break;
            
        case 10: // Material Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.13f, 0.14f, 0.15f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.0f, 0.47f, 0.84f, 1.0f);
            break;
            
        case 11: // Material Light
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.0f, 0.47f, 0.84f, 1.0f);
            break;
            
        case 12: // One Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.16f, 0.17f, 0.21f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.38f, 0.56f, 0.98f, 1.0f);
            break;
            
        case 13: // Atom Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.14f, 0.15f, 0.17f, 0.95f);
            break;
            
        case 14: // VS Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.12f, 0.12f, 0.12f, 0.95f);
            break;
            
        case 15: // VS Light
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(1.0f, 1.0f, 1.0f, 0.95f);
            break;
            
        case 16: // GitHub Dark
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.08f, 0.10f, 0.12f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.13f, 0.52f, 0.93f, 1.0f);
            break;
            
        case 17: // GitHub Light
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(1.0f, 1.0f, 1.0f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.13f, 0.52f, 0.93f, 1.0f);
            break;
            
        case 18: // Oceanic Next
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.11f, 0.14f, 0.17f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.40f, 0.74f, 0.84f, 1.0f);
            break;
            
        case 19: // Tomorrow Night
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.11f, 0.12f, 0.13f, 0.95f);
            break;
            
        case 20: // Cyberpunk
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.05f, 0.0f, 0.15f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(1.0f, 0.0f, 0.8f, 1.0f);
            colors[ImGuiCol_Text] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
            break;
            
        case 21: // Synthwave
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.10f, 0.0f, 0.20f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.97f, 0.20f, 0.75f, 1.0f);
            break;
            
        case 22: // Vaporwave
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.60f, 0.40f, 0.80f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(1.0f, 0.60f, 0.90f, 1.0f);
            colors[ImGuiCol_Text] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
            break;
            
        case 23: // Forest
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.05f, 0.15f, 0.05f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.13f, 0.55f, 0.13f, 1.0f);
            break;
            
        case 24: // Desert
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(0.96f, 0.87f, 0.70f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.85f, 0.65f, 0.35f, 1.0f);
            break;
            
        case 25: // Ocean
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.0f, 0.20f, 0.35f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.0f, 0.50f, 0.75f, 1.0f);
            break;
            
        case 26: // Sunset
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.20f, 0.10f, 0.15f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(1.0f, 0.40f, 0.20f, 1.0f);
            break;
            
        case 27: // Midnight
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.02f, 0.02f, 0.08f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.10f, 0.10f, 0.40f, 1.0f);
            break;
            
        case 28: // Ice
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(0.85f, 0.95f, 1.0f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.60f, 0.85f, 1.0f, 1.0f);
            break;
            
        case 29: // Fire
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.20f, 0.05f, 0.0f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(1.0f, 0.30f, 0.0f, 1.0f);
            break;
            
        case 30: // Purple Haze
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.15f, 0.05f, 0.25f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.60f, 0.20f, 0.90f, 1.0f);
            break;
            
        case 31: // Golden
            ImGui::StyleColorsLight();
            colors[ImGuiCol_WindowBg] = ImVec4(1.0f, 0.95f, 0.70f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(1.0f, 0.84f, 0.0f, 1.0f);
            break;
            
        case 32: // Matrix
            ImGui::StyleColorsDark();
            colors[ImGuiCol_WindowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.95f);
            colors[ImGuiCol_Button] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
            colors[ImGuiCol_Text] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
            break;
    }
    
    // Save theme after applying
    saveThemeSettings();
}

// Render Local Directory Browser
void renderLocalBrowser() {
    if (!appState.showLocalBrowser) return;
    
    ImGui::SetNextWindowSize(ImVec2(600, 500), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Lokale Verzeichnisse", &appState.showLocalBrowser)) {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Wählen Sie Verzeichnisse zum Scannen:");
        ImGui::Separator();
        
        static char customPath[512] = "";
        ImGui::InputText("Pfad", customPath, sizeof(customPath));
        ImGui::SameLine();
        if (ImGui::Button("Hinzufügen")) {
            if (strlen(customPath) > 0) {
                std::string path = customPath;
                appState.selectedLocalDirs.insert(path);
                memset(customPath, 0, sizeof(customPath));
            }
        }
        
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), 
                          "Ausgewählt: %zu Verzeichnis(se)", appState.selectedLocalDirs.size());
        
        ImGui::BeginChild("SelectedDirs", ImVec2(0, 100), true);
        for (const auto& dir : appState.selectedLocalDirs) {
            ImGui::BulletText("%s", dir.c_str());
            ImGui::SameLine(ImGui::GetWindowWidth() - 80);
            if (ImGui::SmallButton(("Entfernen##" + dir).c_str())) {
                appState.selectedLocalDirs.erase(dir);
                break;
            }
        }
        ImGui::EndChild();
        
        ImGui::Separator();
        
        ImGui::BeginTabBar("BrowserTabs");
        
        // Mounted Drives Tab
        if (ImGui::BeginTabItem("[DIR] Laufwerke")) {
            ImGui::BeginChild("MountedDrives", ImVec2(0, -40), true);
            
            static std::vector<MountInfo> drives;
            static bool drivesLoaded = false;
            
            if (!drivesLoaded) {
                drives = getMountedDrives();
                drivesLoaded = true;
            }
            
            if (ImGui::Button("[SYNC] Aktualisieren")) {
                drives = getMountedDrives();
            }
            
            ImGui::Separator();
            
            for (const auto& drive : drives) {
                std::string label = drive.mountPoint + " (" + drive.fsType + ") - " + 
                                   formatSize(drive.freeSpace) + " / " + 
                                   formatSize(drive.totalSpace) + " frei";
                
                if (ImGui::Selectable(label.c_str())) {
                    appState.selectedLocalDirs.insert(drive.mountPoint);
                }
                
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Device: %s", drive.device.c_str());
                }
            }
            
            ImGui::EndChild();
            ImGui::EndTabItem();
        }
        
        // Common Directories Tab
        if (ImGui::BeginTabItem("[DIR] Verzeichnisse")) {
            static std::vector<std::string> expandedDirs;
            
            ImGui::BeginChild("CommonDirs", ImVec2(0, 0), true);
            
            static std::vector<std::string> commonDirs = {
                "/home", "/tmp", "/opt", "/usr", "/usr/local", 
                "/var", "/srv", "/mnt", "/media", "/root"
            };
            
            for (const auto& dir : commonDirs) {
                // Check if directory exists
                struct stat st;
                bool exists = (stat(dir.c_str(), &st) == 0 && S_ISDIR(st.st_mode));
                
                if (!exists) {
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 0.5f, 0.5f, 1.0f));
                    ImGui::Text("[X] %s (nicht verfügbar)", dir.c_str());
                    ImGui::PopStyleColor();
                    continue;
                }
                
                // Tree node für erweiterbares Verzeichnis
                ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;
                bool isExpanded = ImGui::TreeNodeEx(dir.c_str(), flags, "[DIR] %s", dir.c_str());
                
                // Click zum Hinzufügen
                if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen()) {
                    appState.selectedLocalDirs.insert(dir);
                }
                
                if (isExpanded) {
                    // Zeige Unterverzeichnisse (max 1 Ebene)
                    DIR* d = opendir(dir.c_str());
                    if (d) {
                        struct dirent* entry;
                        std::vector<std::string> subdirs;
                        
                        while ((entry = readdir(d)) != nullptr) {
                            std::string name = entry->d_name;
                            if (name == "." || name == "..") continue;
                            
                            std::string fullPath = dir + "/" + name;
                            struct stat subst;
                            if (stat(fullPath.c_str(), &subst) == 0 && S_ISDIR(subst.st_mode)) {
                                subdirs.push_back(fullPath);
                            }
                        }
                        closedir(d);
                        
                        // Sortiere und zeige maximal 20 Unterverzeichnisse
                        std::sort(subdirs.begin(), subdirs.end());
                        int count = 0;
                        for (const auto& subdir : subdirs) {
                            if (count++ >= 20) {
                                ImGui::Text("... (%zu weitere)", subdirs.size() - 20);
                                break;
                            }
                            
                            if (ImGui::Selectable(("  [DIR] " + subdir).c_str())) {
                                appState.selectedLocalDirs.insert(subdir);
                            }
                        }
                    }
                    ImGui::TreePop();
                }
            }
            
            ImGui::EndChild();
            ImGui::EndTabItem();
        }
        
        ImGui::EndTabBar();
        
        if (ImGui::Button("Fertig", ImVec2(120, 0))) {
            appState.showLocalBrowser = false;
        }
        ImGui::SameLine();
        if (ImGui::Button("Alle löschen", ImVec2(120, 0))) {
            appState.selectedLocalDirs.clear();
        }
    }
    ImGui::End();
}

// Render Network Scanner / FTP Browser
void renderNetworkScanner() {
    if (!appState.showNetworkScanner) {
        // Reset Tab-Wechsel Flag wenn Dialog geschlossen ist
        appState.switchToFtpTab = 0;
        return;
    }
    
    ImGui::SetNextWindowSize(ImVec2(700, 600), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("[NET] Netzwerk & FTP Scanner", &appState.showNetworkScanner)) {
        
        if (ImGui::BeginTabBar("NetworkTabs")) {
        
        // Network Discovery Tab
        if (ImGui::BeginTabItem("[SCAN] Netzwerk-Scan")) {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Netzwerk durchsuchen");
            ImGui::Separator();
            
            static char subnet[64] = "192.168.1.0/24";
            ImGui::InputText("Subnetz", subnet, sizeof(subnet));
            ImGui::SameLine();
            
            if (!appState.scanningNetwork) {
                if (ImGui::Button("[SCAN] Scan starten", ImVec2(150, 0))) {
                    appState.scanningNetwork = true;
                    appState.discoveredHosts.clear();
                    std::cout << "[Network] Scanning " << subnet << std::endl;
                    
                    // Real network scanning with nmap or arp-scan
                    std::string cmd = "timeout 10 nmap -sn " + std::string(subnet) + 
                                     " 2>/dev/null | grep 'Nmap scan report' | awk '{print $5}' > /tmp/fileduper_scan.txt";
                    
                    int result = system(cmd.c_str());
                    
                    // Read scan results
                    std::ifstream scanFile("/tmp/fileduper_scan.txt");
                    if (scanFile.is_open()) {
                        std::string line;
                        while (std::getline(scanFile, line)) {
                            if (!line.empty() && line != "()" && line.find('.') != std::string::npos) {
                                appState.discoveredHosts.push_back(line);
                            }
                        }
                        scanFile.close();
                    }
                    
                    // Fallback: scan local network with arp
                    if (appState.discoveredHosts.empty()) {
                        system("arp -a | grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}' > /tmp/fileduper_arp.txt");
                        std::ifstream arpFile("/tmp/fileduper_arp.txt");
                        if (arpFile.is_open()) {
                            std::string line;
                            while (std::getline(arpFile, line)) {
                                if (!line.empty()) {
                                    appState.discoveredHosts.push_back(line);
                                }
                            }
                            arpFile.close();
                        }
                    }
                    
                    appState.scanningNetwork = false;
                    std::cout << "[Network] Found " << appState.discoveredHosts.size() << " hosts" << std::endl;
                }
            } else {
                ImGui::Button("[WAIT] Scanne...", ImVec2(150, 0));
            }
            
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), 
                              "Gefundene Hosts: %zu", appState.discoveredHosts.size());
            
            ImGui::BeginChild("DiscoveredHosts", ImVec2(0, -40), true);
            for (size_t i = 0; i < appState.discoveredHosts.size(); i++) {
                const auto& host = appState.discoveredHosts[i];
                
                // Selectable mit Doppelklick
                bool selected = appState.selectedFtpHost == host;
                if (ImGui::Selectable(("[PC] " + host).c_str(), 
                                     selected,
                                     ImGuiSelectableFlags_AllowDoubleClick)) {
                    // Einfachklick: nur auswählen
                    appState.selectedFtpHost = (host.find(' ') != std::string::npos) 
                                              ? host.substr(0, host.find(' ')) 
                                              : host;
                }
                
                // Doppelklick: auswählen UND zur FTP-Verbindung wechseln
                if (ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked(0)) {
                    size_t spacePos = host.find(' ');
                    appState.selectedFtpHost = (spacePos != std::string::npos) 
                                              ? host.substr(0, spacePos) 
                                              : host;
                    
                    // Setze Flag für Tab-Wechsel
                    appState.switchToFtpTab = 1;
                    std::cout << "[Network] Double-clicked: " << appState.selectedFtpHost 
                             << " - switching to FTP tab" << std::endl;
                }
                
                // Rechtsklick-Menü
                if (ImGui::BeginPopupContextItem(("ctx_" + std::to_string(i)).c_str())) {
                    if (ImGui::MenuItem("[PLUG] Mit FTP verbinden")) {
                        size_t spacePos = host.find(' ');
                        appState.selectedFtpHost = (spacePos != std::string::npos) 
                                                  ? host.substr(0, spacePos) 
                                                  : host;
                        appState.switchToFtpTab = 1; // Wechsle zum FTP Tab
                        std::cout << "[Network] Connect to: " << appState.selectedFtpHost << std::endl;
                    }
                    if (ImGui::MenuItem("[CLIP] Als Preset speichern")) {
                        std::string ip = (host.find(' ') != std::string::npos) 
                                        ? host.substr(0, host.find(' ')) 
                                        : host;
                        addFtpPreset(ip);
                    }
                    if (ImGui::MenuItem("[CLIP] IP kopieren")) {
                        std::cout << "[Network] Copy: " << host << std::endl;
                    }
                    if (ImGui::MenuItem("[SYNC] Ping")) {
                        std::cout << "[Network] Ping: " << host << std::endl;
                    }
                    ImGui::EndPopup();
                }
            }
            ImGui::EndChild();
            
            ImGui::Text("[TIP] Tipp: Doppelklick auf einen Host zum Verbinden");
            
            ImGui::EndTabItem();
        }
        
        // FTP Connection Tab - Auto-Select wenn Flag gesetzt
        ImGuiTabItemFlags ftpFlags = ImGuiTabItemFlags_None;
        if (appState.switchToFtpTab == 1) {
            ftpFlags = ImGuiTabItemFlags_SetSelected;
            appState.switchToFtpTab = 0; // Sofort zurücksetzen
        }
        
        if (ImGui::BeginTabItem("[FTP] FTP-Verbindung", nullptr, ftpFlags)) {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "FTP Server-Verbindung");
            ImGui::Separator();
            
            // Gespeicherte Presets anzeigen
            if (!appState.savedFtpIPs.empty()) {
                ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[CLIP] Gespeicherte Server:");
                ImGui::BeginChild("SavedFtpServers", ImVec2(0, 120), true);
                
                for (size_t i = 0; i < appState.savedFtpIPs.size(); i++) {
                    const auto& ip = appState.savedFtpIPs[i];
                    
                    bool isSelected = appState.selectedFtpHost == ip;
                    if (ImGui::Selectable(("[NET] " + ip).c_str(), isSelected)) {
                        appState.selectedFtpHost = ip;
                        std::cout << "[FTP] Selected preset: " << ip << std::endl;
                    }
                    
                    // Rechtsklick-Menü
                    if (ImGui::BeginPopupContextItem(("ftp_preset_" + std::to_string(i)).c_str())) {
                        if (ImGui::MenuItem("[X] Löschen")) {
                            removeFtpPreset(ip);
                            break;
                        }
                        if (ImGui::MenuItem("[CLIP] IP kopieren")) {
                            std::cout << "[FTP] Copy: " << ip << std::endl;
                        }
                        ImGui::EndPopup();
                    }
                }
                
                ImGui::EndChild();
                ImGui::Spacing();
            }
            
            // FTP Connection Settings
            static char ftpHost[256] = "";
            if (!appState.selectedFtpHost.empty()) {
                strncpy(ftpHost, appState.selectedFtpHost.c_str(), sizeof(ftpHost) - 1);
            }
            
            ImGui::Text("Server:");
            ImGui::InputText("##Host", ftpHost, sizeof(ftpHost));
            appState.selectedFtpHost = ftpHost;
            
            ImGui::SameLine();
            if (ImGui::Button("[CLIP] Speichern")) {
                if (strlen(ftpHost) > 0) {
                    addFtpPreset(std::string(ftpHost));
                }
            }
            
            ImGui::Text("Port:");
            ImGui::InputInt("##Port", &appState.ftpPort);
            
            ImGui::Text("Benutzername:");
            static char username[128] = "anonymous";
            ImGui::InputText("##Username", username, sizeof(username));
            appState.ftpUsername = username;
            
            ImGui::Text("Passwort:");
            static char password[128] = "";
            ImGui::InputText("##Password", password, sizeof(password), ImGuiInputTextFlags_Password);
            appState.ftpPassword = password;
            
            ImGui::Spacing();
            ImGui::Separator();
            
            static bool connected = false;
            if (!connected) {
                if (ImGui::Button("[PLUG] Verbinden", ImVec2(150, 0))) {
                    if (!appState.selectedFtpHost.empty()) {
                        std::cout << "[FTP] Connecting to " << appState.selectedFtpHost 
                                 << ":" << appState.ftpPort << std::endl;
                        connected = true;
                    }
                }
            } else {
                if (ImGui::Button("[X] Trennen", ImVec2(150, 0))) {
                    connected = false;
                }
                
                ImGui::SameLine();
                ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "[OK] Verbunden");
            }
            
            if (connected) {
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "FTP Verzeichnisse:");
                
                ImGui::BeginChild("FtpDirs", ImVec2(0, 200), true);
                static std::vector<std::string> ftpDirs = {
                    "/pub", "/upload", "/backup", "/shared", "/data"
                };
                
                for (const auto& dir : ftpDirs) {
                    bool isSelected = appState.selectedFtpDirs.count(dir) > 0;
                    if (ImGui::Selectable(("[DIR] " + dir).c_str(), isSelected)) {
                        if (isSelected) {
                            appState.selectedFtpDirs.erase(dir);
                        } else {
                            appState.selectedFtpDirs.insert(dir);
                        }
                    }
                }
                ImGui::EndChild();
                
                ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), 
                                  "Ausgewählt: %zu Verzeichnis(se)", 
                                  appState.selectedFtpDirs.size());
            }
            
            ImGui::EndTabItem();
        }
        
        ImGui::EndTabBar(); // End TabBar
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        if (ImGui::Button("Fertig", ImVec2(120, 0))) {
            appState.showNetworkScanner = false;
        }
    }
    ImGui::End();
}

// Render Main Window
void renderMainWindow() {
    ImGui::SetNextWindowPos(ImVec2(0, 0));
    ImGui::SetNextWindowSize(ImGui::GetIO().DisplaySize);
    
    ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | 
                            ImGuiWindowFlags_NoResize | 
                            ImGuiWindowFlags_NoMove |
                            ImGuiWindowFlags_MenuBar;
    
    if (ImGui::Begin("FileDuper", nullptr, flags)) {
        // Menu Bar
        if (ImGui::BeginMenuBar()) {
            if (ImGui::BeginMenu("Datei")) {
                if (ImGui::MenuItem("Beenden")) {
                    glfwSetWindowShouldClose(glfwGetCurrentContext(), GLFW_TRUE);
                }
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Bearbeiten")) {
                if (ImGui::MenuItem("[CFG] Einstellungen", "Ctrl+,")) {
                    appState.showSettings = true;
                }
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Ansicht")) {
                if (ImGui::BeginMenu("Theme (33 verfügbar)")) {
                    // Gruppe 1: Standard Themes
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Standard");
                    ImGui::Separator();
                    for (int i = 0; i < 4; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Entwickler Themes");
                    ImGui::Separator();
                    for (int i = 4; i < 13; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "IDE Themes");
                    ImGui::Separator();
                    for (int i = 13; i < 20; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Retro/Synthwave");
                    ImGui::Separator();
                    for (int i = 20; i < 23; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Natur Themes");
                    ImGui::Separator();
                    for (int i = 23; i < 30; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Spezial");
                    ImGui::Separator();
                    for (int i = 30; i < 33; i++) {
                        if (ImGui::MenuItem(appState.themes[i], nullptr, appState.currentTheme == i)) {
                            appState.currentTheme = i;
                            applyTheme(i);
                        }
                    }
                    
                    ImGui::EndMenu();
                }
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Hilfe")) {
                if (ImGui::MenuItem("Über")) {
                    appState.showAbout = true;
                }
                ImGui::EndMenu();
            }
            ImGui::EndMenuBar();
        }
        
        // Title
        ImGui::PushFont(ImGui::GetIO().Fonts->Fonts[0]);
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.5f, 1.0f), "FileDuper - Duplicate File Scanner");
        ImGui::PopFont();
        ImGui::Separator();
        
        // Layout: 2 columns
        ImGui::Columns(2, "main_columns", true);
        
        // Left Column: Directory Selection
        ImGui::BeginChild("LeftPanel", ImVec2(0, 0), true);
        {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[DIR] Scan-Quellen");
            ImGui::Separator();
            
            if (ImGui::Button("[DIR] Lokale Verzeichnisse...", ImVec2(-1, 40))) {
                appState.showLocalBrowser = true;
            }
            
            if (ImGui::Button("[NET] Netzwerk & FTP...", ImVec2(-1, 40))) {
                appState.showNetworkScanner = true;
            }
            
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), 
                              "Lokal: %zu | FTP: %zu", 
                              appState.selectedLocalDirs.size(),
                              appState.selectedFtpDirs.size());
            
            ImGui::BeginChild("SelectedList", ImVec2(0, 200), true);
            int idx = 0;
            for (const auto& dir : appState.selectedLocalDirs) {
                ImGui::BulletText("%s", dir.c_str());
                idx++;
            }
            ImGui::EndChild();
            
            ImGui::Separator();
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[CFG] Optionen");
            ImGui::Separator();
            
            static bool includeHidden = false;
            static bool followSymlinks = false;
            static int minFileSize = 1;
            
            ImGui::Checkbox("Versteckte Dateien einbeziehen", &includeHidden);
            ImGui::Checkbox("Symbolischen Links folgen", &followSymlinks);
            ImGui::SliderInt("Min. Dateigröße (KB)", &minFileSize, 1, 1000);
            
            ImGui::Spacing();
            ImGui::Separator();
            
            // Scan Button
            if (!appState.scanning) {
                if (ImGui::Button("[GO] SCAN STARTEN", ImVec2(-1, 60))) {
                    if (!appState.selectedLocalDirs.empty()) {
                        appState.scanning = true;
                        appState.scanProgress = 0.0f;
                        appState.filesScanned = 0;
                        appState.bytesProcessed = 0;
                        appState.scanStatus = "Scanne Dateien...";
                        appState.scanStartTime = time(nullptr);
                        appState.hashSpeed = 0.0f;
                        appState.filesPerSecond = 0.0f;
                        appState.threadsActive = appState.threadCount;
                        std::cout << "[FileDuper] Scan gestartet" << std::endl;
                        
                        // Simulate scan progress (in real app, this would be in a thread)
                        appState.totalFiles = 1000;
                        appState.totalBytes = 1024LL * 1024LL * 1024LL * 2; // 2 GB
                    }
                }
            } else {
                if (ImGui::Button("[STOP] STOP", ImVec2(-1, 60))) {
                    appState.scanning = false;
                    appState.scanStatus = "[STOP] Abgebrochen";
                    appState.threadsActive = 0;
                }
            }
            
            if (appState.scanning) {
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[WAIT] Scanne...");
                
                // Main progress bar
                char progressLabel[64];
                snprintf(progressLabel, sizeof(progressLabel), "%.1f%%", appState.scanProgress * 100.0f);
                ImGui::ProgressBar(appState.scanProgress, ImVec2(-1, 0), progressLabel);
                
                // Status indicators
                ImGui::Spacing();
                ImGui::BeginChild("StatusIndicators", ImVec2(0, 120), true);
                {
                    ImGui::Columns(2, nullptr, false);
                    
                    // Left column
                    ImGui::Text("[DIR] Dateien:");
                    ImGui::Text("  %d / %d", appState.filesScanned, appState.totalFiles);
                    ImGui::Spacing();
                    
                    ImGui::Text("[DATA] Daten:");
                    ImGui::Text("  %s / %s", 
                               formatSize(appState.bytesProcessed).c_str(),
                               formatSize(appState.totalBytes).c_str());
                    
                    ImGui::NextColumn();
                    
                    // Right column
                    ImGui::Text("[PERF] Speed:");
                    ImGui::Text("  %.2f MB/s", appState.hashSpeed);
                    ImGui::Text("  %.1f Dateien/s", appState.filesPerSecond);
                    ImGui::Spacing();
                    
                    ImGui::Text("[SYNC] Threads:");
                    ImGui::Text("  %d aktiv", appState.threadsActive);
                    
                    ImGui::Columns(1);
                }
                ImGui::EndChild();
                
                ImGui::Text("%s", appState.scanStatus.c_str());
                
                // Simulate progress and metrics
                appState.scanProgress += 0.001f;
                appState.filesScanned += 10;
                appState.bytesProcessed += 1024 * 1024 * 5; // 5 MB
                appState.hashSpeed = 120.5f + (rand() % 50) - 25; // Simulate varying speed
                appState.filesPerSecond = 15.2f + (rand() % 10) - 5;
                appState.threadsActive = appState.threadCount;
                
                if (appState.scanProgress >= 1.0f) {
                    appState.scanning = false;
                    appState.scanProgress = 1.0f;
                    appState.scanStatus = "[OK] Abgeschlossen";
                    appState.duplicateGroups = 5;
                    appState.duplicateFiles = 15;
                    appState.duplicateSize = 123456789;
                    appState.showResults = true;
                }
            }
        }
        ImGui::EndChild();
        
        ImGui::NextColumn();
        
        // Right Column: Results & Statistics
        ImGui::BeginChild("RightPanel", ImVec2(0, 0), true);
        {
            ImGui::BeginTabBar("RightPanelTabs");
            
            // Results Tab
            if (ImGui::BeginTabItem("[STAT] Ergebnisse")) {
                if (appState.showResults) {
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "[OK] Scan abgeschlossen!");
                    ImGui::Spacing();
                    
                    ImGui::Text("Duplikat-Gruppen: %d", appState.duplicateGroups);
                    ImGui::Text("Duplikat-Dateien: %d", appState.duplicateFiles);
                    ImGui::Text("Platzverschwendung: %s", formatSize(appState.duplicateSize).c_str());
                
                ImGui::Separator();
                ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Duplikat-Gruppen:");
                
                ImGui::BeginChild("ResultsList", ImVec2(0, -40), true);
                for (int i = 0; i < appState.duplicateGroups; i++) {
                    std::string label = "Gruppe " + std::to_string(i + 1) + " (3 Dateien, 5.2 MB)";
                    if (ImGui::TreeNode(label.c_str())) {
                        ImGui::BulletText("/home/user/file1.jpg");
                        ImGui::BulletText("/home/user/backup/file1.jpg");
                        ImGui::BulletText("/mnt/disk/file1.jpg");
                        
                        if (ImGui::Button(("Öffnen##" + std::to_string(i)).c_str())) {
                            std::cout << "[FileDuper] Öffne Datei" << std::endl;
                        }
                        ImGui::SameLine();
                        if (ImGui::Button(("Löschen##" + std::to_string(i)).c_str())) {
                            std::cout << "[FileDuper] Lösche Duplikate" << std::endl;
                        }
                        
                        ImGui::TreePop();
                    }
                }
                ImGui::EndChild();
                    
                    if (ImGui::Button("Ergebnisse exportieren", ImVec2(-1, 0))) {
                        std::cout << "[FileDuper] Exportiere Ergebnisse" << std::endl;
                    }
                } else {
                    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), 
                                      "Noch keine Ergebnisse.\nStarten Sie einen Scan.");
                }
                ImGui::EndTabItem();
            }
            
            // Statistics Tab
            if (ImGui::BeginTabItem("[CHART] Statistiken")) {
                ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Live-Statistiken");
                ImGui::Separator();
                
                // Performance Section
                ImGui::BeginChild("StatsPerf", ImVec2(0, 150), true);
                {
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[PERF] Performance");
                    ImGui::Separator();
                    
                    ImGui::Columns(2, nullptr, false);
                    ImGui::Text("Hash-Speed:");
                    ImGui::NextColumn();
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "%.2f MB/s", appState.hashSpeed);
                    ImGui::NextColumn();
                    
                    ImGui::Text("Dateien/Sek:");
                    ImGui::NextColumn();
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "%.1f", appState.filesPerSecond);
                    ImGui::NextColumn();
                    
                    ImGui::Text("Threads:");
                    ImGui::NextColumn();
                    ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "%d/%d aktiv", 
                                      appState.threadsActive, appState.threadCount);
                    ImGui::Columns(1);
                }
                ImGui::EndChild();
                
                // Progress Section
                ImGui::BeginChild("StatsProgress", ImVec2(0, 150), true);
                {
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[DIR] Fortschritt");
                    ImGui::Separator();
                    
                    ImGui::Text("Dateien:");
                    ImGui::ProgressBar((float)appState.filesScanned / (float)std::max(1, appState.totalFiles), 
                                      ImVec2(-1, 0));
                    ImGui::Text("  %d / %d", appState.filesScanned, appState.totalFiles);
                    
                    ImGui::Spacing();
                    ImGui::Text("Daten:");
                    ImGui::ProgressBar((float)appState.bytesProcessed / (float)std::max(1LL, appState.totalBytes), 
                                      ImVec2(-1, 0));
                    ImGui::Text("  %s / %s", 
                               formatSize(appState.bytesProcessed).c_str(),
                               formatSize(appState.totalBytes).c_str());
                }
                ImGui::EndChild();
                
                // Time Section
                ImGui::BeginChild("StatsTime", ImVec2(0, 0), true);
                {
                    ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[TIME] Zeit");
                    ImGui::Separator();
                    
                    if (appState.scanStartTime > 0) {
                        time_t elapsed = time(nullptr) - appState.scanStartTime;
                        ImGui::Text("Vergangen: %02ld:%02ld:%02ld", 
                                   elapsed / 3600, (elapsed % 3600) / 60, elapsed % 60);
                        
                        if (appState.scanning && appState.scanProgress > 0.01f) {
                            // Estimate remaining time
                            time_t estimated = (time_t)(elapsed / appState.scanProgress) - elapsed;
                            ImGui::Text("Verbleibend: ~%02ld:%02ld:%02ld", 
                                       estimated / 3600, (estimated % 3600) / 60, estimated % 60);
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "Kein aktiver Scan");
                    }
                    
                    ImGui::Spacing();
                    ImGui::Separator();
                    ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "[SCAN] Duplikate");
                    ImGui::Text("Gruppen: %d", appState.duplicateGroups);
                    ImGui::Text("Dateien: %d", appState.duplicateFiles);
                    ImGui::Text("Größe: %s", formatSize(appState.duplicateSize).c_str());
                }
                ImGui::EndChild();
                
                ImGui::EndTabItem();
            }
            
            ImGui::EndTabBar();
        }
        ImGui::EndChild();
        
        ImGui::Columns(1);
        
        // Status Bar
        ImGui::Separator();
        ImGui::Text("Status: %s", appState.scanStatus.c_str());
        ImGui::SameLine(ImGui::GetWindowWidth() - 400);
        
        // Theme Selector in Status Bar
        ImGui::Text("Theme:");
        ImGui::SameLine();
        ImGui::SetNextItemWidth(200);
        if (ImGui::BeginCombo("##ThemeCombo", appState.themes[appState.currentTheme])) {
            for (int i = 0; i < 33; i++) {
                bool isSelected = (appState.currentTheme == i);
                if (ImGui::Selectable(appState.themes[i], isSelected)) {
                    appState.currentTheme = i;
                    applyTheme(i);
                }
                if (isSelected) {
                    ImGui::SetItemDefaultFocus();
                }
            }
            ImGui::EndCombo();
        }
        
        // Theme Preview Button
        ImGui::SameLine();
        if (ImGui::SmallButton("[<]")) {
            appState.currentTheme = (appState.currentTheme - 1 + 33) % 33;
            applyTheme(appState.currentTheme);
        }
        ImGui::SameLine();
        if (ImGui::SmallButton("[>]")) {
            appState.currentTheme = (appState.currentTheme + 1) % 33;
            applyTheme(appState.currentTheme);
        }
    }
    ImGui::End();
}

// Render Settings Dialog
void renderSettings() {
    if (!appState.showSettings) return;
    
    ImGui::SetNextWindowSize(ImVec2(600, 500), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("[CFG] Einstellungen", &appState.showSettings)) {
        ImGui::BeginTabBar("SettingsTabs");
        
        // Performance Tab
        if (ImGui::BeginTabItem("[PERF] Performance")) {
            ImGui::Text("Thread-Einstellungen");
            ImGui::SliderInt("Thread-Anzahl", &appState.threadCount, 1, 16);
            ImGui::SameLine();
            if (ImGui::Button("Auto")) {
                appState.threadCount = 4; // std::thread::hardware_concurrency()
            }
            
            ImGui::Spacing();
            ImGui::Text("Buffer-Einstellungen");
            ImGui::SliderInt("Buffer-Größe (KB)", &appState.bufferSize, 1024, 65536);
            
            ImGui::Spacing();
            ImGui::Checkbox("GPU-Beschleunigung (OpenCL)", &appState.useGPU);
            ImGui::Checkbox("Schneller Hash (CRC32)", &appState.useFastHash);
            ImGui::TextDisabled("(MD5 ist langsamer aber genauer)");
            
            ImGui::EndTabItem();
        }
        
        // Scan Options Tab
        if (ImGui::BeginTabItem("[SCAN] Scan-Optionen")) {
            ImGui::Text("Datei-Filter");
            ImGui::SliderInt("Min. Dateigröße (Bytes)", &appState.minFileSize, 0, 10240);
            
            ImGui::Spacing();
            ImGui::Checkbox("Versteckte Dateien scannen", &appState.scanHiddenFiles);
            ImGui::Checkbox("Symlinks folgen", &appState.followSymlinks);
            
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "⚠️ Erweiterte Optionen");
            ImGui::Spacing();
            
            ImGui::Checkbox("Ergebnisse automatisch exportieren", &appState.autoExportResults);
            if (appState.autoExportResults) {
                ImGui::InputText("Export-Pfad", &appState.exportPath[0], 256);
            }
            
            ImGui::EndTabItem();
        }
        
        // Theme Tab
        if (ImGui::BeginTabItem("[CFG] Erscheinungsbild")) {
            ImGui::Text("Theme auswählen (33 Themes verfügbar):");
            ImGui::Separator();
            
            // Theme Grid mit 3 Spalten
            ImGui::BeginChild("ThemeSelector", ImVec2(0, 300), true);
            ImGui::Columns(3, nullptr, false);
            
            for (int i = 0; i < 33; i++) {
                if (ImGui::RadioButton(appState.themes[i], appState.currentTheme == i)) {
                    appState.currentTheme = i;
                    applyTheme(i);
                }
                ImGui::NextColumn();
                
                // Nach jedem 3. Element eine neue Zeile
                if ((i + 1) % 3 == 0) {
                    ImGui::Separator();
                }
            }
            
            ImGui::Columns(1);
            ImGui::EndChild();
            
            ImGui::Spacing();
            ImGui::Text("Schnellwahl:");
            if (ImGui::Button("< Vorheriges")) {
                appState.currentTheme = (appState.currentTheme - 1 + 33) % 33;
                applyTheme(appState.currentTheme);
            }
            ImGui::SameLine();
            if (ImGui::Button("Nächstes >")) {
                appState.currentTheme = (appState.currentTheme + 1) % 33;
                applyTheme(appState.currentTheme);
            }
            ImGui::SameLine();
            if (ImGui::Button("Quake 3 (Standard)")) {
                appState.currentTheme = 3;
                applyTheme(3);
            }
            
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Text("Live-Vorschau:");
            ImGui::BeginChild("ThemePreview", ImVec2(0, 120), true);
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Aktuelles Theme: %s", appState.themes[appState.currentTheme]);
            ImGui::Spacing();
            ImGui::Text("Dies ist normaler Text");
            ImGui::Button("Beispiel-Button");
            ImGui::SameLine();
            ImGui::Button("Hover über mich");
            ImGui::ProgressBar(0.6f, ImVec2(-1, 0), "60%%");
            ImGui::Checkbox("Checkbox", &appState.scanHiddenFiles);
            ImGui::EndChild();
            
            ImGui::EndTabItem();
        }
        
        ImGui::EndTabBar();
        
        ImGui::Spacing();
        ImGui::Separator();
        if (ImGui::Button("Speichern", ImVec2(120, 0))) {
            appState.showSettings = false;
            // TODO: Save settings to file
        }
        ImGui::SameLine();
        if (ImGui::Button("Abbrechen", ImVec2(120, 0))) {
            appState.showSettings = false;
        }
    }
    ImGui::End();
}

// Render About Dialog
void renderAbout() {
    if (!appState.showAbout) return;
    
    ImGui::SetNextWindowSize(ImVec2(400, 250), ImGuiCond_Always);
    if (ImGui::Begin("Über FileDuper", &appState.showAbout, ImGuiWindowFlags_NoResize)) {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.5f, 1.0f), "FileDuper");
        ImGui::Text("Version 2.0 - ImGui Edition");
        ImGui::Separator();
        ImGui::Text("Duplicate File Scanner");
        ImGui::Text("Findet und verwaltet doppelte Dateien");
        ImGui::Spacing();
        ImGui::Text("Features:");
        ImGui::BulletText("Schnelles Scanning");
        ImGui::BulletText("MD5/SHA Hash-Vergleich");
        ImGui::BulletText("Lokale & Netzwerk-Scans");
        ImGui::BulletText("Mehrere Themes");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Text("© 2025");
        
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            appState.showAbout = false;
        }
    }
    ImGui::End();
}

int main(int argc, char* argv[]) {
    // Init GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return -1;
    }

    // GL 3.3 + GLSL 130
    const char* glsl_version = "#version 130";
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Create window (maximized)
    GLFWwindow* window = glfwCreateWindow(1920, 1080, "FileDuper", NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1); // Enable vsync

    // Setup ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init(glsl_version);

    // Load saved theme and server presets
    loadThemeSettings();
    loadServerPresets();
    applyTheme(appState.currentTheme);

    std::cout << "[FileDuper] [OK] Initialized" << std::endl;

    // Main loop
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

        // Start ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        // Render UI
        renderMainWindow();
        renderLocalBrowser();
        renderNetworkScanner();
        renderSettings();
        renderAbout();

        // Rendering
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        glfwSwapBuffers(window);
    }

    // Cleanup
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
}
