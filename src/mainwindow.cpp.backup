#include "mainwindow.h"
#include "presetmanager.h"
#include <algorithm>
#include "activityindicator.h"
#include "ftpclient.h"
#include "sftpclient.h"         // ‚úÖ SFTP Client Include
#include "smbclient.h"          // ‚úÖ SMB Client Include
#include "nfsclient.h"          // ‚úÖ NFS Client Include
#include "networkdirectorydialog.h"
#include "simpletreedialog.h"
#include "logindialog.h"
#include "hashengine.h"
#include "duplicatedeletedialog.h"
#include "networkrangewidget.h"  // üåê Network Range Management Widget

#include <QApplication>
#include <QThread>
#include <QMenuBar>
#include <QToolBar>
#include <QStatusBar>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QSplitter>
#include <QGroupBox>
#include <QLabel>
#include <QPushButton>
#include <QTreeWidget>
#include <QTableWidget>
#include <QProgressBar>
#include <QComboBox>
#include <QFileDialog>
#include <QMessageBox>
#include <atomic>
#include <memory>
#include <QTimer>
#include <QTime>
#include <QShortcut>
#include <QThread>
#include <QDebug>
#include <QSettings>
#include <QStandardPaths>
#include <QMenu>
#include <QRegularExpression>
#include <QContextMenuEvent>
#include <QHeaderView>
#include <QPalette>
#include <QCloseEvent>
#include <QThreadPool>
#include <QAction>
#include <QClipboard>
#include <QHeaderView>
#include <iostream>
#include <QThread>

// PImpl structure for MainWindow
struct MainWindow::Impl
{
    Scanner *scanner = nullptr;
    NetworkScanner *networkScanner = nullptr;
    PresetManager *presetManager = nullptr;
    ActivityIndicator *activityIndicator = nullptr;

    QStringList scanDirectories;
    bool isScanning = false;
};

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
      m_scanner(new Scanner(this)),
      m_networkScanner(new NetworkScanner(this)),
      m_presetManager(new PresetManager(this)),
      m_activityIndicator(new ActivityIndicator(this)),
      m_hashEngine(new HashEngine(this)),
      m_ftpClient(new FtpClient(this)),
      m_sftpClient(new SftpClient(this)),    // ‚úÖ SFTP Client
      m_smbClient(new SmbClient(this)),      // ‚úÖ SMB Client
      m_nfsClient(new NfsClient(this)),      // ‚úÖ NFS Client
      m_networkRangeWidget(new NetworkRangeWidget(this)), // üåê Network Range Widget
      d(std::make_unique<Impl>()),
      m_isScanning(false),
      m_networkScanActive(false),      // Initialize network scan state
      m_multiRangeScanActive(false),   // Initialize multi-range scan state
      m_hashCalculationStarted(false), // Initialize hash calculation state
      m_filesCollectedHandled(false)   // Initialize filesCollected handling state
{
    setupProgrammaticGUI(); // Call the programmatic UI setup
    setupConnections();     // ‚úÖ FR√úHER: Verbinde Signals VOR initializeComponents()
    initializeComponents();
    loadSettings();

    // Initial network scan after delay
    // ‚úÖ PRODUCTION: Nur automatisches Netzwerk-Discovery
    QTimer::singleShot(1000, this, &MainWindow::startNetworkDiscovery);
    
    // Multi-Range-Scan ist jetzt in startNetworkDiscovery() integriert

    // ‚úÖ PRODUCTION: Kein automatischer Demo-Scan - nur Benutzerauswahl
    std::cout << "[MainWindow] ‚úÖ Produktions-Scanner bereit - warte auf Benutzerauswahl" << std::endl;

    // üß™ DEBUG: Auto-Test-Scan f√ºr GUI-Update-Verifizierung
    // TEMP: Automatischer Test-Scan um zu pr√ºfen ob GUI-Updates funktionieren
    if (qgetenv("FILEDUPER_GUI_TEST") == "1") {
        qDebug() << "[MainWindow] üß™üß™üß™ GUI-TEST-MODUS AKTIVIERT!";
        std::cout << "[MainWindow] üß™ Starte automatischen Test-Scan f√ºr GUI-Updates" << std::endl;
        
        // F√ºge Test-Verzeichnis hinzu (FTP oder lokal)
        QString testDir = "ftp://192.168.50.224/share/Jan/heiner/Musik/";
        m_selectedDirectories.append(testDir);
        updateDirectorySummary();
        
        qDebug() << "[MainWindow] üß™ Test-Verzeichnis hinzugef√ºgt:" << testDir;
        std::cout << "[MainWindow] üß™ Starte Scan in 3 Sekunden..." << std::endl;
        
        // Starte Scan nach 3 Sekunden
        QTimer::singleShot(3000, this, [this]() {
            qDebug() << "[MainWindow] üß™ AUTO-SCAN STARTET JETZT!";
            std::cout << "[MainWindow] üöÄüöÄüöÄ AUTO-TEST-SCAN GESTARTET!" << std::endl;
            startDuplicateScan();
        });
    }

    // üîß Production-Hook: Auto-Scan √ºber Umgebungsvariable f√ºr Batch-Verarbeitung
    // Setzen Sie FILEDUPER_AUTOSCAN_DIRS="/pfad/zu/local;ftp://host/pfad/" um
    // direkt nach dem Start einen Scan mit diesen Verzeichnissen zu triggern.
    const QByteArray autoScanEnv = qgetenv("FILEDUPER_AUTOSCAN_DIRS");
    if (!autoScanEnv.isEmpty()) {
        QString raw = QString::fromUtf8(autoScanEnv);
        // Unterst√ºtze Trennzeichen ';', ',' oder Zeilenumbruch
        QStringList dirs = raw.split(QRegularExpression("[\n;,]"), Qt::SkipEmptyParts);
        int added = 0;
        for (QString d : dirs) {
            d = d.trimmed();
            if (d.isEmpty()) continue;
            if (!m_selectedDirectories.contains(d)) {
                m_selectedDirectories.append(d);
                ++added;
            }
        }
        qDebug() << "[MainWindow] üß™ AutoScan aktiviert via Env - Verzeichnisse hinzugef√ºgt:" << added
                 << "‚Üí" << m_selectedDirectories;
        updateDirectorySummary();
        // Starte den Scan leicht verz√∂gert, damit UI/Komponenten bereit sind
        QTimer::singleShot(1500, this, &MainWindow::startDuplicateScan);
    }
}

MainWindow::~MainWindow()
{
    // ‚úÖ CRASH PREVENTION: Umfassender sicherer Destructor
    qDebug() << "[MainWindow] üßπ Destructor gestartet - Sichere Bereinigung...";
    
    try {
        // ‚úÖ 1. Scanner sicher stoppen
        if (m_scanner) {
            qDebug() << "[MainWindow] üõë Stoppe Scanner...";
            m_scanner->stopScan();
            m_scanner = nullptr;
        }
        
        // ‚úÖ 2. NetworkScanner sicher stoppen  
        if (m_networkScanner) {
            qDebug() << "[MainWindow] üì° Stoppe NetworkScanner...";
            // NetworkScanner hat automatische Bereinigung
            m_networkScanner = nullptr;
        }
        
        // ‚úÖ 3. Timers sicher stoppen
        if (m_activityIndicator) {
            qDebug() << "[MainWindow] ‚è∞ Stoppe ActivityIndicator...";
            // ActivityIndicator stoppt seine eigenen Timer
            m_activityIndicator = nullptr;
        }
        
        // ‚úÖ 4. Settings sicher speichern
        qDebug() << "[MainWindow] üíæ Speichere Settings...";
        saveSettings();
        
        // ‚úÖ 5. Weitere Komponenten auf nullptr setzen
        m_presetManager = nullptr;
        m_hashEngine = nullptr;
        
        // ‚úÖ 6. GUI-Komponenten sind durch Qt Parent-System automatisch bereinigt
        
        qDebug() << "[MainWindow] ‚úÖ Destructor erfolgreich abgeschlossen";
        
    } catch (const std::exception& e) {
        qDebug() << "[MainWindow] ‚ùå Exception in Destruktor:" << e.what();
    } catch (...) {
        qDebug() << "[MainWindow] ‚ùå Unknown exception in Destruktor";
    }
}

void MainWindow::initializeComponents()
{
    d->scanner = m_scanner;
    d->networkScanner = m_networkScanner;
    d->presetManager = m_presetManager;
    d->activityIndicator = m_activityIndicator;

    // Configure HashEngine for Scanner
    m_scanner->setHashEngine(m_hashEngine);
    
    // üîÑ Verbinde HashEngine Status-Updates mit GUI
    connect(m_hashEngine, &HashEngine::statusUpdate, this, &MainWindow::onHashEngineStatusUpdate);
    
    // ‚úÖ KRITISCH: Configure PresetManager for Scanner (f√ºr FTP-Credentials)
    m_scanner->setPresetManager(m_presetManager);
    
    // ‚úÖ Configure FtpClient for Scanner
    m_scanner->setFtpClient(m_ftpClient);
    
    // üåê Initialize Network Range Widget connections
    if (m_networkRangeWidget) {
        // Connect the NetworkScanner to the NetworkRangeWidget
        m_networkRangeWidget->setNetworkScanner(m_networkScanner);
        
        connect(m_networkRangeWidget, &NetworkRangeWidget::customRangeAdded, 
                this, &MainWindow::onCustomNetworkRangeAdded);
        connect(m_networkRangeWidget, &NetworkRangeWidget::rangeSelected, 
                this, &MainWindow::onNetworkRangeSelected);
        connect(m_networkRangeWidget, &NetworkRangeWidget::rangesLoaded, 
                this, &MainWindow::onNetworkRangesLoaded);
        
        // Initial setup with auto-detected ranges
        updateNetworkRangeDisplay();
    }

    // üß† NPU enablement is configurable: env FILEDUPER_NPU or settings key npu/enabled (default: true)
    bool npuEnabled = true; // default
    const QByteArray npuEnv = qgetenv("FILEDUPER_NPU");
    if (!npuEnv.isEmpty()) {
        const QString v = QString::fromUtf8(npuEnv).trimmed().toLower();
        npuEnabled = (v == "1" || v == "true" || v == "yes" || v == "on");
    } else {
        QSettings s; // use application/org defaults
        npuEnabled = s.value("npu/enabled", true).toBool();
    }
    m_scanner->setNpuEnabled(npuEnabled);
    qDebug() << "[MainWindow] üß† NPU initial state =" << npuEnabled << "(env FILEDUPER_NPU overrides)";

    QThreadPool::globalInstance()->setMaxThreadCount(QThread::idealThreadCount());

    setWindowTitle("FileDuper - Advanced Duplicate Scanner");
    setMinimumSize(1200, 800);
}

void MainWindow::setupProgrammaticGUI()
{
    setWindowTitle(tr("FileDuper - Advanced Network Duplicate Scanner"));
    resize(1400, 900);

    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    QHBoxLayout *mainLayout = new QHBoxLayout(centralWidget);
    QSplitter *splitter = new QSplitter(Qt::Horizontal, this);
    mainLayout->addWidget(splitter);

    // Left Panel: Directory & Network Services
    QWidget *leftPanel = new QWidget();
    QVBoxLayout *leftLayout = new QVBoxLayout(leftPanel);
    
    // Local Directory Group with Multi-Selection
    QGroupBox *dirGroupBox = new QGroupBox(tr("üìÅ Lokale Verzeichnisse"));
    QVBoxLayout *dirLayout = new QVBoxLayout(dirGroupBox);
    
    // Directory selection buttons
    QHBoxLayout *dirButtonLayout = new QHBoxLayout();
    selectDirBtn = new QPushButton(tr("üìÇ Verzeichnisse ausw√§hlen"));
    scanSelectedBtn = new QPushButton(tr("üîç Ausgew√§hlte scannen"));
    scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
    dirButtonLayout->addWidget(selectDirBtn);
    dirButtonLayout->addWidget(scanSelectedBtn);
    dirLayout->addLayout(dirButtonLayout);
    
    // ‚úÖ Ersetzt direkten Tree durch Summary-Label mit DUNKLEREM Hintergrund
    QLabel *directorySummaryLabel = new QLabel(tr("üìÅ Keine Verzeichnisse ausgew√§hlt"), this);
    directorySummaryLabel->setObjectName("directorySummaryLabel");
    directorySummaryLabel->setStyleSheet(
        "QLabel { "
        "   background-color: #2d3748; "  // Dunkelgrau statt hell
        "   color: #e2e8f0; "             // Helle Schrift
        "   border: 1px solid #4a5568; "  // Dunklerer Rand
        "   border-radius: 8px; "
        "   padding: 12px; "
        "   font-size: 13px; "
        "   font-family: 'Segoe UI', Arial, sans-serif; "
        "   min-height: 120px; "
        "}"
    );
    directorySummaryLabel->setWordWrap(true);
    directorySummaryLabel->setAlignment(Qt::AlignTop | Qt::AlignLeft);
    
    // ‚úÖ Context Menu f√ºr Pfad-Entfernung aktivieren
    directorySummaryLabel->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(directorySummaryLabel, &QLabel::customContextMenuRequested, 
            this, &MainWindow::showDirectorySummaryContextMenu);
    
    dirLayout->addWidget(directorySummaryLabel);
    
    leftLayout->addWidget(dirGroupBox);

    // Network Services Group with Auto-Login
    QGroupBox *networkGroupBox = new QGroupBox(tr("üåê Netzwerk-Services (Doppelklick f√ºr Auto-Login)"));
    QVBoxLayout *networkLayout = new QVBoxLayout(networkGroupBox);
    
    // Network scan status
    QHBoxLayout *networkStatusLayout = new QHBoxLayout();
    QLabel *networkStatusLabel = new QLabel(tr("üì° Netzwerk-Scan:"));
    networkProgressLabel = new QLabel(tr("Bereit"));
    networkStatusLayout->addWidget(networkStatusLabel);
    networkStatusLayout->addWidget(networkProgressLabel);
    networkStatusLayout->addStretch();
    networkLayout->addLayout(networkStatusLayout);
    
    networkTree = new QTreeWidget();
    networkTree->setColumnCount(5);
    networkTree->setHeaderLabels({tr("üì° Intelligente Server-Hierarchie"), tr("üîß Service"), tr("üîê Auth"), tr("üìä Status"), tr("üéØ Relevanz")});
    networkTree->header()->resizeSection(0, 280);
    networkTree->header()->resizeSection(1, 100);
    networkTree->header()->resizeSection(2, 70);
    networkTree->header()->resizeSection(3, 80);
    networkTree->header()->resizeSection(4, 90);
    networkTree->setSelectionMode(QAbstractItemView::ExtendedSelection);
    networkTree->setContextMenuPolicy(Qt::CustomContextMenu);
    networkTree->setRootIsDecorated(true);
    networkTree->setAnimated(true);
    networkTree->setIndentation(25);
    networkTree->setSortingEnabled(true);
    networkTree->setAlternatingRowColors(true);
    
    // ‚úÖ VERBESSERTE Sichtbarkeit mit dunklerem Design
    networkTree->setStyleSheet(R"(
        QTreeWidget {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #1e293b, stop:1 #0f172a);
            color: #e2e8f0;
            border: 2px solid #475569;
            border-radius: 12px;
            font-family: 'Segoe UI', 'SF Pro Display', Arial, sans-serif;
            font-size: 13px;
            alternate-background-color: rgba(71, 85, 105, 0.3);
        }
        QTreeWidget::item {
            padding: 8px 6px;
            border-bottom: 1px solid #334155;
            min-height: 28px;
        }
        QTreeWidget::item:hover {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #3b82f6, stop:1 #2563eb);
            color: white;
            border-radius: 6px;
            font-weight: 500;
        }
        QTreeWidget::item:selected {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #7c3aed, stop:1 #5b21b6);
            color: white;
            border-radius: 6px;
            font-weight: bold;
        }
        QTreeWidget::item:selected:hover {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #8b5cf6, stop:1 #7c3aed);
        }
        QTreeWidget::branch:has-children:!has-siblings:closed,
        QTreeWidget::branch:closed:has-children:has-siblings {
            image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM0w5IDZMMyA5IiBzdHJva2U9IiNmMWY1ZjkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=);
            width: 12px;
            height: 12px;
        }
        QTreeWidget::branch:open:has-children:!has-siblings,
        QTreeWidget::branch:open:has-children:has-siblings {
            image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgNEw2IDlMOSA0IiBzdHJva2U9IiNmMWY1ZjkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=);
            width: 12px;
            height: 12px;
        }
        QHeaderView::section {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #4338ca, stop:1 #3730a3);
            color: #f8fafc;
            border: 1px solid #312e81;
            padding: 10px 8px;
            font-weight: bold;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        QHeaderView::section:hover {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #5b21b6, stop:1 #581c87);
        }
        QScrollBar:vertical {
            background: #1e293b;
            width: 14px;
            border-radius: 7px;
            margin: 2px;
        }
        QScrollBar::handle:vertical {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                      stop:0 #64748b, stop:1 #475569);
            border-radius: 6px;
            min-height: 25px;
            margin: 1px;
        }
        QScrollBar::handle:vertical:hover {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                                      stop:0 #94a3b8, stop:1 #64748b);
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
    
    networkLayout->addWidget(networkTree);
    
    // üåê Network Range Settings Button
    QHBoxLayout *networkRangeLayout = new QHBoxLayout();
    networkRangeBtn = new QPushButton(tr("üåê IP-Bereiche verwalten"));
    networkRangeBtn->setStyleSheet("font-weight: bold; background-color: #2563eb; color: white; padding: 8px;");
    networkRangeBtn->setToolTip(tr("Netzwerk-IP-Bereiche konfigurieren und Auto-Erkennung verwalten"));
    networkRangeLayout->addWidget(networkRangeBtn);
    networkRangeLayout->addStretch();
    networkLayout->addLayout(networkRangeLayout);
    
    leftLayout->addWidget(networkGroupBox);
    splitter->addWidget(leftPanel);

    // Right Panel
    QWidget *rightPanel = new QWidget();
    QVBoxLayout *rightLayout = new QVBoxLayout(rightPanel);
    QGroupBox *scanGroupBox = new QGroupBox(tr("üîç Duplikat-Scan"));
    QFormLayout *scanLayout = new QFormLayout(scanGroupBox);
    hashComboBox = new QComboBox();
    hashComboBox->addItems({
        "üß† Smart Auto-Detect (Empfohlen)",
        "‚ö° XXHash (Ultra-Fast, Video/Audio)",
        "üöÄ MD5 (Fast, Dokumente)",
        "üîí SHA-1 (Balance, Bilder)",
        "üõ°Ô∏è SHA-256 (Secure, Archive)",
        "üíé SHA-512 (Maximum Security)",
        "üî• BLAKE2 (Modern, schnell)",
        "üí´ BLAKE3 (Ultra-Modern, parallel)",
        "üåä SHA3 (Keccak, modern)",
        "üèéÔ∏è Murmur3 (Hash-Table optimiert)",
        "üèôÔ∏è CityHash (Google, sehr schnell)",
        "üöú FarmHash (Google, Nachfolger)",
        "üõ£Ô∏è HighwayHash (SIMD-optimiert)",
        "üöá MetroHash (Extrem schnell)",
        "üëª SpookyHash (Gut verteilt)"
    });
    hashComboBox->setCurrentIndex(0); // Smart Auto-Detect als Standard
    hardwareComboBox = new QComboBox();
    hardwareComboBox->addItems({"Auto Detect", "CPU Only", "GPU Accelerated"});
    themeComboBox = new QComboBox();
    themeComboBox->addItems({
        "üåê System Default",
        "‚òÄÔ∏è Light Theme (High Contrast)",
        "üåô Dark Theme (Blue Accent)",
        "üåë Dark Theme (Green Accent)",
        "üé® Dark Theme (Purple Accent)",
        "üî• Dark Theme (Red/Orange)",
        "‚ùÑÔ∏è Ice Theme (Light Blue)",
        "üå≤ Forest Theme (Dark Green)",
        "üé≠ High Contrast (Black/White)",
        "üå∏ Sakura Theme (Pink)"
    });
    
    // Connect theme change handler
    connect(themeComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &MainWindow::onThemeChanged);
    
    scanLayout->addRow(tr("Hash-Algorithmus:"), hashComboBox);
    scanLayout->addRow(tr("Hardware:"), hardwareComboBox);
    scanLayout->addRow(tr("Theme:"), themeComboBox);
    
    // ‚úÖ ERWEITERTE PROGRESS-ANZEIGE
    // Action-Label (was gerade passiert)
    actionLabel = new QLabel(tr("üîç Bereit"));
    actionLabel->setStyleSheet("QLabel { font-weight: bold; color: #FF0000; background-color: #00FF00; font-size: 10pt; font-family: 'DejaVu Sans', 'Liberation Sans', Arial, sans-serif; }");
    scanLayout->addRow(tr("Aktion:"), actionLabel);
    
    // Progress-Bar mit deutlich sichtbarer Prozentzahl
    progressBar = new QProgressBar();
    progressBar->setTextVisible(true); // Zeige Prozent in der Mitte
    progressBar->setFormat("%p%"); // Format: "45%"
    progressBar->setAlignment(Qt::AlignCenter); // Zentrierte Anzeige
    
    // Styling mit wei√üer Schrift auf gr√ºnem Balken
    progressBar->setStyleSheet(
        "QProgressBar {"
        "    background-color: #E0E0E0;"
        "    border: 2px solid #CCCCCC;"
        "    border-radius: 5px;"
        "    text-align: center;"
        "    color: #000000;"  // Schwarze Schrift auf grauem Hintergrund
        "    font-weight: bold;"
        "    font-size: 14px;"
        "}"
        "QProgressBar::chunk {"
        "    background-color: #4CAF50;"
        "    border-radius: 3px;"
        "}"
    );
    
    scanLayout->addRow(tr("Fortschritt:"), progressBar);
    
    // Datei X von Y Anzeige
    fileCountLabel = new QLabel(tr("Keine Dateien"));
    fileCountLabel->setStyleSheet("QLabel { color: #666; }");
    scanLayout->addRow(tr("Dateien:"), fileCountLabel);

    // üì° FTP-Verzeichnis-Anzeige
    ftpDirectoryCountLabel = new QLabel(tr("FTP: 0 Verzeichnisse"));
    ftpDirectoryCountLabel->setStyleSheet("QLabel { color: #1976D2; font-weight: bold; }");
    scanLayout->addRow(tr("FTP Gesamt:"), ftpDirectoryCountLabel);

    ftpCompletedLabel = new QLabel(tr("FTP: 0 abgearbeitet"));
    ftpCompletedLabel->setStyleSheet("QLabel { color: #388E3C; font-weight: bold; }");
    scanLayout->addRow(tr("FTP Fertig:"), ftpCompletedLabel);
    
    // üéØ NEUE DETAILLIERTE PROGRESS-LABELS
    currentFileLabel = new QLabel(tr("Bereit"));
    currentFileLabel->setStyleSheet("QLabel { color: #FF0000; background-color: #FFFF00; font-family: 'DejaVu Sans Mono', 'Liberation Mono', 'Courier New', monospace; font-size: 10pt; font-weight: bold; }");
    scanLayout->addRow(tr("Aktuelle Datei:"), currentFileLabel);
    
    fileComparisonLabel = new QLabel(tr("Bereit"));
    fileComparisonLabel->setStyleSheet("QLabel { color: #555; font-family: 'DejaVu Sans Mono', 'Liberation Mono', 'Courier New', monospace; font-size: 10pt; }");
    scanLayout->addRow(tr("Vergleiche:"), fileComparisonLabel);
    
    duplicateCountLabel = new QLabel(tr("0 Duplikate"));
    duplicateCountLabel->setStyleSheet("QLabel { color: #2E7D32; font-weight: bold; }");
    scanLayout->addRow(tr("Duplikate:"), duplicateCountLabel);
    
    // üöÄ ECHTZEIT HARDWARE-MONITORING
    hardwareStatusLabel = new QLabel(tr("Hardware bereit"));
    hardwareStatusLabel->setStyleSheet("QLabel { color: #555; }");
    scanLayout->addRow(tr("Hardware:"), hardwareStatusLabel);
    
    // CPU Echtzeit-Anzeige
    cpuLoadLabel = new QLabel(tr("CPU: 0%"));
    cpuLoadLabel->setStyleSheet("QLabel { color: #666; font-family: 'DejaVu Sans Mono', 'Liberation Mono', 'Courier New', monospace; font-weight: bold; font-size: 10pt; }");
    scanLayout->addRow(tr("üñ•Ô∏è CPU:"), cpuLoadLabel);
    
    // GPU Echtzeit-Anzeige
    gpuLoadLabel = new QLabel(tr("GPU: Inaktiv"));
    gpuLoadLabel->setStyleSheet("QLabel { color: #666; font-family: 'DejaVu Sans Mono', 'Liberation Mono', 'Courier New', monospace; font-weight: bold; font-size: 10pt; }");
    scanLayout->addRow(tr("üéÆ GPU:"), gpuLoadLabel);
    
    // NPU Echtzeit-Anzeige
    npuLoadLabel = new QLabel(tr("NPU: Inaktiv"));
    npuLoadLabel->setStyleSheet("QLabel { color: #666; font-family: monospace; font-weight: bold; font-size: 10pt; }");
    scanLayout->addRow(tr("üß† NPU:"), npuLoadLabel);
    
    pathProcessingLabel = new QLabel(tr("Warten..."));
    pathProcessingLabel->setStyleSheet("QLabel { color: #777; font-size: 10pt; }");
    scanLayout->addRow(tr("Pfad:"), pathProcessingLabel);
    
    rightLayout->addWidget(scanGroupBox);

    QGroupBox *resultsGroupBox = new QGroupBox(tr("üìä Scan-Ergebnisse"));
    QVBoxLayout *resultsLayout = new QVBoxLayout(resultsGroupBox);
    resultsTable = new QTableWidget();
    resultsTable->setColumnCount(5);
    resultsTable->setHorizontalHeaderLabels({tr("Status"), tr("Dateiname"), tr("Pfad"), tr("Gr√∂√üe"), tr("Hash")});
    resultsTable->setColumnWidth(0, 120);  // Status
    resultsTable->setColumnWidth(1, 250);  // Dateiname
    resultsTable->setColumnWidth(2, 400);  // Pfad
    resultsTable->setColumnWidth(3, 100);  // Gr√∂√üe
    resultsTable->setColumnWidth(4, 350);  // Hash - 350px f√ºr vollst√§ndigen MD5 (32 Zeichen)
    resultsTable->setSelectionBehavior(QAbstractItemView::SelectItems); // Select einzelne Items
    resultsTable->setSelectionMode(QAbstractItemView::ExtendedSelection); // Mehrfachauswahl
    resultsTable->setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked); // Edit bei Doppelklick
    resultsTable->setTextElideMode(Qt::ElideMiddle);
    resultsTable->setWordWrap(false);
    
    // Sortierung DEAKTIVIERT - Behalte Original ‚Üí Duplikate Reihenfolge
    resultsTable->setSortingEnabled(false);
    
    for (int i = 0; i < resultsTable->columnCount(); ++i) {
        resultsTable->horizontalHeader()->setSectionResizeMode(i, QHeaderView::Interactive);
    }
    
    resultsTable->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(resultsTable, &QTableWidget::customContextMenuRequested, 
            this, &MainWindow::showResultsContextMenu);
    
    // üìã DOUBLE-CLICK to copy cell text
    connect(resultsTable, &QTableWidget::cellDoubleClicked, this, [this](int row, int col) {
        QTableWidgetItem *item = resultsTable->item(row, col);
        if (!item) return;
        
        QString text = item->text();
        QApplication::clipboard()->setText(text);
        statusBar()->showMessage(tr("üìã Kopiert: %1").arg(text.length() > 50 ? text.left(50) + "..." : text), 2000);
    });
    
    // üìã COPY & PASTE: Ctrl+C Shortcut f√ºr resultsTable
    QShortcut *copyShortcut = new QShortcut(QKeySequence::Copy, resultsTable);
    connect(copyShortcut, &QShortcut::activated, this, [this]() {
        // Copy selected rows as tab-separated values
        QSet<int> selectedRowSet;
        for (QTableWidgetItem *it : resultsTable->selectedItems()) {
            if (it) selectedRowSet.insert(it->row());
        }
        if (selectedRowSet.isEmpty()) return;
        
        QStringList rows;
        QList<int> sortedRows = selectedRowSet.values();
        std::sort(sortedRows.begin(), sortedRows.end());
        for (int row : sortedRows) {
            QStringList cells;
            for (int col = 0; col < resultsTable->columnCount(); ++col) {
                QTableWidgetItem *item = resultsTable->item(row, col);
                cells.append(item ? item->text() : "");
            }
            rows.append(cells.join("\t"));
        }
        QApplication::clipboard()->setText(rows.join("\n"));
        statusBar()->showMessage(tr("üìã %1 Zeilen kopiert (Ctrl+C)").arg(rows.size()), 2000);
    });
    
    resultsLayout->addWidget(resultsTable);
    rightLayout->addWidget(resultsGroupBox);

    // Standard 2-Panel Layout ohne Mitte
    splitter->addWidget(leftPanel);
    splitter->addWidget(rightPanel);
    splitter->setSizes({600, 800});
    splitter->setStretchFactor(0, 1);  // Links Panel
    splitter->setStretchFactor(1, 2);  // Rechts Panel mehr Platz
    
    // Widgets nutzen verf√ºgbaren Platz
    networkTree->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    resultsTable->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    
    // Zentrales Widget Layout √§ndern von HBox zu VBox
    delete centralWidget->layout(); // Altes HBoxLayout entfernen
    QVBoxLayout *newMainLayout = new QVBoxLayout(centralWidget);
    newMainLayout->setContentsMargins(0, 0, 0, 0);  // Keine R√§nder f√ºr maximalen Platz
    newMainLayout->addWidget(splitter, 1);  // Stretch factor 1 = nutzt ganzen Platz

    createActions();
    setupMenuBar();
    setupToolBar();
}

void MainWindow::setupMenuBar()
{
    QMenu *fileMenu = menuBar()->addMenu(tr("&File"));
    fileMenu->addAction(m_addDirectoryAction);
    fileMenu->addAction(m_removeDirectoryAction);
    fileMenu->addSeparator();
    fileMenu->addAction(m_exitAction);

    QMenu *scanMenu = menuBar()->addMenu(tr("&Scan"));
    scanMenu->addAction(m_startScanAction);
    scanMenu->addAction(m_stopScanAction);
    scanMenu->addSeparator();
    scanMenu->addAction(m_networkScanAction);
    scanMenu->addAction(m_multiRangeScanAction);

    QMenu *toolsMenu = menuBar()->addMenu(tr("&Tools"));
    toolsMenu->addAction(m_settingsAction);
    toolsMenu->addAction(m_presetManagerAction);
    toolsMenu->addSeparator();
    toolsMenu->addAction(m_networkRangeAction);

    QMenu *helpMenu = menuBar()->addMenu(tr("&Help"));
    helpMenu->addAction(m_aboutAction);
    helpMenu->addAction(m_documentationAction);
}

void MainWindow::setupToolBar()
{
    QToolBar *mainToolBar = addToolBar(tr("Main Toolbar"));
    mainToolBar->setMovable(false);

    mainToolBar->addAction(m_addDirectoryAction);
    mainToolBar->addAction(m_removeDirectoryAction);
    mainToolBar->addSeparator();
    mainToolBar->addAction(m_startScanAction);
    mainToolBar->addAction(m_stopScanAction);
    mainToolBar->addSeparator();
    mainToolBar->addAction(m_networkScanAction);
    mainToolBar->addAction(m_multiRangeScanAction);
}

void MainWindow::createActions()
{
    m_addDirectoryAction = new QAction(QIcon(":/icons/add_folder.png"), tr("Add Directory"), this);
    m_removeDirectoryAction = new QAction(QIcon(":/icons/remove_folder.png"), tr("Remove Directory"), this);

    m_startScanAction = new QAction(QIcon(":/icons/start_scan.png"), tr("Start Scan"), this);
    m_stopScanAction = new QAction(QIcon(":/icons/stop_scan.png"), tr("Stop Scan"), this);
    m_networkScanAction = new QAction(QIcon(":/icons/network_scan.png"), tr("Network Scan"), this);
    m_multiRangeScanAction = new QAction(QIcon(":/icons/multi_range_scan.png"), tr("Alle Netzwerk-Bereiche scannen"), this);

    m_settingsAction = new QAction(QIcon(":/icons/settings.png"), tr("Settings"), this);
    m_presetManagerAction = new QAction(QIcon(":/icons/presets.png"), tr("Presets"), this);
    m_networkRangeAction = new QAction(QIcon(":/icons/network_range.png"), tr("Network Ranges"), this);

    m_aboutAction = new QAction(QIcon(":/icons/about.png"), tr("About"), this);
    m_documentationAction = new QAction(QIcon(":/icons/help.png"), tr("Documentation"), this);

    m_exitAction = new QAction(QIcon(":/icons/exit.png"), tr("Exit"), this);

    connect(m_addDirectoryAction, &QAction::triggered, this, &MainWindow::addDirectory);
    connect(m_removeDirectoryAction, &QAction::triggered, this, &MainWindow::removeSelectedDirectories);
    connect(m_startScanAction, &QAction::triggered, this, [this]()
            { startDuplicateScan(); });
    connect(m_stopScanAction, &QAction::triggered, this, &MainWindow::stopDuplicateScan);
    connect(m_networkScanAction, &QAction::triggered, this, &MainWindow::startNetworkDiscovery);
    connect(m_multiRangeScanAction, &QAction::triggered, this, &MainWindow::startMultiRangeScan);
    connect(m_settingsAction, &QAction::triggered, this, &MainWindow::showSettingsDialog);
    connect(m_presetManagerAction, &QAction::triggered, this, &MainWindow::showPresetManager);
    connect(m_networkRangeAction, &QAction::triggered, this, &MainWindow::showNetworkRangeSettings);
    connect(m_aboutAction, &QAction::triggered, this, &MainWindow::showAboutDialog);
    connect(m_exitAction, &QAction::triggered, this, &QMainWindow::close);
}

void MainWindow::setupConnections()
{
    // Directory Selection Buttons
    connect(selectDirBtn, &QPushButton::clicked, this, [this]() {
        QFileDialog dialog(this);
        dialog.setFileMode(QFileDialog::Directory);
        dialog.setOption(QFileDialog::ShowDirsOnly);
        dialog.setWindowTitle(tr("üìÇ Verzeichnisse f√ºr Duplikat-Scan ausw√§hlen"));
        
        if (dialog.exec() == QDialog::Accepted) {
            // üõë CRITICAL FIX: Leere alte Auswahl BEVOR neue Verzeichnisse hinzugef√ºgt werden
            m_selectedDirectories.clear();
            qDebug() << "[MainWindow] üßπ Alte Verzeichnisse geleert - starte mit neuer lokaler Auswahl";
            
            QStringList selectedPaths = dialog.selectedFiles();
            for (const QString &path : selectedPaths) {
                if (!m_selectedDirectories.contains(path)) {
                    m_selectedDirectories.append(path);
                }
            }
            updateDirectoryTree();
            statusBar()->showMessage(tr("üìÅ %1 Verzeichnisse ausgew√§hlt").arg(m_selectedDirectories.size()), 3000);
        }
    });
    
    connect(scanSelectedBtn, &QPushButton::clicked, this, [this]() {
        if (m_isScanning) {
            // üõë STOP: Scan l√§uft, stoppe ihn
            stopDuplicateScan();
            scanSelectedBtn->setText(tr("üîç Ausgew√§hlte scannen"));
            scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
        } else {
            // ‚ñ∂Ô∏è START: Starte neuen Scan
            if (m_selectedDirectories.isEmpty()) {
                QMessageBox::information(this, tr("Keine Verzeichnisse"),
                                       tr("Bitte w√§hlen Sie zuerst Verzeichnisse aus."));
                return;
            }
            startDuplicateScan();
            scanSelectedBtn->setText(tr("‚èπÔ∏è Scan stoppen"));
            scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #f44336; color: white;");
        }
    });    // ‚úÖ Directory Management - Summary Context Menu aktiviert statt directoryTree
    // connect(directoryTree, &QTreeWidget::customContextMenuRequested, this, &MainWindow::showDirectoryContextMenu);
    // connect(directoryTree, &QTreeWidget::itemExpanded, this, &MainWindow::onDirectoryItemExpanded);
    
    // Network Management
    connect(networkTree, &QTreeWidget::customContextMenuRequested, this, &MainWindow::showNetworkContextMenu);
    connect(networkTree, &QTreeWidget::itemDoubleClicked, this, &MainWindow::onNetworkServiceDoubleClicked);
    connect(networkTree, &QTreeWidget::itemChanged, this, &MainWindow::onNetworkTreeItemChanged);
    
    // üåê Network Range Management
    connect(networkRangeBtn, &QPushButton::clicked, this, &MainWindow::showNetworkRangeSettings);
    
    // Network Scanning
    std::cout << "\n[setupConnections] ================================================\n";
    std::cout << "[setupConnections] üîó Verbinde serviceFound Signal...\n";
    std::cout << "[setupConnections] m_networkScanner ist: " << (m_networkScanner ? "VALID ‚úÖ" : "NULL ‚ùå") << "\n";
    std::cout.flush();
    
    if (!m_networkScanner) {
        std::cout << "[setupConnections] ‚ùå KRITISCH: m_networkScanner ist nullptr!\n";
        std::cout.flush();
        return;
    }
    
    bool connectSuccess = connect(m_networkScanner, &NetworkScanner::serviceFound, this, [this](const NetworkService &service) {
        std::cout << "\n[Lambda-serviceFound] üéØüéØüéØ SIGNAL EMPFANGEN!!!\n";
        std::cout << "[Lambda] IP: " << service.ip.toUtf8().constData() << "\n";
        std::cout << "[Lambda] Port: " << service.port << "\n";
        std::cout << "[Lambda] Service: " << service.service.toUtf8().constData() << "\n";
        std::cout.flush();
        onNetworkServiceFound(service.ip, service.port, service.service);
    });
    
    std::cout << "[setupConnections] connect() Result: " << (connectSuccess ? "‚úÖ SUCCESS" : "‚ùå FAILED") << "\n";
    std::cout << "[setupConnections] ================================================\n";
    std::cout.flush();
    
    // ‚úÖ Reset network scan flags when scan completes
    connect(m_networkScanner, &NetworkScanner::scanFinished, this, [this]() {
        m_networkScanActive = false;
        m_multiRangeScanActive = false;
        statusBar()->showMessage(tr("‚úÖ Network Discovery abgeschlossen - IPs bleiben sichtbar"), 5000);
    });

    // Duplicate Scanning
    connect(m_scanner, &Scanner::scanProgress, this, &MainWindow::onScanProgress);
    connect(m_scanner, &Scanner::filesCollected, this, &MainWindow::onFilesCollected); // üî• NEW: FTP Discovery completion
    connect(m_scanner, &Scanner::ftpProgressUpdate, this, [this](int total, int completed, int pending) {
        if (ftpDirectoryCountLabel) {
            ftpDirectoryCountLabel->setText(QString("üì° FTP Gesamt: %1 Verzeichnisse").arg(total));
            ftpDirectoryCountLabel->repaint();
        }
        if (ftpCompletedLabel) {
            ftpCompletedLabel->setText(QString("‚úÖ FTP Fertig: %1 von %2 Verzeichnissen gescannt").arg(completed).arg(total));
            ftpCompletedLabel->repaint();
        }
    });
    connect(m_scanner, &Scanner::scanCompleted, this, [this](const DuplicateGroups &groups) {
        qDebug() << "[MainWindow] üì° scanCompleted Signal empfangen mit" << groups.groups.size() << "Gruppen";
        // Persist groups for deletion actions
        m_currentDuplicateGroups = groups;
        
        // ‚úÖ ALWAYS call onScanCompleted() to reset GUI state!
        qDebug() << "[MainWindow] ‚úÖ Calling onScanCompleted() mit" << groups.groups.size() << "Gruppen";
        onScanCompleted(groups);
    }, Qt::QueuedConnection);

    // üîß NEU: HashEngine duplicatesFound Signal f√ºr vollst√§ndige Duplikat-Anzeige
    connect(m_hashEngine, &HashEngine::duplicatesFound, this, [this](const QHash<QString, QStringList> &hashGroups, int totalFiles) {
        qDebug() << "[MainWindow] üîç HashEngine duplicatesFound Signal empfangen mit" << hashGroups.size() << "Hash-Gruppen und" << totalFiles << "Dateien";
        
        // Convert HashEngine format to DuplicateGroups format
        DuplicateGroups engineGroups;
        for (auto it = hashGroups.begin(); it != hashGroups.end(); ++it) {
            const QStringList &files = it.value();
            if (files.size() > 1) {  // Only process actual duplicate groups
                DuplicateGroup group;
                QList<FileInfo> fileInfos;
                
                // Convert file paths to FileInfo objects
                for (const QString &filePath : files) {
                    FileInfo fileInfo;
                    fileInfo.filePath = filePath;
                    fileInfo.hash = it.key();
                    
                    QFileInfo info(filePath);
                    fileInfo.size = info.size();
                    fileInfo.lastModified = info.lastModified().toSecsSinceEpoch();
                    fileInfo.isLocal = !filePath.startsWith("ftp://");
                    
                    fileInfos.append(fileInfo);
                }
                
                // Sort by preference: local files first, then by modification time
                std::sort(fileInfos.begin(), fileInfos.end(), [](const FileInfo &a, const FileInfo &b) {
                    if (a.isLocal != b.isLocal) {
                        return a.isLocal > b.isLocal; // Local files first
                    }
                    return a.lastModified < b.lastModified; // Oldest first as original
                });
                
                group.original = fileInfos.takeFirst();
                group.duplicates = fileInfos;
                group.hash = it.key();
                group.size = group.original.size;
                
                engineGroups.groups.append(group);
                engineGroups.duplicateFiles += group.duplicates.size();
                engineGroups.duplicateSize += group.size * group.duplicates.size();
            }
        }
        
        // üî• CRITICAL FIX: Setze totalFiles auf gescannte Dateien von HashEngine
        engineGroups.totalFiles = totalFiles; // ‚úÖ totalFiles kommt vom Signal-Parameter
        qDebug() << "[MainWindow] ‚úÖ HashEngine-Ergebnisse: totalFiles =" << engineGroups.totalFiles;
        
        qDebug() << "[MainWindow] üîç HashEngine-Gruppen konvertiert:" << engineGroups.groups.size() << "Gruppen mit" << engineGroups.duplicateFiles << "Duplikaten";
        
        // ‚úÖ ALWAYS use HashEngine results (they are the REAL duplicates based on full hash)
        qDebug() << "[MainWindow] ‚úÖ Verwende HashEngine-Ergebnisse (echte Hash-basierte Duplikate)";
        m_currentDuplicateGroups = engineGroups;
        
        // Update GUI with real duplicate results
        qDebug() << "[MainWindow] üéØ Aktualisiere GUI mit HashEngine-Ergebnissen:" << engineGroups.groups.size() << "Gruppen";
        onScanCompleted(engineGroups);
    }, Qt::QueuedConnection);
    
    // üöÄ ECHTZEIT-STATUS-UPDATES: Zeige Scan-Status in GUI
    connect(m_scanner, &Scanner::scanStatusChanged, this, [this](const QString &status) {
        // Zeige Status in StatusBar UND im actionLabel
        statusBar()->showMessage(status, 3000);
        if (actionLabel) {
            actionLabel->setText(status);
        }
        qDebug() << "[MainWindow] üìä Status-Update:" << status;
    }, Qt::QueuedConnection);
    
    // üöÄ NEUE DETAILLIERTE PROGRESS-VERBINDUNGEN
    connect(m_scanner, &Scanner::currentFileProcessing, this, &MainWindow::onCurrentFileProcessing);
    connect(m_scanner, &Scanner::processActivityUpdate, this, &MainWindow::onProcessActivityUpdate);
    connect(m_scanner, &Scanner::fileComparisonProgress, this, &MainWindow::onFileComparisonProgress);
    connect(m_scanner, &Scanner::pathProcessingUpdate, this, &MainWindow::onPathProcessingUpdate);
    connect(m_scanner, &Scanner::duplicateDetectionUpdate, this, &MainWindow::onDuplicateDetectionUpdate);
    connect(m_scanner, &Scanner::hardwareUsageUpdate, this, &MainWindow::onHardwareUsageUpdate);

    // ‚úÖ KRITISCH: Signal-Slot f√ºr thread-sichere FTP-GUI-Updates
    connect(this, &MainWindow::ftpDirectoriesReady, this, &MainWindow::handleFtpDirectoriesReady, Qt::QueuedConnection);
    
    // üöÄ ECHTZEIT HARDWARE-MONITORING: Update alle 250ms (4x pro Sekunde)
    QTimer *hardwareMonitorTimer = new QTimer(this);
    connect(hardwareMonitorTimer, &QTimer::timeout, this, &MainWindow::updateHardwareMonitoring);
    hardwareMonitorTimer->start(250); // 250ms = 4 FPS f√ºr Hardware-Anzeige

    // ‚úÖ HARDWARE STATUS WIDGET INITIALIZATION & CONNECTIONS
    if (!m_hardwareStatusWidget) {
        m_hardwareStatusWidget = new HardwareStatusWidget(this);
        qDebug() << "[setupConnections] ‚úÖ HardwareStatusWidget erstellt";
    }
    
    // Connect Scanner hardware status updates to widget
    connect(m_scanner, QOverload<int, int>::of(&Scanner::cpuStatusUpdated), 
            m_hardwareStatusWidget, &HardwareStatusWidget::updateCpuStatus);
    connect(m_scanner, QOverload<bool, const QString&, int>::of(&Scanner::gpuStatusUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateGpuStatus);
    connect(m_scanner, QOverload<int, int>::of(&Scanner::gpuMemoryUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateGpuMemory);
    connect(m_scanner, QOverload<int>::of(&Scanner::gpuClockUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateGpuClock);
    connect(m_scanner, QOverload<int>::of(&Scanner::gpuTemperatureUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateGpuTemperature);
    connect(m_scanner, QOverload<bool, int>::of(&Scanner::npuStatusUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateNpuStatus);
    connect(m_scanner, QOverload<int, int, const QString&>::of(&Scanner::npuActivityUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateNpuActivity);
    connect(m_scanner, QOverload<int>::of(&Scanner::npuPowerUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateNpuPower);
    connect(m_scanner, QOverload<int>::of(&Scanner::ioStatusUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateIoStatus);
    connect(m_scanner, QOverload<int>::of(&Scanner::memoryStatusUpdated),
            m_hardwareStatusWidget, &HardwareStatusWidget::updateMemoryStatus);
    
    // ‚úÖ LIVE BENCHMARK MONITOR INITIALIZATION & CONNECTIONS
    if (!m_liveBenchmarkMonitor) {
        m_liveBenchmarkMonitor = new LiveBenchmarkMonitor(this);
        qDebug() << "[setupConnections] ‚úÖ LiveBenchmarkMonitor erstellt";
    }
    
    connect(m_scanner, &Scanner::processActivityUpdate, m_liveBenchmarkMonitor, &LiveBenchmarkMonitor::onActivityLogged);
    connect(m_scanner, &Scanner::scanProgress, m_liveBenchmarkMonitor, &LiveBenchmarkMonitor::onScanProgress);
    connect(m_scanner, &Scanner::scanStatusChanged, m_liveBenchmarkMonitor, &LiveBenchmarkMonitor::onStatusChanged);
    
    // üîê HASH ENGINE PROGRESS CONNECTION
    if (m_scanner && m_scanner->getHashEngine()) {
        connect(m_scanner->getHashEngine(), &HashEngine::hashProgress, 
                this, &MainWindow::onHashProgress);
        qDebug() << "[setupConnections] ‚úÖ HashEngine hashProgress Signal verbunden";
    }
    
    // ‚úÖ SETTINGS DIALOG CONNECTIONS
    connect(m_settingsAction, &QAction::triggered, this, &MainWindow::showSettingsDialog);
    
    qDebug() << "[setupConnections] ‚úÖ Alle Widget-Verbindungen hergestellt";

}

void MainWindow::onDirectoryDoubleClicked(QTreeWidgetItem *item, int column)
{
    Q_UNUSED(column)
    if (item)
    {
        QString path = item->text(0);
        QMessageBox::information(this, tr("Directory"), tr("Selected: %1").arg(path));
    }
}

void MainWindow::onNetworkServiceDoubleClicked(QTreeWidgetItem *item, int column)
{
    Q_UNUSED(column);
    if (!item) return;

    // üîß INTELLIGENTE DATENEXTRAKTION: Adaptiert f√ºr neue Metadaten-Struktur
    QString ip = item->data(0, Qt::UserRole).toString();
    int port = item->data(0, Qt::UserRole + 1).toInt();
    QString service = item->data(0, Qt::UserRole + 2).toString();
    
    if (ip.isEmpty() || port == 0) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Unvollst√§ndige Service-Daten - √ºberspringe Doppelklick";
        return;
    }

    qDebug() << "[MainWindow] üñ±Ô∏è Network Service Doppelklick:" << ip << port << service;

    // ‚úÖ KRITISCH: Pr√ºfe Auto-Login zuerst
    if (m_presetManager) {
        LoginData existingLogin = m_presetManager->getLogin(ip, port);
        if (existingLogin.autoLogin && !existingLogin.username.isEmpty() && !existingLogin.password.isEmpty()) {
            qDebug() << "[MainWindow] üöÄ‚ú® AUTO-LOGIN erkannt f√ºr" << ip << "- Direkte Verbindung ohne Dialog";
            statusBar()->showMessage(tr("üöÄ Auto-Login: Verbinde mit %1:%2...").arg(ip).arg(port));
            
            // Direkt verbinden ohne Dialog-Anzeige
            connectAndShowDirectoryTree(ip, port, service, 
                                       existingLogin.username, existingLogin.password);
            return;
        }
    }

    // Fallback: Login-Dialog anzeigen wenn kein Auto-Login
    showLoginDialog(ip, port, service);
}

void MainWindow::onNetworkServiceFound(const QString &ip, int port, const QString &service)
{
    qDebug() << "[MainWindow] onNetworkServiceFound() aufgerufen:" << ip << port << service;
    addNetworkService(ip, port, service);
}

void MainWindow::showLoginDialog(const QString &ip, int port, const QString &service)
{
    LoginDialog dialog(this);
    dialog.setServiceInfo(ip, port, service);

    // Load existing credentials if available
    if (m_presetManager) {
        dialog.setExistingLogin(m_presetManager->getLogin(ip, port));
    }

    if (dialog.exec() == QDialog::Accepted) {
        LoginData loginData = dialog.getLoginData();
        
        // Save credentials if saveCredentials is enabled
        if (loginData.saveCredentials && m_presetManager) {
            m_presetManager->saveLogin(ip, port, loginData);
            qDebug() << "[MainWindow] üíæ Login gespeichert f√ºr" << ip << ":" << port 
                     << "AutoLogin:" << loginData.autoLogin;
        }

        // Connect and show directory tree dialog
        connectAndShowDirectoryTree(ip, port, service, loginData.username, loginData.password);
    }
}

void MainWindow::connectAndShowDirectoryTree(const QString &ip, int port, const QString &service, const QString &username, const QString &password)
{
    qDebug() << "[MainWindow] üîå connectAndShowDirectoryTree:" << service << "auf Port" << port;
    
    // üîç EXPLICIT DEBUG f√ºr Service-Erkennung
    QString serviceLower = service.toLower();
    bool isSSH = serviceLower.contains("ssh");
    bool isSFTP = serviceLower.contains("sftp");
    bool isFTP = serviceLower.contains("ftp") && !serviceLower.contains("sftp");
    
    qDebug() << "[MainWindow] üîç Service-Analyse:";
    qDebug() << "  üìù Original Service:" << service;
    qDebug() << "  üìù Lowercase Service:" << serviceLower;
    qDebug() << "  üîê Contains SSH:" << isSSH;
    qDebug() << "  üîê Contains SFTP:" << isSFTP;
    qDebug() << "  üì° Contains FTP (pure):" << isFTP;
    
    // ‚úÖ SSH/SFTP-Erkennung MUSS vor FTP-Erkennung stehen!
    if (isSSH || isSFTP) {
        qDebug() << "[MainWindow] üîê SSH/SFTP-Protokoll erkannt auf Port" << port;
        
        // ‚úÖ SFTP-Unterst√ºtzung: Verwende externe Tools oder zeige Hinweis
        QString message = QString("SSH/SFTP-Verbindung zu %1:%2\n\n"
                                "Benutzer: %3\n"
                                "Protokoll: %4\n\n"
                                "SSH/SFTP wird derzeit √ºber externe Tools unterst√ºtzt.\n"
                                "Sie k√∂nnen sich manuell verbinden mit:\n"
                                "sftp %3@%1")
                         .arg(ip).arg(port).arg(username).arg(service);
        
        QMessageBox::information(this, "SSH/SFTP Verbindung", message);
        
        // Markiere Service als "SSH erkannt" im Netzwerk-Tree
        QList<QTreeWidgetItem*> items = networkTree->findItems(ip, Qt::MatchContains | Qt::MatchRecursive, 0);
        if (!items.isEmpty()) {
            QTreeWidgetItem *serviceItem = items.first();
            serviceItem->setText(2, "üîê SSH erkannt");
            serviceItem->setIcon(0, QIcon("üîê"));
        }
    }
    else if (isFTP) {
        qDebug() << "[MainWindow] üì° FTP-Protokoll erkannt - verwende FtpClient";
        FtpClient *ftp = new FtpClient(this);
        ftp->setCredentials(ip, port, username, password);
        
        // Connect to signals BEFORE connecting to host
        connect(ftp, &FtpClient::connected, this, [ftp](){
            qDebug() << "[MainWindow] ‚úÖ FTP connected, starting directory list at root...";
            // Start at server root ‚Äì no hardcoded paths
            ftp->list("/");
        });
        
        connect(ftp, &FtpClient::listFinished, this, [this, ip, ftp](const QStringList &dirs, bool success){
            qDebug() << "[MainWindow] üìã FTP listFinished:" << dirs.size() << "directories, success:" << success;
            if (success) {
                emit ftpDirectoriesReady(ip, dirs);
            } else {
                QMessageBox::warning(this, tr("FTP Fehler"), tr("Konnte echte Verzeichnisliste nicht abrufen. Bitte Berechtigungen pr√ºfen oder anderes Startverzeichnis w√§hlen."));
            }
            ftp->deleteLater(); // Clean up FTP client
        });
        
        connect(ftp, &FtpClient::error, this, [this, ip, ftp](const QString &error){
            qDebug() << "[MainWindow] ‚ùå FTP error:" << error;
            QMessageBox::critical(this, "FTP Verbindungsfehler", 
                                QString("Verbindung zu %1 fehlgeschlagen:\n%2").arg(ip, error));
            ftp->deleteLater(); // Clean up FTP client
        });

        // NOW actually connect to the FTP server
        qDebug() << "[MainWindow] üöÄ Starting FTP connection to" << ip << ":" << port;
        ftp->connectToHost();
    }
    else if (service.toLower().contains("smb") || service.toLower().contains("cifs")) {
        qDebug() << "[MainWindow] üóÇÔ∏è SMB/CIFS-Protokoll erkannt auf Port" << port;
        
        QString message = QString("SMB/CIFS-Verbindung zu %1:%2\n\n"
                                "Benutzer: %3\n"
                                "Protokoll: %4\n\n"
                                "SMB/CIFS wird derzeit √ºber System-Mount unterst√ºtzt.\n"
                                "Sie k√∂nnen sich manuell verbinden mit:\n"
                                "smbclient //%1/share -U %3")
                         .arg(ip).arg(port).arg(username).arg(service);
        
        QMessageBox::information(this, "SMB/CIFS Verbindung", message);
    }
    else {
        qDebug() << "[MainWindow] ‚ùì Unbekanntes Protokoll:" << service << "- zeige generischen Hinweis";
        
        QString message = QString("Verbindung zu %1:%2\n\n"
                                "Benutzer: %3\n"
                                "Protokoll: %4\n\n"
                                "Dieses Protokoll wird derzeit nicht direkt unterst√ºtzt.\n"
                                "Bitte verwenden Sie externe Tools f√ºr die Verbindung.")
                         .arg(ip).arg(port).arg(username).arg(service);
        
        QMessageBox::information(this, "Protokoll nicht unterst√ºtzt", message);
    }
}

void MainWindow::handleFtpDirectoriesReady(const QString &ip, const QStringList &directories)
{
    // Ensure this runs on the main GUI thread
    if (QThread::currentThread() != this->thread()) {
        QMetaObject::invokeMethod(this, [this, ip, directories]() {
            handleFtpDirectoriesReady(ip, directories);
        }, Qt::QueuedConnection);
        return;
    }

    qDebug() << "[MainWindow] üìÇ FTP-Verzeichnisse empfangen f√ºr" << ip << "mit" << directories.size() << "Verzeichnissen";
    
    // Update network tree to show connected status only
    QList<QTreeWidgetItem*> items = networkTree->findItems(ip, Qt::MatchContains | Qt::MatchRecursive, 0);
    if (!items.isEmpty()) {
        QTreeWidgetItem *serviceItem = items.first();
        serviceItem->setText(2, "üü¢ Verbunden");
        serviceItem->setIcon(0, QIcon("üì°"));
    }

    // ‚úÖ KORREKTE L√ñSUNG: SimpleTreeDialog statt NetworkDirectoryDialog verwenden
    qDebug() << "[MainWindow] üöÄ √ñffne SimpleTreeDialog mit Verzeichnis-Hierarchie";
    
    SimpleTreeDialog *dialog = new SimpleTreeDialog(QString("%1 (FTP)").arg(ip), this);
    
    // ‚ö° CRITICAL FIX: Signal verbinden VOR setDirectories(), da setDirectories() sofort Signale emittiert!
    connect(dialog, &SimpleTreeDialog::directoryExpanded, 
            this, [this, ip, dialog](const QString &path) {
        qDebug() << "[MainWindow] üì° FTP-LIST-Anfrage f√ºr Unterverzeichnisse:" << path;
        requestFtpSubdirectoriesForDialog(ip, path, dialog);
    });
    
    // Jetzt erst Verzeichnisse setzen - triggert automatisch directoryExpanded f√ºr Root-Level
    dialog->setDirectories(directories);
    
    if (dialog->exec() == QDialog::Accepted) {
        QStringList selectedDirs = dialog->getSelectedDirectories();
        qDebug() << "[MainWindow] ‚úÖ Benutzer hat" << selectedDirs.size() << "Verzeichnisse ausgew√§hlt";
        qDebug() << "[MainWindow] üîç Debug: Ausgew√§hlte Pfade:" << selectedDirs;
        
        // üõë CRITICAL FIX: Leere alte Verzeichnisse BEVOR neue hinzugef√ºgt werden
        m_selectedDirectories.clear();
        qDebug() << "[MainWindow] üßπ Alte Verzeichnisse geleert - starte mit neuer Auswahl";
        
        // F√ºge ausgew√§hlte FTP-Verzeichnisse hinzu
        int addedCount = 0;
        for (const QString &dir : selectedDirs) {
            qDebug() << "[MainWindow] üîç Debug: Verarbeite Pfad:" << dir;
            // FTP-URL korrekt konstruieren - dir ist bereits vollst√§ndiger Pfad
            QString ftpUrl;
            if (dir.startsWith("ftp://")) {
                // Bereits vollst√§ndige FTP-URL
                ftpUrl = dir;
            } else {
                // Konstruiere FTP-URL aus Pfad
                QString cleanPath = dir;
                qDebug() << "[MainWindow] üîç Debug: Original-Pfad:" << dir;
                if (cleanPath.startsWith("/")) cleanPath = cleanPath.mid(1);
                qDebug() << "[MainWindow] üîç Debug: Clean-Pfad:" << cleanPath;
                ftpUrl = QString("ftp://%1/%2").arg(ip, cleanPath);
                qDebug() << "[MainWindow] üîç Debug: Konstruierte URL:" << ftpUrl;
            }
            
            // Bereinige nur echte doppelte Slashes (nicht ftp://)
            ftpUrl = ftpUrl.replace(QRegularExpression("([^:])//+"), "\\1/");
            
            if (!m_selectedDirectories.contains(ftpUrl)) {
                m_selectedDirectories.append(ftpUrl);
                addedCount++;
                qDebug() << "[MainWindow] ‚ûï FTP-URL hinzugef√ºgt:" << ftpUrl;
            }
        }
        
        // ‚úÖ SICHERE GUI-AKTUALISIERUNG: Verwende updateDirectorySummary statt updateDirectoryTree
        updateDirectorySummary();
        updateSelectedDirectoriesDisplay();
        statusBar()->showMessage(tr("‚úÖ %1 FTP-Verzeichnisse hinzugef√ºgt").arg(addedCount), 5000);
        
        qDebug() << "[MainWindow] üìÅ FTP-Verzeichnisse vom Benutzer ausgew√§hlt:" << addedCount;
    } else {
        qDebug() << "[MainWindow] ‚ùå Benutzer hat Dialog abgebrochen";
        statusBar()->showMessage("‚ùå Keine FTP-Verzeichnisse hinzugef√ºgt", 3000);
    }
    
    dialog->deleteLater();
}

void MainWindow::requestFtpSubdirectories(const QString &ip, const QString &path)
{
    qDebug() << "[MainWindow] üöÄ Starte FTP-LIST f√ºr Unterverzeichnisse:" << ip << path;
    
    // Hole gespeicherte Login-Daten f√ºr diesen Server
    LoginData loginData = m_presetManager->getLogin(ip, 21);
    
    if (!loginData.isValid()) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Keine Login-Daten f√ºr" << ip << "gefunden";
        return;
    }
    
    // Erstelle neuen FTP-Client f√ºr Unterverzeichnis-Scan
    FtpClient *subdirClient = new FtpClient(this);
    subdirClient->setCredentials(ip, 21, loginData.username, loginData.password);
    
    // Verbinde das listFinished Signal
    connect(subdirClient, &FtpClient::listFinished, this, 
        [this, ip, path, subdirClient](const QStringList &subdirs, bool success) {
            if (success && !subdirs.isEmpty()) {
                qDebug() << "[MainWindow] ‚úÖ Unterverzeichnisse f√ºr" << path << "empfangen:" << subdirs.size();
                
                // Finde den aktiven NetworkDirectoryDialog
                NetworkDirectoryDialog *activeDialog = findChild<NetworkDirectoryDialog*>();
                if (activeDialog) {
                    activeDialog->addSubdirectories(path, subdirs);
                } else {
                    qDebug() << "[MainWindow] ‚ö†Ô∏è Kein aktiver NetworkDirectoryDialog gefunden";
                }
            } else {
                qDebug() << "[MainWindow] ‚ùå FTP-LIST f√ºr Unterverzeichnisse fehlgeschlagen:" << path;
            }
            
            // Cleanup
            subdirClient->deleteLater();
        });
    
    // Starte FTP-Verbindung
    connect(subdirClient, &FtpClient::connected, subdirClient, [subdirClient, path]() {
        qDebug() << "[FtpClient] üöÄ Verbunden - starte LIST f√ºr:" << path;
        subdirClient->list(path);
    });
    
    subdirClient->connectToHost();
}

void MainWindow::requestFtpSubdirectoriesForDialog(const QString &ip, const QString &path, NetworkDirectoryDialog *dialog)
{
    qDebug() << "[MainWindow] üöÄ Starte FTP-LIST f√ºr Unterverzeichnisse mit Dialog-Referenz:" << ip << path;
    
    // Hole gespeicherte Login-Daten f√ºr diesen Server
    LoginData loginData = m_presetManager->getLogin(ip, 21);
    
    if (!loginData.isValid()) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Keine Login-Daten f√ºr" << ip << "gefunden";
        return;
    }
    
    // Erstelle neuen FTP-Client f√ºr Unterverzeichnis-Scan
    FtpClient *subdirClient = new FtpClient(this);
    subdirClient->setCredentials(ip, 21, loginData.username, loginData.password);
    
    // Verbinde das listFinished Signal direkt mit dem Dialog
    connect(subdirClient, &FtpClient::listFinished, this, 
        [this, ip, path, dialog, subdirClient](const QStringList &subdirs, bool success) {
            if (success && !subdirs.isEmpty()) {
                qDebug() << "[MainWindow] ‚úÖ Unterverzeichnisse f√ºr" << path << "empfangen:" << subdirs.size() << "Eintr√§ge";
                
                if (dialog) {
                    dialog->addSubdirectories(path, subdirs);
                    qDebug() << "[MainWindow] üìã Unterverzeichnisse an Dialog weitergegeben";
                } else {
                    qDebug() << "[MainWindow] ‚ö†Ô∏è Dialog-Referenz ung√ºltig";
                }
            } else {
                qDebug() << "[MainWindow] ‚ùå FTP-LIST f√ºr Unterverzeichnisse fehlgeschlagen:" << path;
            }
            
            // Cleanup
            subdirClient->deleteLater();
        });
    
    // Starte FTP-Verbindung
    connect(subdirClient, &FtpClient::connected, subdirClient, [subdirClient, path]() {
        qDebug() << "[FtpClient] üöÄ Verbunden f√ºr Unterverzeichnisse - starte LIST f√ºr:" << path;
        subdirClient->list(path);
    });
    
    subdirClient->connectToHost();
}

// ‚úÖ THREAD-SAFE FTP hierarchical tree building on main GUI thread
void MainWindow::buildHierarchicalFtpTree(const QString &ip, const QStringList &directories)
{
    // ‚ùå CRASH PREVENTION: Diese Funktion ist tempor√§r deaktiviert
    // Die komplexe Tree-Manipulation verursacht Speicherzugriffsfehler
    
    qDebug() << "‚ö†Ô∏è buildHierarchicalFtpTree() DEAKTIVIERT f√ºr" << ip 
             << "mit" << directories.size() << "Verzeichnissen";
    qDebug() << "üîß FTP-Tree-Integration erfordert separaten Dialog f√ºr sichere Mehrfachauswahl";
    
    // Tempor√§re Benachrichtigung ohne GUI-Manipulation
    statusBar()->showMessage(tr("üìÅ FTP-Verzeichnisbaum f√ºr %1 verf√ºgbar (Dialog erforderlich)").arg(ip), 5000);
    
    // ‚ùå GESAMTE TREE-MANIPULATION DEAKTIVIERT
    return;
    
    // ‚ùå ALLE WEITEREN TREE-OPERATIONEN DEAKTIVIERT
    /*
    // Root-Element
    QTreeWidgetItem *rootItem = new QTreeWidgetItem();
    rootItem->setText(0, QString("üì° FTP %1").arg(ip));
    [... komplette Tree-Manipulation entfernt ...]
    */
}


void MainWindow::startDuplicateScan()
{
    // ‚úÖ FIX: Stoppe vorherigen Scan statt zu blockieren
    if (m_isScanning) {
        qDebug() << "[MainWindow] ‚è∏Ô∏è Stoppe vorherigen Scan, starte neuen...";
        statusBar()->showMessage(tr("‚è∏Ô∏è Stoppe vorherigen Scan, starte neuen..."), 2000);
        if (m_scanner) {
            m_scanner->stopScan(); // Stoppe aktuellen Scan
        }
        m_isScanning = false; // Reset state
    }
    
    // üîÑ RESET: Hash-Berechnung und FileCollection Flags zur√ºcksetzen
    m_hashCalculationStarted = false;
    m_filesCollectedHandled = false;
    qDebug() << "[MainWindow] üîÑ RESET: Hash- und FileCollection-Flags zur√ºckgesetzt";

    // ‚úÖ KORREKTUR: Verwende m_selectedDirectories statt Checkboxen aus directoryTree
    QStringList selectedDirs = m_selectedDirectories;

    qDebug() << "[MainWindow] üîç Starte Duplikat-Scan mit" << selectedDirs.size() << "Verzeichnissen:" << selectedDirs;

    if (selectedDirs.isEmpty()) {
        QMessageBox::information(this, tr("Keine Verzeichnisse"), 
                                tr("Bitte w√§hlen Sie Verzeichnisse zum Scannen aus."));
        return;
    }

    resultsTable->setRowCount(0);
    
    // ÔøΩÔ∏è HASH-SCHUTZ: Hash-Indizes NICHT vor Scan l√∂schen - werden nach Duplikat-L√∂schung freigegeben!
    // Hash-Daten m√ºssen erhalten bleiben f√ºr die Duplikatliste-Anzeige
    // L√∂schung erfolgt automatisch in onDeletionCompleted() NACH dem L√∂schen der Duplikate
    if (m_scanner) {
        qDebug() << "[MainWindow] ÔøΩÔ∏è Hash-Indizes bleiben erhalten f√ºr aktuelle Duplikatliste";
        // m_scanner->clearAllHashes();  // ‚ùå DEAKTIVIERT - l√∂scht Hashes f√ºr angezeigte Duplikate!
    }
    
    // ‚úÖ ERWEITERTE PROGRESS-INITIALISIERUNG
    progressBar->setValue(0);
    actionLabel->setText(tr("üîç Starte Duplikat-Scan..."));
    fileCountLabel->setText(tr("Bereite Scan vor..."));
    statusBar()->showMessage(tr("üîç Duplikat-Scan wird gestartet..."));
    statusBar()->showMessage(tr("üöÄ Starte Duplikat-Scan..."));

    // üß† SMART AUTO-DETECT: W√§hle Hash basierend auf Dateityp
    QString selectedHashAlgo = hashComboBox->currentText();
    QString hashAlgorithm;
    
    if (selectedHashAlgo.startsWith("üß†")) {
        hashAlgorithm = "SMART"; // Auto-Detect aktiviert
        qDebug() << "[MainWindow] üß† Smart Auto-Detect aktiviert";
        statusBar()->showMessage(tr("üß† Smart Auto-Detect: Optimaler Hash + Hardware pro Dateityp"), 3000);
    } else if (selectedHashAlgo.contains("XXHash")) {
        hashAlgorithm = "XXHASH";
    } else if (selectedHashAlgo.contains("MD5")) {
        hashAlgorithm = "MD5";
    } else if (selectedHashAlgo.contains("SHA-1")) {
        hashAlgorithm = "SHA1";
    } else if (selectedHashAlgo.contains("SHA-256")) {
        hashAlgorithm = "SHA256";
    } else if (selectedHashAlgo.contains("SHA-512")) {
        hashAlgorithm = "SHA512";
    } else if (selectedHashAlgo.contains("BLAKE2")) {
        hashAlgorithm = "BLAKE2";
    } else if (selectedHashAlgo.contains("BLAKE3")) {
        hashAlgorithm = "BLAKE3";
    } else if (selectedHashAlgo.contains("SHA3")) {
        hashAlgorithm = "SHA3";
    } else if (selectedHashAlgo.contains("Murmur3")) {
        hashAlgorithm = "MURMUR3";
    } else if (selectedHashAlgo.contains("CityHash")) {
        hashAlgorithm = "CITYHASH";
    } else if (selectedHashAlgo.contains("FarmHash")) {
        hashAlgorithm = "FARMHASH";
    } else if (selectedHashAlgo.contains("HighwayHash")) {
        hashAlgorithm = "HIGHWAY";
    } else if (selectedHashAlgo.contains("MetroHash")) {
        hashAlgorithm = "METROHASH";
    } else if (selectedHashAlgo.contains("SpookyHash")) {
        hashAlgorithm = "SPOOKY";
    } else {
        hashAlgorithm = "BLAKE2"; // Fallback zu modernem schnellen Algo
    }
    
    qDebug() << "[MainWindow] üîê Gew√§hlter Hash-Algorithmus:" << hashAlgorithm;
    
    // ‚úÖ FTP-INTEGRATION AKTIVIERT: Alle Pfade werden unterst√ºtzt
    QStringList safeDirs = selectedDirs; // Alle Pfade sind jetzt sicher
    
    qDebug() << "[MainWindow] üìÅ Scan mit" << safeDirs.size() << "Verzeichnissen (lokal + FTP):" << safeDirs;
    
    // ‚úÖ WICHTIG: FtpClient dem Scanner zur Verf√ºgung stellen f√ºr FTP-Pfade
    // ‚úÖ FTP-INTEGRATION AKTIVIERT: Credentials aus INI-Datei laden
    bool hasFtpPaths = false;
    for (const QString &dir : selectedDirs) {
        if (dir.startsWith("ftp://")) {
            hasFtpPaths = true;
            break;
        }
    }
    
    if (hasFtpPaths) {
        qDebug() << "[MainWindow] üîê FTP-Pfade erkannt - lade Credentials aus INI-Datei...";
        // Erstelle FtpClient mit den gespeicherten Credentials f√ºr diesen Scan
        for (const QString &dir : selectedDirs) {
            if (dir.startsWith("ftp://")) {
                QUrl ftpUrl(dir);
                QString host = ftpUrl.host();
                
                // Hole Login-Daten f√ºr diesen Host
                LoginData loginData = m_presetManager->getLogin(host, 21);
                if (loginData.isValid()) {
                    // Konfiguriere den bestehenden FtpClient
                    m_ftpClient->setCredentials(host, 21, loginData.username, loginData.password);
                    qDebug() << "[MainWindow] ‚úÖ FtpClient-Credentials aus INI gesetzt f√ºr:" << host << "User:" << loginData.username;
                    break; // Ein FtpClient reicht f√ºr alle FTP-Pfade desselben Hosts
                } else {
                    qWarning() << "[MainWindow] ‚ùå Keine FTP-Credentials gefunden f√ºr Host:" << host;
                }
            }
        }
    }
    
    // ‚úÖ Setze Scanning-Flag
    m_isScanning = true;
    m_hashCalculationStarted = false;  // üîÑ Reset hash calculation flag for new scan
    
    // üîÑ WICHTIG: Duplikat-Label zur√ºcksetzen - NICHT "0 Duplikate" w√§hrend Scan zeigen!
    if (duplicateCountLabel) {
        duplicateCountLabel->setText(tr("üîç Scan l√§uft..."));
    }
    
    // üîÑ Tabelle leeren w√§hrend Scan l√§uft
    if (resultsTable) {
        resultsTable->setRowCount(0);
    }
    
    qDebug() << "[MainWindow] üß™ PRE: Scanner::startScan call";
    qDebug() << "[MainWindow] üöÄ Rufe Scanner::startScan auf mit sicheren Pfaden:" << safeDirs << "Hash:" << hashAlgorithm;
    if (!m_scanner) {
        qCritical() << "[MainWindow] ‚ùå Scanner ist nullptr ‚Äì Abbruch";
        QMessageBox::critical(this, tr("Fehler"), tr("Scanner-Komponente nicht verf√ºgbar."));
        return;
    }
    m_scanner->startScan(safeDirs, hashAlgorithm, "*");  // Verwende safeDirs statt selectedDirs
    qDebug() << "[MainWindow] ‚úÖ POST: Scanner::startScan returned";
    statusBar()->showMessage(tr("üîç Scan gestartet mit %1 lokalen Verzeichnissen...").arg(safeDirs.size()));
    m_activityIndicator->setActivity(true);
}

void MainWindow::stopDuplicateScan()
{
    qDebug() << "[MainWindow] üõë stopDuplicateScan() aufgerufen - m_isScanning:" << m_isScanning;
    
    if (m_scanner && m_isScanning) {
        qDebug() << "[MainWindow] üõë Rufe m_scanner->stopScan() auf";
        m_scanner->stopScan();
        m_isScanning = false;
        statusBar()->showMessage(tr("‚èπÔ∏è Scan gestoppt!"), 3000);
        m_activityIndicator->setActivity(false);
        
        // Reset GUI
        if (progressBar) progressBar->setValue(0);
        if (actionLabel) actionLabel->setText(tr("Bereit"));
        if (currentFileLabel) currentFileLabel->setText(tr("---"));
        
        // üõë CRITICAL FIX: Button zur√ºck auf "Start" setzen
        if (scanSelectedBtn) {
            scanSelectedBtn->setText(tr("üîç Ausgew√§hlte scannen"));
            scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
        }
        
        qDebug() << "[MainWindow] ‚úÖ Scan gestoppt - GUI zur√ºckgesetzt";
    } else {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Scan kann nicht gestoppt werden - nicht aktiv";
        statusBar()->showMessage(tr("‚ö†Ô∏è Kein aktiver Scan"), 2000);
    }
}

void MainWindow::initializeBackgroundServices()
{
    if (m_networkScanner)
    {
        QTimer::singleShot(2000, this, &MainWindow::startNetworkDiscovery);
    }
}

void MainWindow::loadSettings()
{
    QSettings settings;

    restoreGeometry(settings.value("Window/Geometry").toByteArray());
    restoreState(settings.value("Window/State").toByteArray());

    // Entfernt: Automatisches Laden der gespeicherten Verzeichnisse
    // QStringList dirs = settings.value("Directories/Recent").toStringList();
    // if (!dirs.isEmpty())
    // {
    //     m_selectedDirectories = dirs;
    //     updateDirectoryTree();
    // }

    hashComboBox->setCurrentText(settings.value("Settings/HashAlgorithm", "MD5 (Fast)").toString());
    hardwareComboBox->setCurrentText(settings.value("Settings/HardwareMode", "Auto Detect").toString());
    
    // üé® THEME LOADING: Restore saved theme
    QString savedTheme = loadThemeFromSettings();
    applyTheme(savedTheme);
    
    // Set ComboBox to match loaded theme
    QStringList themeNames = {
        "System Default", "Light High Contrast", "Dark Blue", "Dark Green",
        "Dark Purple", "Dark Red/Orange", "Ice Blue", "Forest Green",
        "High Contrast BW", "Sakura Pink"
    };
    int themeIndex = themeNames.indexOf(savedTheme);
    if (themeIndex >= 0) {
        themeComboBox->setCurrentIndex(themeIndex);
    }
}

void MainWindow::saveSettings()
{
    // ‚úÖ CRASH PREVENTION: Sichere Settings-Speicherung
    qDebug() << "[MainWindow] üíæ saveSettings() gestartet...";
    
    try {
        QSettings settings;

        // ‚úÖ Window-Einstellungen sicher speichern
        if (this && !this->isHidden()) {
            settings.setValue("Window/Geometry", saveGeometry());
            settings.setValue("Window/State", saveState());
            qDebug() << "[MainWindow] ‚úÖ Window-Settings gespeichert";
        }

        // ‚úÖ Directory-Liste sicher speichern
        settings.setValue("Directories/Recent", m_selectedDirectories);
        qDebug() << "[MainWindow] ‚úÖ Directory-Settings gespeichert:" << m_selectedDirectories.size();

        // ‚úÖ UI-Settings sicher speichern (mit Null-Checks)
        if (hashComboBox) {
            settings.setValue("Settings/HashAlgorithm", hashComboBox->currentText());
            qDebug() << "[MainWindow] ‚úÖ Hash-Algorithm gespeichert";
        }
        
        if (hardwareComboBox) {
            settings.setValue("Settings/HardwareMode", hardwareComboBox->currentText());
            qDebug() << "[MainWindow] ‚úÖ Hardware-Mode gespeichert";
        }
        
        if (themeComboBox) {
            settings.setValue("Settings/Theme", themeComboBox->currentIndex());
            qDebug() << "[MainWindow] ‚úÖ Theme gespeichert";
        }
        
        qDebug() << "[MainWindow] ‚úÖ saveSettings() erfolgreich abgeschlossen";
        
    } catch (const std::exception& e) {
        qDebug() << "[MainWindow] ‚ùå Exception in saveSettings:" << e.what();
    } catch (...) {
        qDebug() << "[MainWindow] ‚ùå Unknown exception in saveSettings";
    }
}

void MainWindow::addDirectory()
{
    // üå≥ VERBESSERTER DIALOG: Mit Unterverzeichnis-Auswahl
    QDialog *dialog = new QDialog(this);
    dialog->setWindowTitle(tr("Verzeichnis mit Unterverzeichnissen ausw√§hlen"));
    dialog->resize(700, 500);
    
    QVBoxLayout *layout = new QVBoxLayout(dialog);
    
    // Erkl√§rungstext
    QLabel *infoLabel = new QLabel(tr("‚úÖ Beim Anklicken eines Verzeichnisses werden automatisch alle Unterverzeichnisse mit ausgew√§hlt."), dialog);
    infoLabel->setWordWrap(true);
    layout->addWidget(infoLabel);
    
    // Tree Widget f√ºr Verzeichnisstruktur
    QTreeWidget *dirTree = new QTreeWidget(dialog);
    dirTree->setHeaderLabel(tr("Verzeichnisstruktur"));
    dirTree->setSelectionMode(QAbstractItemView::NoSelection); // Keine Standard-Selection, nur Checkboxen
    layout->addWidget(dirTree);
    
    // Start-Verzeichnis ausw√§hlen
    QPushButton *selectRootBtn = new QPushButton(tr("üìÅ Basis-Verzeichnis w√§hlen..."), dialog);
    layout->addWidget(selectRootBtn);
    
    // Buttons
    QDialogButtonBox *buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, dialog);
    layout->addWidget(buttonBox);
    
    QString selectedRoot;
    
    // Funktion: Alle Unterverzeichnisse rekursiv ausw√§hlen
    auto checkAllChildren = [](QTreeWidgetItem *item, Qt::CheckState state) {
        std::function<void(QTreeWidgetItem*, Qt::CheckState)> checkRecursive;
        checkRecursive = [&checkRecursive](QTreeWidgetItem *current, Qt::CheckState newState) {
            current->setCheckState(0, newState);
            for (int i = 0; i < current->childCount(); ++i) {
                checkRecursive(current->child(i), newState);
            }
        };
        checkRecursive(item, state);
    };
    
    // Funktion: Verzeichnisbaum aufbauen
    auto buildTree = [&](const QString &rootPath) {
        dirTree->clear();
        QTreeWidgetItem *rootItem = new QTreeWidgetItem(dirTree);
        rootItem->setText(0, rootPath);
        rootItem->setData(0, Qt::UserRole, rootPath);
        rootItem->setCheckState(0, Qt::Unchecked);
        rootItem->setFlags(rootItem->flags() | Qt::ItemIsUserCheckable);
        
        // Rekursiv Unterverzeichnisse hinzuf√ºgen (max 3 Ebenen f√ºr Performance)
        std::function<void(QTreeWidgetItem*, const QString&, int)> addSubDirs;
        addSubDirs = [&](QTreeWidgetItem *parent, const QString &path, int depth) {
            if (depth > 3) return; // Max 3 Ebenen
            
            QDir dir(path);
            QStringList subDirs = dir.entryList(QDir::Dirs | QDir::NoDotAndDotDot, QDir::Name);
            
            for (const QString &subDir : subDirs) {
                QString fullPath = dir.absoluteFilePath(subDir);
                QTreeWidgetItem *item = new QTreeWidgetItem(parent);
                item->setText(0, subDir);
                item->setData(0, Qt::UserRole, fullPath);
                item->setCheckState(0, Qt::Unchecked);
                item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
                
                // Rekursiv weitere Unterverzeichnisse
                addSubDirs(item, fullPath, depth + 1);
            }
        };
        
        addSubDirs(rootItem, rootPath, 1);
        dirTree->expandAll();
    };
    
    // Basis-Verzeichnis ausw√§hlen
    connect(selectRootBtn, &QPushButton::clicked, [&]() {
        QString dir = QFileDialog::getExistingDirectory(
            dialog, 
            tr("Basis-Verzeichnis ausw√§hlen"),
            QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
            QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
        );
        
        if (!dir.isEmpty()) {
            selectedRoot = dir;
            buildTree(dir);
        }
    });
    
    // ‚úÖ AUTO-SELECT CHILDREN: Wenn Item angeklickt, alle Kinder auch anklicken
    connect(dirTree, &QTreeWidget::itemChanged, [&](QTreeWidgetItem *item, int column) {
        if (column == 0) {
            Qt::CheckState state = item->checkState(0);
            checkAllChildren(item, state);
        }
    });
    
    connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
    
    if (dialog->exec() == QDialog::Accepted && !selectedRoot.isEmpty()) {
        // Sammle alle ausgew√§hlten Verzeichnisse
        QStringList selectedDirs;
        
        std::function<void(QTreeWidgetItem*)> collectChecked;
        collectChecked = [&](QTreeWidgetItem *item) {
            if (item->checkState(0) == Qt::Checked) {
                QString path = item->data(0, Qt::UserRole).toString();
                if (!path.isEmpty() && !selectedDirs.contains(path)) {
                    selectedDirs.append(path);
                }
            }
            for (int i = 0; i < item->childCount(); ++i) {
                collectChecked(item->child(i));
            }
        };
        
        for (int i = 0; i < dirTree->topLevelItemCount(); ++i) {
            collectChecked(dirTree->topLevelItem(i));
        }
        
        // F√ºge ausgew√§hlte Verzeichnisse hinzu
        int addedCount = 0;
        for (const QString &dir : selectedDirs) {
            if (!m_selectedDirectories.contains(dir)) {
                m_selectedDirectories.append(dir);
                addedCount++;
            }
        }
        
        if (addedCount > 0) {
            qDebug() << "[MainWindow] ÔøΩ" << addedCount << "Verzeichnisse hinzugef√ºgt (inkl. Unterverzeichnisse)";
            updateDirectorySummary();
            saveSettings();
            statusBar()->showMessage(tr("üìÅ %1 neue Verzeichnisse hinzugef√ºgt (gesamt: %2)").arg(addedCount).arg(m_selectedDirectories.size()), 5000);
        } else {
            statusBar()->showMessage(tr("‚ö†Ô∏è Keine neuen Verzeichnisse ausgew√§hlt"), 3000);
        }
    }
    
    delete dialog;
}

void MainWindow::updateDirectoryTree()
{
    qDebug() << "[MainWindow] üìä updateDirectoryTree: Zeige" << m_selectedDirectories.size() << "Verzeichnisse";
    
    // ‚úÖ NEUES DESIGN: Verwende directorySummaryLabel statt directoryTree
    QLabel *directorySummaryLabel = findChild<QLabel*>("directorySummaryLabel");
    if (!directorySummaryLabel) {
        qWarning() << "[MainWindow] ‚ö†Ô∏è directorySummaryLabel nicht gefunden - √ºberspringe Update";
        return;
    }
    
    // ‚úÖ Aktualisiere Summary Label
    if (m_selectedDirectories.isEmpty()) {
        directorySummaryLabel->setText(tr("üìÅ Keine Verzeichnisse ausgew√§hlt"));
    } else {
        QString summaryText = tr("üìÅ %1 Verzeichnisse ausgew√§hlt:\n").arg(m_selectedDirectories.size());
        for (int i = 0; i < m_selectedDirectories.size() && i < 8; ++i) {
            summaryText += QString("‚Ä¢ %1\n").arg(m_selectedDirectories[i]);
        }
        if (m_selectedDirectories.size() > 8) {
            summaryText += QString("... und %1 weitere").arg(m_selectedDirectories.size() - 8);
        }
        directorySummaryLabel->setText(summaryText);
    }
    
    // ‚úÖ SICHERES Status-Update
    if (statusBar()) {
        statusBar()->showMessage(tr("üìÅ %1 Verzeichnisse aktiv").arg(m_selectedDirectories.size()), 3000);
    }
}

void MainWindow::updateDirectorySummary()
{
    // ‚úÖ Aktualisiere Summary-Label mit ausgew√§hlten Verzeichnissen
    QLabel *summaryLabel = findChild<QLabel*>("directorySummaryLabel");
    if (!summaryLabel) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è directorySummaryLabel nicht gefunden!";
        return;
    }
    
    QString summaryText;
    
    if (m_selectedDirectories.isEmpty()) {
        summaryText = tr("üìÅ Keine Verzeichnisse ausgew√§hlt\n\n"
                        "Klicken Sie auf '‚ûï Verzeichnis hinzuf√ºgen', um Ordner f√ºr den "
                        "Duplikat-Scan auszuw√§hlen.");
    } else {
        summaryText = tr("üìÅ %1 Verzeichnisse ausgew√§hlt:\n\n").arg(m_selectedDirectories.size());
        
        for (int i = 0; i < m_selectedDirectories.size() && i < 10; ++i) {
            QString dir = m_selectedDirectories.at(i);
            // K√ºrze sehr lange Pfade
            if (dir.length() > 50) {
                dir = "..." + dir.right(47);
            }
            summaryText += tr("‚Ä¢ %1\n").arg(dir);
        }
        
        if (m_selectedDirectories.size() > 10) {
            summaryText += tr("‚Ä¢ ... und %1 weitere Verzeichnisse\n").arg(m_selectedDirectories.size() - 10);
        }
        
        summaryText += tr("\nüîç Klicken Sie auf 'Duplikate suchen', um den Scan zu starten.");
    }
    
    summaryLabel->setText(summaryText);
    
    qDebug() << "[MainWindow] ‚úÖ Directory Summary aktualisiert:" << m_selectedDirectories.size() << "Verzeichnisse";
}

void MainWindow::updateSelectedDirectoriesDisplay()
{
    // ‚úÖ SICHERE GUI-AKTUALISIERUNG ohne Tree-Manipulation
    qDebug() << "[MainWindow] üîÑ Aktualisiere Selected Directories Display...";
    
    // Update directory summary
    updateDirectorySummary();
    
    // Update network tree to show selected directories (if it exists and is safe)
    QTreeWidget *networkTree = findChild<QTreeWidget*>("networkTree");
    if (networkTree) {
        // Markiere ausgew√§hlte FTP-Pfade visuell (ohne Crash-Risk)
        for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {
            QTreeWidgetItem *item = networkTree->topLevelItem(i);
            updateItemSelectionState(item);
        }
    }
    
    // Update status
    if (!m_selectedDirectories.isEmpty()) {
        statusBar()->showMessage(tr("üìÅ %1 Verzeichnisse ausgew√§hlt (bereit f√ºr Duplikat-Scan)")
                               .arg(m_selectedDirectories.size()), 2000);
    }
    
    qDebug() << "[MainWindow] ‚úÖ Selected Directories Display aktualisiert:" << m_selectedDirectories.size() << "Eintr√§ge";
}

void MainWindow::updateItemSelectionState(QTreeWidgetItem *item)
{
    if (!item) return;
    
    // Pr√ºfe, ob dieser Pfad in den ausgew√§hlten Verzeichnissen ist
    QString itemPath = item->data(0, Qt::UserRole).toString();
    bool isSelected = false;
    
    for (const QString &selectedDir : m_selectedDirectories) {
        if (selectedDir.contains(itemPath) || itemPath.contains(selectedDir)) {
            isSelected = true;
            break;
        }
    }
    
    // Visuelles Feedback: Ausgew√§hlte Elemente hervorheben
    if (isSelected) {
        QFont font = item->font(0);
        font.setBold(true);
        item->setFont(0, font);
        item->setBackground(0, QColor(144, 238, 144, 100)); // Light green background
        item->setIcon(0, QIcon(":/assets/icons/folder-selected.svg"));
    }
    
    // Rekursiv f√ºr Kinder
    for (int i = 0; i < item->childCount(); ++i) {
        updateItemSelectionState(item->child(i));
    }
}

void MainWindow::removeSelectedDirectories()
{
    // ‚úÖ Dialog-basierte Verzeichnis-Entfernung
    if (m_selectedDirectories.isEmpty()) {
        QMessageBox::information(this, tr("Keine Verzeichnisse"), 
                               tr("Es sind keine Verzeichnisse zum Entfernen ausgew√§hlt."));
        return;
    }
    
    // Zeige aktuell ausgew√§hlte Verzeichnisse zum Entfernen
    DirectorySelectorDialog dialog(this);
    dialog.setWindowTitle(tr("üóëÔ∏è Verzeichnisse entfernen"));
    dialog.setSelectedDirectories(m_selectedDirectories);
    
    if (dialog.exec() == QDialog::Accepted) {
        QStringList remainingDirs = dialog.getSelectedDirectories();
        m_selectedDirectories = remainingDirs;
        updateDirectorySummary();
        saveSettings();
        
        statusBar()->showMessage(tr("üìÅ Verzeichnisse aktualisiert: %1 verbleibend").arg(remainingDirs.size()), 3000);
    }
}

void MainWindow::showDirectoryContextMenu(const QPoint &pos)
{
    // ‚úÖ NEUES DESIGN: Context Menu f√ºr directorySummaryLabel
    QLabel *directorySummaryLabel = findChild<QLabel*>("directorySummaryLabel");
    if (!directorySummaryLabel) {
        qWarning() << "[MainWindow] ‚ö†Ô∏è directorySummaryLabel nicht gefunden";
        return;
    }

    QMenu contextMenu(this);

    // ‚úÖ Deutsche Labels und Icons f√ºr bessere UX
    QAction *scanAction = contextMenu.addAction(tr("üîç Alle Verzeichnisse scannen"));
    QAction *clearAction = contextMenu.addAction(tr("üóëÔ∏è Alle Pfade entfernen"));
    contextMenu.addSeparator();
    QAction *addAction = contextMenu.addAction(tr("‚ûï Verzeichnisse hinzuf√ºgen"));

    QAction *selectedAction = contextMenu.exec(directorySummaryLabel->mapToGlobal(pos));

    if (selectedAction == scanAction)
    {
        if (!m_selectedDirectories.isEmpty()) {
            startDuplicateScan();
        }
    }
    else if (selectedAction == clearAction)
    {
        m_selectedDirectories.clear();
        updateDirectoryTree();
    }
    else if (selectedAction == addAction)
    {
        addDirectory();
    }
}

// ‚úÖ Context Menu f√ºr Directory Summary Label mit Pfad-Entfernung
void MainWindow::showDirectorySummaryContextMenu(const QPoint &pos)
{
    if (m_selectedDirectories.isEmpty()) {
        return; // Kein Menu, wenn keine Verzeichnisse ausgew√§hlt
    }

    QMenu contextMenu(this);
    
    // ‚úÖ Liste aller ausgew√§hlten Verzeichnisse zum Entfernen
    contextMenu.addSection("üóëÔ∏è Pfad entfernen:");
    
    for (int i = 0; i < m_selectedDirectories.size(); ++i) {
        QString dirPath = m_selectedDirectories.at(i);
        
        // K√ºrze sehr lange Pfade f√ºr das Menu
        QString displayPath = dirPath;
        if (displayPath.length() > 50) {
            displayPath = "..." + displayPath.right(47);
        }
        
        QAction *removeAction = contextMenu.addAction(QString("üóëÔ∏è %1").arg(displayPath));
        removeAction->setData(i); // Index speichern f√ºr Entfernung
    }
    
    contextMenu.addSeparator();
    QAction *clearAllAction = contextMenu.addAction("üßπ Alle Pfade entfernen");
    
    // Context Menu anzeigen
    QAction *selectedAction = contextMenu.exec(mapToGlobal(pos));
    
    if (selectedAction == clearAllAction) {
        // Alle Pfade entfernen
        m_selectedDirectories.clear();
        updateDirectorySummary();
        statusBar()->showMessage("üßπ Alle Pfade entfernt", 2000);
        qDebug() << "[MainWindow] üßπ Alle Verzeichnisse entfernt";
    }
    else if (selectedAction && selectedAction->data().isValid()) {
        // Einzelnen Pfad entfernen
        int index = selectedAction->data().toInt();
        if (index >= 0 && index < m_selectedDirectories.size()) {
            QString removedPath = m_selectedDirectories.takeAt(index);
            updateDirectorySummary();
            statusBar()->showMessage(QString("üóëÔ∏è Pfad entfernt: %1").arg(QFileInfo(removedPath).baseName()), 3000);
            qDebug() << "[MainWindow] üóëÔ∏è Pfad entfernt:" << removedPath;
        }
    }
}

void MainWindow::showNetworkContextMenu(const QPoint &pos)
{
    QTreeWidgetItem *item = networkTree->itemAt(pos);
    if (!item)
        return;

    QMenu contextMenu(this);

    // Different actions based on item type
    if (item->parent()) {
        // This is a directory item under an FTP service
        QAction *addToScannerAction = contextMenu.addAction(tr("‚ûï Zu Scanner hinzuf√ºgen"));
        QAction *removeFromScannerAction = contextMenu.addAction(tr("‚ûñ Aus Scanner entfernen"));
        contextMenu.addSeparator();
        QAction *scanDirectlyAction = contextMenu.addAction(tr("üöÄ Sofort scannen"));
        
        QAction *selectedAction = contextMenu.exec(networkTree->mapToGlobal(pos));
        
        if (selectedAction == addToScannerAction) {
            // Add FTP directory to scanner list
            QString ftpPath = item->data(0, Qt::UserRole).toString();
            if (!ftpPath.isEmpty()) {
                addFtpDirectoryToScanner(item);
            }
        } else if (selectedAction == scanDirectlyAction) {
            // Start scan immediately with this FTP directory
            addFtpDirectoryToScanner(item);
            startDuplicateScan();
        }
    } else {
        // This is a service item (FTP server)
        // ‚úÖ AUTO-BROWSE aktiviert - manuelle Verbindung nur f√ºr Refresh
        QAction *refreshAction = contextMenu.addAction(tr("üîÑ Aktualisieren"));
        
        QAction *selectedAction = contextMenu.exec(networkTree->mapToGlobal(pos));
        
        if (selectedAction == refreshAction) {
            // Re-connect and refresh (works for both initial and re-connection)
            onNetworkServiceDoubleClicked(item, 0);
        }
    }
}

void MainWindow::addFtpDirectoryToScanner(QTreeWidgetItem *ftpDirItem)
{
    if (!ftpDirItem) return;
    
    QString ftpPath = ftpDirItem->data(0, Qt::UserRole).toString();
    if (ftpPath.isEmpty()) return;
    
    // Get the FTP server info from parent
    QTreeWidgetItem *parentItem = ftpDirItem->parent();
    if (!parentItem) return;
    
    // Extract IP and port from parent item
    QString serverInfo = parentItem->text(0);
    QString ip = serverInfo.split(':').first();
    
    // ‚úÖ CRITICAL FIX: Ensure ftpPath starts with /
    if (!ftpPath.startsWith('/')) {
        ftpPath = "/" + ftpPath;
    }
    
    // Create a special FTP path identifier for the scanner
    QString scannerPath = QString("ftp://%1%2").arg(ip, ftpPath);
    
    if (!m_selectedDirectories.contains(scannerPath)) {
        m_selectedDirectories.append(scannerPath);
        // Neue GUI: aktualisiere Summary statt directoryTree zu verwenden
        updateDirectorySummary();
        qDebug() << "[MainWindow] ‚ûï FTP-Verzeichnis zum Scanner hinzugef√ºgt:" << scannerPath;
        statusBar()->showMessage(tr("FTP-Verzeichnis %1 zum Scanner hinzugef√ºgt").arg(ftpPath), 3000);
    } else {
        statusBar()->showMessage(tr("FTP-Verzeichnis %1 bereits im Scanner").arg(ftpPath), 3000);
    }
}

void MainWindow::onNetworkTreeItemChanged(QTreeWidgetItem *item, int column)
{
    if (!item || column != 0) return;  // Nur Spalte 0 (Checkbox-Spalte)
    
    // üîí Verhindere Rekursion w√§hrend wir Kinder/Eltern aktualisieren
    static bool isUpdating = false;
    if (isUpdating) return;
    isUpdating = true;
    
    Qt::CheckState currentState = item->checkState(0);
    qDebug() << "[MainWindow] üîò Checkbox ge√§ndert:" << item->text(0) << "‚Üí" << (currentState == Qt::Checked ? "CHECKED" : "UNCHECKED");
    
    // üå≥ REKURSIVE CHILD-UPDATE: Wenn Parent gechecked/unchecked ‚Üí ALLE Unterverzeichnisse gleich setzen
    std::function<void(QTreeWidgetItem*, Qt::CheckState)> updateChildrenRecursive;
    updateChildrenRecursive = [&](QTreeWidgetItem *parentItem, Qt::CheckState state) {
        for (int i = 0; i < parentItem->childCount(); ++i) {
            QTreeWidgetItem *child = parentItem->child(i);
            if (child->flags() & Qt::ItemIsUserCheckable) {
                child->setCheckState(0, state);
                qDebug() << "[MainWindow]   ‚Ü≥ Unterverzeichnis aktualisiert:" << child->text(0) << "‚Üí" << (state == Qt::Checked ? "CHECKED" : "UNCHECKED");
                
                // üîÑ REKURSIV: Update auch die Kinder dieses Kindes
                if (child->childCount() > 0) {
                    updateChildrenRecursive(child, state);
                }
            }
        }
    };
    
    // Starte rekursives Update aller Unterverzeichnisse
    if (item->childCount() > 0) {
        updateChildrenRecursive(item, currentState);
    }
    
    // üîº PARENT-UPDATE: Wenn alle Geschwister checked ‚Üí Parent checked, wenn keiner ‚Üí Parent unchecked
    QTreeWidgetItem *parent = item->parent();
    if (parent && (parent->flags() & Qt::ItemIsUserCheckable)) {
        int checkedCount = 0;
        int totalChildren = parent->childCount();
        
        for (int i = 0; i < totalChildren; ++i) {
            if (parent->child(i)->checkState(0) == Qt::Checked) {
                checkedCount++;
            }
        }
        
        if (checkedCount == totalChildren) {
            parent->setCheckState(0, Qt::Checked);
            qDebug() << "[MainWindow]   ‚Üë Parent CHECKED:" << parent->text(0);
        } else if (checkedCount == 0) {
            parent->setCheckState(0, Qt::Unchecked);
            qDebug() << "[MainWindow]   ‚Üë Parent UNCHECKED:" << parent->text(0);
        } else {
            parent->setCheckState(0, Qt::PartiallyChecked);
            qDebug() << "[MainWindow]   ‚Üë Parent PARTIALLY:" << parent->text(0) << "(" << checkedCount << "/" << totalChildren << ")";
        }
    }
    
    // üìä DATEI-ANZAHL UPDATE: Berechne Anzahl der ausgew√§hlten Dateien
    updateNetworkTreeFileCounts();
    
    // ‚úÖ Scanner-Liste aktualisieren
    collectSelectedNetworkDirectories();
    
    isUpdating = false;
}

void MainWindow::updateNetworkTreeFileCounts()
{
    // TODO: Implementiere Datei-Anzahl Berechnung f√ºr FTP-Verzeichnisse
    // Dies w√ºrde FTP LIST -R Kommandos erfordern f√ºr echte Counts
    qDebug() << "[MainWindow] üìä updateNetworkTreeFileCounts() - TODO: FTP file counts";
}

void MainWindow::collectSelectedNetworkDirectories()
{
    qDebug() << "[MainWindow] üìÇ collectSelectedNetworkDirectories() gestartet";
    qDebug() << "[MainWindow] üîç networkTree topLevelItemCount:" << (networkTree ? networkTree->topLevelItemCount() : -1);
    
    // L√∂sche alte Auswahl (nur FTP-Pfade)
    m_selectedDirectories.erase(
        std::remove_if(m_selectedDirectories.begin(), m_selectedDirectories.end(),
            [](const QString &path) { return path.startsWith("ftp://"); }),
        m_selectedDirectories.end()
    );
    
    // üîç Durchsuche Network Tree und sammle alle CHECKED Items
    QTreeWidgetItemIterator it(networkTree, QTreeWidgetItemIterator::Checked);
    int addedCount = 0;
    int totalChecked = 0;
    
    // Z√§hle erstmal ALLE gecheckte Items
    QTreeWidgetItemIterator countIt(networkTree, QTreeWidgetItemIterator::Checked);
    while (*countIt) {
        totalChecked++;
        qDebug() << "[MainWindow] üîç Gecheckt:" << (*countIt)->text(0) 
                 << "Parent:" << ((*countIt)->parent() ? (*countIt)->parent()->text(0) : "NONE")
                 << "UserRole:" << (*countIt)->data(0, Qt::UserRole).toString();
        ++countIt;
    }
    qDebug() << "[MainWindow] üìä Total gecheckte Items:" << totalChecked;
    
    while (*it) {
        QTreeWidgetItem *item = *it;
        
        // Nur FTP-Verzeichnisse (haben Parent und UserRole-Daten)
        if (item->parent() && !item->data(0, Qt::UserRole).toString().isEmpty()) {
            QString ftpPath = item->data(0, Qt::UserRole).toString();
            QTreeWidgetItem *parentItem = item->parent();
            QString serverInfo = parentItem->text(0);
            QString ip = serverInfo.split(':').first();
            
            if (!ftpPath.startsWith('/')) {
                ftpPath = "/" + ftpPath;
            }
            
            QString scannerPath = QString("ftp://%1%2").arg(ip, ftpPath);
            
            if (!m_selectedDirectories.contains(scannerPath)) {
                m_selectedDirectories.append(scannerPath);
                addedCount++;
                qDebug() << "[MainWindow]   ‚úÖ Hinzugef√ºgt:" << scannerPath;
            }
        }
        
        ++it;
    }
    
    qDebug() << "[MainWindow] üìÇ Gesamt ausgew√§hlte FTP-Verzeichnisse:" << addedCount;
    
    // GUI aktualisieren
    updateDirectorySummary();
    updateSelectedDirectoriesDisplay();
    
    if (addedCount > 0) {
        statusBar()->showMessage(tr("‚úÖ %1 FTP-Verzeichnisse ausgew√§hlt").arg(addedCount), 3000);
    }
}

void MainWindow::addNetworkService(const QString &ip, int port, const QString &service)
{
    qDebug() << "[MainWindow] üîç addNetworkService() GESTARTET - ip:" << ip << "port:" << port << "service:" << service;
    qDebug() << "[MainWindow] üîç networkTree ist:" << (networkTree ? "VALID" : "INVALID");
    qDebug() << "[MainWindow] üîç networkTree topLevelItemCount:" << (networkTree ? networkTree->topLevelItemCount() : -1);
    
    if (!networkTree) {
        qDebug() << "[MainWindow] ‚ùå FEHLER: networkTree ist null!";
        return;
    }
    // üõ°Ô∏è DUPLIKAT-SCHUTZ: Pr√ºfe ob Service bereits existiert
    QString serviceKey = QString("%1:%2").arg(ip).arg(port);
    
    // Durchsuche alle existierenden Services
    QTreeWidgetItemIterator it(networkTree);
    while (*it) {
        QString existingIp = (*it)->data(0, Qt::UserRole).toString();
        int existingPort = (*it)->data(0, Qt::UserRole + 1).toInt();
        
        if (existingIp == ip && existingPort == port) {
            qDebug() << "[MainWindow] ‚ö†Ô∏è Service bereits vorhanden, √ºberspringe:" << serviceKey;
            return; // Service existiert bereits
        }
        ++it;
    }
    
    qDebug() << "[MainWindow] üì° Network Service hinzugef√ºgt:" << ip << port << service;
    
    // üß† INTELLIGENTE SERVICE-KATEGORISIERUNG
    QString category = categorizeIntelligentService(service, port);
    QString priority = calculateServicePriority(service, port, ip);
    QString icon = getServiceIcon(service, port);
    QString authStatus = getAuthenticationStatus(ip, port);
    
    // üèóÔ∏è INTELLIGENTE HIERARCHIE-ERSTELLUNG
    QTreeWidgetItem *categoryItem = findOrCreateCategory(category);
    QTreeWidgetItem *serverItem = findOrCreateServer(categoryItem, ip);
    
    // üéØ SERVICE-ITEM MIT ERWEITERTEN METADATEN
    QTreeWidgetItem *serviceItem = new QTreeWidgetItem(serverItem);
    serviceItem->setText(0, QString("%1 %2:%3").arg(icon, ip).arg(port));
    serviceItem->setText(1, service);
    serviceItem->setText(2, authStatus);
    serviceItem->setText(3, "üü¢ Aktiv");
    serviceItem->setText(4, priority);
    
    // üè∑Ô∏è METADATEN F√úR INTELLIGENTE SORTIERUNG
    serviceItem->setData(0, Qt::UserRole, ip);
    serviceItem->setData(0, Qt::UserRole + 1, port);
    serviceItem->setData(0, Qt::UserRole + 2, service);
    serviceItem->setData(0, Qt::UserRole + 3, getPriorityScore(service, port));
    serviceItem->setData(0, Qt::UserRole + 4, QDateTime::currentDateTime());
    
    // üé® DYNAMISCHE STYLING BASIEREND AUF SERVICE-TYP
    applyIntelligentServiceStyling(serviceItem, service, port);
    
    // üìä STATISTICS UPDATE
    updateNetworkStatistics();
    
    // üìÇ AUTO-EXPANSION F√úR HOHE PRIORIT√ÑT & FTP-SERVICES
    if (getPriorityScore(service, port) >= 8) {
        categoryItem->setExpanded(true);
        serverItem->setExpanded(true);
    }
    
    // üå≥ AUTO-EXPANSION f√ºr FTP-Services (nur Tree erweitern, keine Verbindung)
    if (port == 21 || service.toLower().contains("ftp")) {
        qDebug() << "[MainWindow] üå≥ FTP Service erkannt - erweitere Tree-Struktur automatisch";
        categoryItem->setExpanded(true);
        serverItem->setExpanded(true);
        serviceItem->setExpanded(true); // FTP-Item auch aufklappen
    }
    
    // üîÑ SOFORTIGE GUI-AKTUALISIERUNG ERZWINGEN
    networkTree->update();
    networkTree->repaint();
    // REMOVED: QApplication::processEvents(); // Sofortige Verarbeitung der GUI-Events
    
    qDebug() << "[MainWindow] ‚úÖ GUI-Update erzwungen f√ºr Service:" << ip << port << service;
}

void MainWindow::startNetworkDiscovery()
{
    // ‚úÖ FIX: NIEMALS clear() aufrufen - nur neue Services hinzuf√ºgen
    // networkTree->clear();  // ‚ùå DEAKTIVIERT - l√∂scht gefundene IPs
    
    statusBar()->showMessage(tr("üöÄ Starting 30-Chunk Network Discovery..."));

    if (m_networkScanner)
    {
        // Always perform multi-range scan to include all preset ranges
        QList<NetworkRange> ranges = m_networkScanner->getAvailableNetworkRanges();
        int customRangeCount = 0;
        int autoRangeCount = 0;
        
        for (const NetworkRange &range : ranges) {
            if (!range.isAutoDetected) {
                customRangeCount++;
                std::cout << "[MainWindow] ÔøΩ Custom Preset Range: " << range.name.toUtf8().constData() 
                          << " (" << range.cidr.toUtf8().constData() << ")" << std::endl;
            } else {
                autoRangeCount++;
            }
        }
        
        // Always use Multi-Range-Scan to ensure all preset ranges are scanned
        std::cout << "[MainWindow] üåê Auto-Scanning ALL ranges: " << customRangeCount 
                  << " Custom Presets + " << autoRangeCount << " Auto-Detected" << std::endl;
        m_networkScanner->scanAllAvailableRanges();
    }
}

void MainWindow::startMultiRangeScan()
{
    // ‚úÖ FIX: NIEMALS clear() aufrufen - nur neue Services hinzuf√ºgen
    // networkTree->clear();  // ‚ùå DEAKTIVIERT - l√∂scht gefundene IPs
    
    statusBar()->showMessage(tr("üåê Starting Multi-Range Network Scan..."));

    if (m_networkScanner)
    {
        m_networkScanner->scanAllAvailableRanges();
    }
}

void MainWindow::onNetworkRangesLoaded(int customRangeCount)
{
    std::cout << "[MainWindow] üåê Network ranges loaded - " << customRangeCount 
              << " custom ranges available" << std::endl;
    
    // Trigger multi-range scan if custom ranges are available
    if (customRangeCount > 0) {
        std::cout << "[MainWindow] üöÄ Starting Multi-Range-Scan for " 
                  << customRangeCount << " custom ranges..." << std::endl;
        
        // Wait a moment for everything to settle, then start scan
        QTimer::singleShot(1000, this, &MainWindow::startMultiRangeScan);
    }
}

void MainWindow::checkAndStartMultiRangeScan()
{
    std::cout << "[MainWindow] üîç checkAndStartMultiRangeScan() called..." << std::endl;
    
    if (!m_networkScanner) {
        std::cout << "[MainWindow] ‚ö†Ô∏è NetworkScanner not available for multi-range check" << std::endl;
        return;
    }
    
    // Check if custom ranges are available
    QList<NetworkRange> ranges = m_networkScanner->getAvailableNetworkRanges();
    int customRangeCount = 0;
    
    std::cout << "[MainWindow] üîç Checking " << ranges.size() << " available network ranges..." << std::endl;
    
    for (const NetworkRange &range : ranges) {
        std::cout << "[MainWindow] üìç Range: " << range.name.toUtf8().constData() 
                  << " (" << range.cidr.toUtf8().constData() << ") Auto: " 
                  << (range.isAutoDetected ? "Yes" : "No") << std::endl;
        
        if (!range.isAutoDetected) {
            customRangeCount++;
        }
    }
    
    if (customRangeCount > 0) {
        std::cout << "[MainWindow] üåê " << customRangeCount 
                  << " Custom Ranges detected - starting Multi-Range-Scan..." << std::endl;
        
        // Wait a bit for the first scan to complete, then start multi-range
        QTimer::singleShot(2000, this, &MainWindow::startMultiRangeScan);
    } else {
        std::cout << "[MainWindow] ‚ÑπÔ∏è No custom ranges configured - using single range scan only" << std::endl;
    }
}

void MainWindow::onScanProgress(int percentage, int current, int total)
{
    qDebug() << "[MainWindow] üìä onScanProgress aufgerufen:" << percentage << "% (" << current << "/" << total << ")";
    std::cout << "[MainWindow] üìä Progress GUI-Update: " << percentage << "% (" << current << "/" << total << ")" << std::endl;
    
    // üõ°Ô∏è CRITICAL NULL-CHECKS: Verhindere GUI-Crashes
    if (!progressBar) {
        qWarning() << "[MainWindow] ‚ùå progressBar ist NULL!";
        std::cout << "[MainWindow] ‚ùå‚ùå‚ùå progressBar ist NULL!" << std::endl;
        return;
    }
    
    if (!actionLabel) {
        qWarning() << "[MainWindow] ‚ùå actionLabel ist NULL!";
        std::cout << "[MainWindow] ‚ùå‚ùå‚ùå actionLabel ist NULL!" << std::endl;
        return;
    }
    
    if (!fileCountLabel) {
        qWarning() << "[MainWindow] ‚ùå fileCountLabel ist NULL!";
        std::cout << "[MainWindow] ‚ùå‚ùå‚ùå fileCountLabel ist NULL!" << std::endl;
        return;
    }
    
    if (total > 0) {
        // üöÄ ECHTZEIT PROGRESS-ANZEIGE: Sofortige Updates ohne Verz√∂gerung
        progressBar->setMaximum(100); // Immer 0-100 f√ºr Prozent
        progressBar->setValue(percentage); // Direkt Prozent setzen
        progressBar->repaint(); // üöÄ FORCE IMMEDIATE REPAINT!
        
        // ‚úÖ FIX: Aktualisiere Action-Label basierend auf Fortschritt
        QString currentAction;
        if (percentage >= 90) {
            currentAction = "üîç Identifiziere Duplikate...";
        } else if (percentage >= 50) {
            currentAction = "üîê Hash-Berechnung l√§uft...";
        } else if (percentage >= 10) {
            currentAction = "üìè Analysiere Dateigr√∂√üen...";
        } else {
            currentAction = "üîç Sammle Dateien...";
        }
        
        // üöÄ ECHTZEIT: Aktualisiere GUI Komponenten sofort
        actionLabel->setText(currentAction);
        actionLabel->repaint(); // üöÄ FORCE REPAINT!
        fileCountLabel->setText(QString("Datei %1 von %2").arg(current).arg(total));
        fileCountLabel->repaint(); // üöÄ FORCE REPAINT!
        
        // üöÄ ECHTZEIT: Status-Bar ohne Timeout f√ºr permanente Anzeige
        statusBar()->showMessage(QString("üîç Hash-Berechnung: %1/%2 (%3%)").arg(current).arg(total).arg(percentage), 0); // 0 = kein Timeout!
        
        // üî• FORCE GUI UPDATE: Erzwinge sofortige Bildschirm-Aktualisierung
        // REMOVED: QCoreApplication::processEvents();
        update();
        repaint();
        
        // Logge nur alle 10% Fortschritt
        static int lastLoggedPercentage = -1;
        if (percentage % 10 == 0 && percentage != lastLoggedPercentage) {
            qDebug() << "[MainWindow] üìä Progress:" << percentage << "% (" << current << "/" << total << ")";
            lastLoggedPercentage = percentage;
        }
    } else {
        // Unbestimmter Progress
        progressBar->setMaximum(0); // Indeterminate progress
        actionLabel->setText("üîç Initialisiere Scan...");
        
        // üî• FORCE GUI UPDATE auch f√ºr unbestimmten Progress
        // REMOVED: QCoreApplication::processEvents();
        update();
        repaint();
        
        std::cout << "[MainWindow] üîÑ Unbestimmter Progress - Initialisierung" << std::endl;
    }
}

void MainWindow::onScanCompleted(const DuplicateGroups &results)
{
    qDebug() << "[MainWindow] ‚úÖ onScanCompleted aufgerufen mit" << results.groups.size() << "Duplikat-Gruppen";
    std::cout << "[MainWindow] ‚úÖ Scan abgeschlossen! Duplikat-Gruppen: " << results.groups.size() << std::endl;
    
    // üî• DEBUG: Zeige alle empfangenen Werte
    qDebug() << "[MainWindow] üî•üî•üî• onScanCompleted EMPFANGEN:";
    qDebug() << "    - results.totalFiles =" << results.totalFiles;
    qDebug() << "    - results.groups.size() =" << results.groups.size();
    qDebug() << "    - results.duplicateFiles =" << results.duplicateFiles;
    qDebug() << "    - results.duplicateSize =" << results.duplicateSize;
    std::cout << "üî•üî•üî• totalFiles=" << results.totalFiles << " groups=" << results.groups.size() << std::endl;
    
    // üî• KRITISCH: Pr√ºfe ob √ºberhaupt Dateien gescannt wurden!
    if (results.totalFiles == 0) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è scanCompleted mit 0 Dateien - Scan wurde nicht ausgef√ºhrt!";
        std::cout << "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PROBLEM: totalFiles == 0!" << std::endl;
        // NICHT "Keine Duplikate gefunden" anzeigen - Scan wurde abgebrochen/nicht gestartet
        if (actionLabel) {
            actionLabel->setText(tr("‚èπÔ∏è Scan nicht ausgef√ºhrt"));
        }
        
        // üõë CRITICAL FIX: Button zur√ºcksetzen auch bei abgebrochenem Scan
        if (scanSelectedBtn) {
            scanSelectedBtn->setText(tr("üîç Ausgew√§hlte scannen"));
            scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
        }
        
        m_isScanning = false;
        return;
    }
    
    // üìä Spezialfall: Scan wurde durchgef√ºhrt aber keine Duplikate gefunden
    if (results.groups.isEmpty() && results.totalFiles > 0) {
        qDebug() << "[MainWindow] ‚ÑπÔ∏è Scan abgeschlossen:" << results.totalFiles << "Dateien gepr√ºft, keine Duplikate";
        qDebug() << "[MainWindow] üîß GUI-Cleanup: actionLabel=" << (actionLabel ? "OK" : "NULL");
        qDebug() << "[MainWindow] üîß GUI-Cleanup: progressBar=" << (progressBar ? "OK" : "NULL");
        qDebug() << "[MainWindow] üîß GUI-Cleanup: scanSelectedBtn=" << (scanSelectedBtn ? "OK" : "NULL");
        
        if (actionLabel) {
            actionLabel->setText(tr("‚úÖ Scan abgeschlossen - Keine Duplikate"));
            qDebug() << "[MainWindow] ‚úÖ actionLabel updated";
        }
        if (progressBar) {
            progressBar->setValue(100);
            qDebug() << "[MainWindow] ‚úÖ progressBar set to 100%";
        }
        
        // üõë CRITICAL FIX: Button zur√ºcksetzen auch bei "keine Duplikate"
        if (scanSelectedBtn) {
            qDebug() << "[MainWindow] üîß Resetting scanSelectedBtn...";
            scanSelectedBtn->setText(tr("üîç Ausgew√§hlte scannen"));
            scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
            qDebug() << "[MainWindow] ‚úÖ scanSelectedBtn RESET to GREEN!";
        }
        
        qDebug() << "[MainWindow] üì¢ Showing QMessageBox...";
        // Zeige Info-Meldung
        QMessageBox::information(this, 
            tr("Scan abgeschlossen"),
            tr("%1 Dateien wurden gepr√ºft.\n\nKeine Duplikate gefunden.").arg(results.totalFiles)
        );
        qDebug() << "[MainWindow] ‚úÖ QMessageBox closed";
        
        m_isScanning = false;
        qDebug() << "[MainWindow] ‚úÖ m_isScanning = false";
        return;
    }
    
    // üéØ NEU: √úbergebe komplette DuplicateGroups Struktur (mit Hash!)
    qDebug() << "[MainWindow] üîÑ Zeige" << results.groups.size() << "Duplikat-Gruppen mit allen Infos";
    displayResultsGrouped(results);
    m_isScanning = false;
    
    // üîÑ KRITISCH: Button zur√ºcksetzen nach Scan
    if (scanSelectedBtn) {
        scanSelectedBtn->setText(tr("üîç Ausgew√§hlte scannen"));
        scanSelectedBtn->setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;");
    }
    
    // ‚úÖ ERWEITERTE PROGRESS-FERTIGSTELLUNG mit speziellem Text f√ºr "keine Duplikate"
    progressBar->setValue(progressBar->maximum()); // 100%
    
    if (results.groups.isEmpty()) {
        // üî• KRITISCH: Unterscheide zwischen "keine Duplikate" und "Scan abgebrochen"
        if (results.totalFiles > 0) {
            // ‚úÖ Scan wurde ausgef√ºhrt, aber keine Duplikate gefunden
            actionLabel->setText(tr("‚úÖ Keine Duplikate gefunden!"));
            if (currentFileLabel) currentFileLabel->setText(tr("Alle Dateien sind einzigartig üéâ"));
            statusBar()->showMessage(tr("‚úÖ Scan abgeschlossen - Keine Duplikate gefunden! Alle Dateien sind einzigartig."), 8000);
        } else {
            // ‚èπÔ∏è Scan wurde abgebrochen (z.B. stopScan() aufgerufen)
            actionLabel->setText(tr("‚èπÔ∏è Scan abgebrochen"));
            if (currentFileLabel) currentFileLabel->setText(tr("Scan wurde gestoppt"));
            statusBar()->showMessage(tr("‚èπÔ∏è Scan wurde abgebrochen"), 3000);
        }
    } else {
        // Normale Anzeige wenn Duplikate gefunden wurden
        actionLabel->setText(tr("‚úÖ Scan abgeschlossen"));
        if (currentFileLabel) currentFileLabel->setText(tr("%1 Duplikatgruppen gefunden").arg(results.groups.size()));
        statusBar()->showMessage(tr("Scan abgeschlossen. %1 Duplikatgruppen gefunden.").arg(results.groups.size()), 5000);
        
        // üîî MessageBox: Duplikate gefunden!
        QString message = tr("‚úÖ Scan abgeschlossen!\n\n"
                           "üìä Gescannte Dateien: %1\n"
                           "üìÇ Duplikat-Gruppen: %2\n"
                           "üìÑ Duplikate gefunden: %3\n"
                           "üíæ Potentiell freizugebender Speicher: %4 MB")
            .arg(results.totalFiles)
            .arg(results.groups.size())
            .arg(results.duplicateFiles)
            .arg(QString::number(results.duplicateSize / (1024.0 * 1024.0), 'f', 2));
        
        QMessageBox::information(this, tr("üéâ Duplikate gefunden!"), message);
    }
    
    std::cout << "[MainWindow] üéâ GUI erfolgreich aktualisiert - " << results.groups.size() << " Gruppen angezeigt" << std::endl;
}

void MainWindow::onFilesCollected(int totalFiles)
{
    // üõ°Ô∏è CRITICAL: Ignore repeated calls - nur EINMAL verarbeiten!
    if (m_filesCollectedHandled) {
        qDebug() << "[MainWindow] ‚è≠Ô∏è onFilesCollected bereits verarbeitet, ignoriere Aufruf";
        return;
    }
    
    qDebug() << "[MainWindow] üî• onFilesCollected aufgerufen mit" << totalFiles << "Dateien";
    std::cout << "[MainWindow] üî• FTP Discovery abgeschlossen - " << totalFiles << " Dateien gesammelt!" << std::endl;
    
    m_filesCollectedHandled = true;  // üîí Lock - nur EINMAL verarbeiten
    
    // GUI-Updates f√ºr Discovery-Completion
    if (progressBar) {
        progressBar->setValue(50); // Discovery ist 50% des Scans
    }
    
    if (actionLabel) {
        actionLabel->setText(tr("üìÅ %1 Dateien gesammelt - Starte Analyse...").arg(totalFiles));
    }
    
    if (currentFileLabel) {
        currentFileLabel->setText(tr("üîç Discovery abgeschlossen - Berechne Hashes..."));
    }
    
    statusBar()->showMessage(tr("‚úÖ FTP Discovery abgeschlossen: %1 Dateien gefunden").arg(totalFiles), 3000);
    
    qDebug() << "[MainWindow] ‚úÖ GUI f√ºr Discovery-Completion aktualisiert";
    
    // üî• CRITICAL FIX: STARTE HASH-BERECHNUNG SOFORT (parallel zur Sortierung)!
    qDebug() << "[MainWindow] üöÄ STARTE HASH-BERECHNUNG sofort nach File Collection!";
    if (m_scanner) {
        // ‚ö° OPTIMIERUNG: Keine Wartezeit - starte Hash-Berechnung SOFORT!
        // Sortierung l√§uft parallel (ist Memory-Operation, ultra-schnell)
        QTimer::singleShot(0, this, &MainWindow::onHashCalculationStartNeeded);
    }
}

void MainWindow::onHashCalculationStartNeeded()
{
    qDebug() << "[MainWindow] üî• onHashCalculationStartNeeded - starte Hash-Berechnung!";
    
    // üõ°Ô∏è CRITICAL: Prevent multiple hash calculation starts
    if (m_hashCalculationStarted) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Hash calculation already started, ignoring duplicate call";
        return;
    }
    
    if (m_scanner) {
        int fileCount = m_scanner->getAllFiles().size();
        qDebug() << "[MainWindow] üìä Total files in Scanner:" << fileCount;
        if (fileCount > 0) {
            qDebug() << "[MainWindow] ‚úÖ Rufe startProcessingCollectedFiles() auf";
            m_hashCalculationStarted = true;  // üîí Lock to prevent re-entry
            m_scanner->startProcessingCollectedFiles();
        } else {
            qDebug() << "[MainWindow] ‚ö†Ô∏è KEINE FILES gefunden! Warte nochmal 10s...";
            QTimer::singleShot(10000, this, &MainWindow::onHashCalculationStartNeeded);
        }
    }
}

void MainWindow::onHashProgress(int current, int total)
{
    qDebug() << "[MainWindow] üîê onHashProgress:" << current << "/" << total;
    
    if (total > 0) {
        int percentage = (current * 100) / total;
        
        // üîá STOP BLINKING during hash (happens once at start)
        if (m_activityIndicator) {
            m_activityIndicator->setActivity(false);
        }
        
        // Update progress bar
        if (progressBar) {
            progressBar->setMaximum(total); // Set to determinate mode
            progressBar->setValue(current);
        }
        
        // Update labels
        if (actionLabel) {
            actionLabel->setText(tr("üîê Hash-Berechnung: %1%").arg(percentage));
        }
        
        if (fileCountLabel) {
            fileCountLabel->setText(tr("Dateien: %1 / %2").arg(current).arg(total));
        }
        
        if (currentFileLabel) {
            currentFileLabel->setText(tr("Berechne Hashes... %1%").arg(percentage));
        }
        
        statusBar()->showMessage(tr("üîê Hash-Berechnung: %1% (%2/%3 Dateien)").arg(percentage).arg(current).arg(total), 0);
        
        qDebug() << "[MainWindow] ‚úÖ Hash-Progress GUI aktualisiert:" << percentage << "%";
    }
}

// üöÄ NEUE DETAILLIERTE PROGRESS-SLOT-IMPLEMENTIERUNGEN

void MainWindow::onCurrentFileProcessing(const QString &fileName, const QString &processType, int fileNumber, int totalFiles)
{
    qDebug() << "[MainWindow] üìÑ onCurrentFileProcessing aufgerufen:" << processType << fileName << "(" << fileNumber << "/" << totalFiles << ")";
    qDebug() << "[MainWindow] üîç Labels: currentFileLabel=" << (currentFileLabel ? "OK" : "NULL") 
             << " actionLabel=" << (actionLabel ? "OK" : "NULL")
             << " pathProcessingLabel=" << (pathProcessingLabel ? "OK" : "NULL");
    // DEBUG DISABLED FOR PERFORMANCE
    
    // üéØ FTP-QUEUE-MONITORING: Extrahiere Queue-Gr√∂√üe aus fileName wenn vorhanden
    QString displayFileName = fileName;
    QString queueInfo;
    
    // ‚ö° RATE LIMITING: Verhindere Spam bei identischen Queue-Updates
    static QString lastQueueInfo;
    static QTime lastUpdateTime = QTime::currentTime();
    
    // Format: "ftp://host/path | Verbleibend: 3695"
    if (fileName.contains(" | Verbleibend: ")) {
        QStringList parts = fileName.split(" | Verbleibend: ");
        if (parts.size() == 2) {
            displayFileName = parts[0];
            queueInfo = QString(" | üéØ Queue: %1").arg(parts[1]);
            
            // üö® ANTI-SPAM: Zeige nur bei √Ñnderung oder alle 5 Sekunden
            QTime currentTime = QTime::currentTime();
            if (queueInfo != lastQueueInfo || lastUpdateTime.secsTo(currentTime) >= 5) {
                std::cout << "[MainWindow] üéØ QUEUE UPDATE: " << parts[1].toUtf8().constData() << std::endl;
                lastQueueInfo = queueInfo;
                lastUpdateTime = currentTime;
            }
        }
    }
    
    // üõ°Ô∏è CRITICAL NULL-CHECKS f√ºr currentFileLabel
    if (!currentFileLabel) {
        qWarning() << "[MainWindow] ‚ùå currentFileLabel ist NULL!";
        std::cout << "[MainWindow] ‚ùå‚ùå‚ùå currentFileLabel ist NULL!" << std::endl;
        return;
    }
    
    if (currentFileLabel) {
        // Zeige Dateinamen + Z√§hler f√ºr bessere √úbersicht
        QString displayText = displayFileName.isEmpty() ? processType : displayFileName;
        QString text = QString("üìÑ %1 (%2/%3)%4").arg(displayText).arg(fileNumber).arg(totalFiles).arg(queueInfo);
        currentFileLabel->setText(text);
        currentFileLabel->repaint(); // üöÄ FORCE IMMEDIATE REPAINT!
        
        // üî• FORCE GUI UPDATE: Erzwinge sofortige Anzeige
        // REMOVED: QCoreApplication::processEvents();
        
        // DEBUG DISABLED FOR PERFORMANCE
    } else {
        qWarning() << "[MainWindow] ‚ùå currentFileLabel ist NULL!";
        std::cout << "[MainWindow] ‚ùå‚ùå‚ùå currentFileLabel ist NULL!" << std::endl;
    }
    
    if (actionLabel) {
        actionLabel->setText(QString("üîç %1 (%2/%3)").arg(processType).arg(fileNumber).arg(totalFiles));
        actionLabel->repaint();
    } else {
        qWarning() << "[MainWindow] ‚ùå actionLabel ist NULL!";
    }
    
    // üöÄ ECHTZEIT-UPDATE: Statusbar zeigt nur wichtigste Info (ProgressBar zeigt Zahlen bereits!)
    QString statusMsg = QString("%1: %2%3").arg(processType, displayFileName, queueInfo);
    statusBar()->showMessage(statusMsg, 0);
    
    // Force GUI update
    // REMOVED: QCoreApplication::processEvents();
}

void MainWindow::onProcessActivityUpdate(const QString &activity, const QString &details)
{
    qDebug() << "[MainWindow] üîÑ onProcessActivityUpdate:" << activity << "-" << details;
    std::cout << "[MainWindow] üîÑ Activity: " << activity.toUtf8().constData() << " | " << details.toUtf8().constData() << std::endl;
    
    // üéØ FTP-STATISTIKEN: Parse "Files: X Success: Y" aus details
    QString displayActivity = activity;
    QString displayDetails = details;
    
    if (details.contains("Files:") && details.contains("Success:")) {
        // Format: "Files: 19 Success: true"
        QRegularExpression re(R"(Files:\s*(\d+)\s*Success:\s*(\w+))");
        QRegularExpressionMatch match = re.match(details);
        
        if (match.hasMatch()) {
            QString filesCount = match.captured(1);
            QString successStr = match.captured(2);
            QString successIcon = (successStr == "true") ? "‚úÖ" : "‚ùå";
            
            displayDetails = QString("%1 %2 Dateien gefunden").arg(successIcon, filesCount);
            std::cout << "[MainWindow] üìäüìäüìä FTP-STATISTIK: " << displayDetails.toUtf8().constData() << std::endl;
        }
    }
    
    if (actionLabel) {
        actionLabel->setText(displayActivity);
        qDebug() << "[MainWindow] ‚úÖ actionLabel aktualisiert (Activity):" << displayActivity;
    } else {
        qWarning() << "[MainWindow] ‚ùå actionLabel ist NULL (Activity)!";
    }
    
    // Details in Status-Bar anzeigen mit besserer Formatierung
    if (!displayDetails.isEmpty()) {
        statusBar()->showMessage(QString("%1 - %2").arg(displayActivity, displayDetails), 0); // 0 = kein Timeout!
        qDebug() << "[MainWindow] ‚úÖ StatusBar:" << displayActivity << "-" << displayDetails;
    } else {
        statusBar()->showMessage(displayActivity, 0);
    }
    
    // üöÄ Aktualisiere auch pathProcessingLabel wenn vorhanden
    if (pathProcessingLabel) {
        if (activity.contains("FTP") || !displayDetails.isEmpty()) {
            pathProcessingLabel->setText(displayDetails);
            pathProcessingLabel->repaint(); // üöÄ FORCE IMMEDIATE REPAINT!
            qDebug() << "[MainWindow] ‚úÖ pathProcessingLabel aktualisiert:" << displayDetails;
            std::cout << "[MainWindow] ‚úÖ‚úÖ‚úÖ PATH LABEL: " << displayDetails.toUtf8().constData() << std::endl;
        }
    } else {
        qWarning() << "[MainWindow] ‚ùå pathProcessingLabel ist NULL!";
    }
    
    // Force GUI update
    // REMOVED: QCoreApplication::processEvents();
}

void MainWindow::onFileComparisonProgress(const QString &file1, const QString &file2, int comparisonNumber, int totalComparisons)
{
    if (fileComparisonLabel) {
        QString shortFile1 = QFileInfo(file1).fileName();
        QString shortFile2 = QFileInfo(file2).fileName();
        fileComparisonLabel->setText(QString("üîç %1 ‚Üî %2 (%3/%4)").arg(shortFile1, shortFile2, QString::number(comparisonNumber), QString::number(totalComparisons)));
    }
    
    // Berechne Prozent f√ºr Progress-Bar
    if (totalComparisons > 0) {
        int percentage = (comparisonNumber * 100) / totalComparisons;
        progressBar->setValue(percentage);
    }
}

void MainWindow::onPathProcessingUpdate(const QString &currentPath, const QString &action, int pathNumber, int totalPaths)
{
    if (pathProcessingLabel) {
        QString shortPath = currentPath.length() > 50 ? "..." + currentPath.right(47) : currentPath;
        pathProcessingLabel->setText(QString("üìÇ %1: %2 (%3/%4)").arg(action, shortPath, QString::number(pathNumber), QString::number(totalPaths)));
    }
}

void MainWindow::onDuplicateDetectionUpdate(int duplicatesFound, int groupsCreated, const QString &latestDuplicate)
{
    // üî• WICHTIG: NICHT "0 Duplikate" w√§hrend Scan anzeigen!
    if (duplicatesFound == 0) {
        // Zeige "Scan l√§uft..." statt "0 Duplikate"
        if (duplicateCountLabel) {
            duplicateCountLabel->setText(tr("üîç Suche Duplikate..."));
        }
        return; // Kein Update bei 0 Duplikaten
    }
    
    // ‚úÖ Nur bei echten Duplikaten anzeigen
    if (duplicateCountLabel) {
        duplicateCountLabel->setText(QString("üîÑ %1 Duplikate in %2 Gruppen").arg(duplicatesFound).arg(groupsCreated));
    }
    
    // Zeige letztes gefundenes Duplikat kurz in Status-Bar
    if (!latestDuplicate.isEmpty()) {
        statusBar()->showMessage(QString("üîç Duplikat: %1").arg(latestDuplicate), 500);
    }
}

void MainWindow::onHardwareUsageUpdate(const QString &processingUnit, int utilizationPercent, const QString &currentTask)
{
    if (hardwareStatusLabel) {
        // Color-coding basierend auf Auslastung
        QString colorClass;
        if (utilizationPercent >= 90) {
            colorClass = "color: red; font-weight: bold;"; // üî¥ Kritisch
        } else if (utilizationPercent >= 70) {
            colorClass = "color: orange; font-weight: bold;"; // üü† Hoch
        } else if (utilizationPercent >= 30) {
            colorClass = "color: green;"; // üü¢ Normal
        } else {
            colorClass = "color: gray;"; // Niedrig
        }
        
        hardwareStatusLabel->setStyleSheet(QString("QLabel { %1 }").arg(colorClass));
        hardwareStatusLabel->setText(QString("‚ö° %1: %2% - %3").arg(processingUnit, QString::number(utilizationPercent), currentTask));
    }
}

// +++ NEUE FUNKTIONEN F√úR VERZEICHNISBAUM MIT CHECKBOXEN +++

void MainWindow::loadLocalDirectoryTreeWithCheckboxes()
{
    // ‚úÖ NEUES DESIGN: Kompatibel mit directorySummaryLabel
    qDebug() << "[MainWindow] üìÅ loadLocalDirectoryTreeWithCheckboxes: Nicht mehr verwendet in neuer GUI";
    
    // Backup: Lade Standard-Verzeichnisse in m_selectedDirectories wenn leer
    if (m_selectedDirectories.isEmpty()) {
        QStringList systemPaths = {
            QStandardPaths::writableLocation(QStandardPaths::HomeLocation),
            QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
            QStandardPaths::writableLocation(QStandardPaths::DownloadLocation),
            QStandardPaths::writableLocation(QStandardPaths::PicturesLocation),
            QStandardPaths::writableLocation(QStandardPaths::MusicLocation),
            QStandardPaths::writableLocation(QStandardPaths::MoviesLocation)
        };
        
        for (const QString &path : systemPaths) {
            if (QDir(path).exists() && !m_selectedDirectories.contains(path)) {
                m_selectedDirectories.append(path);
            }
        }
        updateDirectoryTree();
        qDebug() << "[MainWindow] üìÅ Standard-Verzeichnisse geladen:" << m_selectedDirectories.size();
    }
}


void MainWindow::onDirectoryItemExpanded(QTreeWidgetItem *item)
{
    // ‚úÖ ECHTES LAZY-LOADING: Kinder nur bei erster Expansion laden
    if (item && item->childCount() == 1 && item->child(0)->text(0) == "Lade...") {
        item->takeChild(0); // Loading-Platzhalter entfernen
        loadSubDirectories(item, item->data(0, Qt::UserRole).toString());
    }
}

void MainWindow::loadSubDirectories(QTreeWidgetItem *parentItem, const QString &path)
{
    QDir dir(path);
    QFileInfoList entries = dir.entryInfoList(QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot, QDir::Name);

    for (const QFileInfo &info : entries) {
        QTreeWidgetItem *childItem = new QTreeWidgetItem(parentItem);
        QString icon = info.isDir() ? "üìÅ" : "üìÑ";
        childItem->setText(0, icon + " " + info.fileName());
        childItem->setText(1, formatFileSize(info.isDir() ? getDirSize(info.filePath()) : info.size()));
        childItem->setText(2, info.lastModified().toString("dd.MM.yyyy hh:mm"));
        childItem->setData(0, Qt::UserRole, info.filePath());
        childItem->setFlags(childItem->flags() | Qt::ItemIsUserCheckable);
        childItem->setCheckState(0, Qt::Unchecked);

        // For directories, check if they have subdirectories to show expander
        if (info.isDir()) {
            QDir subDir(info.filePath());
            if (subDir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot).count() > 0) {
                new QTreeWidgetItem(childItem, QStringList("Lade..."));
            }
        }
    }
}

QString MainWindow::formatFileSize(qint64 size) const
{
    if (size < 1024) return QString::number(size) + " B";
    if (size < 1024 * 1024) return QString::number(size / 1024.0, 'f', 1) + " KB";
    if (size < 1024 * 1024 * 1024) return QString::number(size / (1024.0 * 1024.0), 'f', 1) + " MB";
    return QString::number(size / (1024.0 * 1024.0 * 1024.0), 'f', 1) + " GB";
}

qint64 MainWindow::getDirSize(const QString &path)
{
    // Quick approximation - in real app you'd do this async
    QDir dir(path);
    qint64 size = 0;
    QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot);
    for (const QFileInfo &file : files) {
        size += file.size();
        if (size > 1024 * 1024 * 100) break; // Stop at 100MB for performance
    }
    return size;
}

// üîê HASH-CACHE: Lade Hash aus Cache-Datei mit Gr√∂√üen-Verifikation
QString MainWindow::loadHashFromCacheFile(const QString &filePath, qint64 size)
{
    QString hashCacheFile = QDir::homePath() + "/.fileduper_hash_cache.dat";
    QFile file(hashCacheFile);
    
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return QString(); // Cache-Datei nicht vorhanden
    }
    
    QString canonical = QFileInfo(filePath).canonicalFilePath();
    if (canonical.isEmpty()) {
        canonical = filePath; // Fallback f√ºr Netzwerk-Pfade
    }
    
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();
        if (line.isEmpty() || line.startsWith("#")) continue;
        
        // Format: hash|size|filepath
        QStringList parts = line.split("|");
        if (parts.size() >= 3) {
            QString cachedHash = parts[0];
            qint64 cachedSize = parts[1].toLongLong();
            QString cachedPath = parts.mid(2).join("|"); // Falls Pfad | enth√§lt
            
            // Pr√ºfe ob Pfad √ºbereinstimmt
            if (cachedPath == canonical || cachedPath == filePath) {
                // Pr√ºfe Gr√∂√üe zur Verifikation
                if (cachedSize == size) {
                    file.close();
                    return cachedHash; // ‚úÖ Hash gefunden und Gr√∂√üe stimmt √ºberein
                } else {
                    qWarning() << "[MainWindow] ‚ö†Ô∏è Cache-Gr√∂√üe stimmt nicht √ºberein:" 
                              << filePath << "Cache:" << cachedSize << "Aktuell:" << size;
                    file.close();
                    return QString(); // ‚ùå Gr√∂√üe stimmt nicht ‚Üí Datei wurde ge√§ndert
                }
            }
        }
    }
    
    file.close();
    return QString(); // Kein Hash im Cache gefunden
}

// --- ENDE NEUE FUNKTIONEN ---

void MainWindow::displayResults(const QList<QStringList> &duplicateGroups)
{
    resultsTable->setRowCount(0);

    if (duplicateGroups.isEmpty()) {
        // üéâ WICHTIG: Nur "Keine Duplikate" zeigen wenn Scan ABGESCHLOSSEN ist!
        if (!m_isScanning) {
            resultsTable->setRowCount(1);
            resultsTable->setColumnCount(3);
            
            QTableWidgetItem *messageItem = new QTableWidgetItem("üéâ Keine Duplikate gefunden!");
            messageItem->setTextAlignment(Qt::AlignCenter);
            messageItem->setBackground(QColor(144, 238, 144));
            messageItem->setFont(QFont("Arial", 12, QFont::Bold));
            resultsTable->setItem(0, 0, messageItem);
            
            QTableWidgetItem *detailItem = new QTableWidgetItem("Alle Dateien sind einzigartig");
            detailItem->setTextAlignment(Qt::AlignCenter);
            detailItem->setBackground(QColor(144, 238, 144));
            resultsTable->setItem(0, 1, detailItem);
            
            QTableWidgetItem *statusItem = new QTableWidgetItem("‚úÖ Scan erfolgreich");
            statusItem->setTextAlignment(Qt::AlignCenter);
            statusItem->setBackground(QColor(144, 238, 144));
            resultsTable->setItem(0, 2, statusItem);
            
            resultsTable->resizeColumnsToContents();
        }
        return;
    }

    // üéØ GRUPPIERTE ANZEIGE: Jede Gruppe mit Trenner und visueller Hierarchie
    int groupNumber = 1;
    for (const QStringList &group : duplicateGroups)
    {
        if (group.size() < 2) continue; // Skip Gruppen mit nur 1 Datei
        
        // üìä GRUPPEN-HEADER: Zeige Gruppen-Nummer und Anzahl Duplikate
        int headerRow = resultsTable->rowCount();
        resultsTable->insertRow(headerRow);
        
        QTableWidgetItem *groupHeaderItem = new QTableWidgetItem(
            QString("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üóÇÔ∏è GRUPPE %1 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê (%2 Dateien) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê").arg(groupNumber).arg(group.size())
        );
        groupHeaderItem->setTextAlignment(Qt::AlignCenter);
        groupHeaderItem->setBackground(QColor(70, 130, 180, 100)); // Steel Blue
        groupHeaderItem->setForeground(Qt::white);
        groupHeaderItem->setFont(QFont("Arial", 11, QFont::Bold));
        groupHeaderItem->setFlags(Qt::ItemIsEnabled); // Nicht selektierbar
        resultsTable->setItem(headerRow, 0, groupHeaderItem);
        
        // Merge alle Spalten f√ºr Header
        resultsTable->setSpan(headerRow, 0, 1, resultsTable->columnCount());
        
        // üü¢ ORIGINAL (erste Datei in Gruppe)
        addResultRow(group.first(), true);
        
        // üî¥ DUPLIKATE (Rest der Gruppe)
        for (int i = 1; i < group.size(); ++i) {
            addResultRow(group.at(i), false);
        }
        
        // üìè LEERZEILE als visuelle Trennung zwischen Gruppen
        int separatorRow = resultsTable->rowCount();
        resultsTable->insertRow(separatorRow);
        QTableWidgetItem *separatorItem = new QTableWidgetItem("");
        separatorItem->setBackground(QColor(240, 240, 240)); // Light gray
        separatorItem->setFlags(Qt::ItemIsEnabled); // Nicht selektierbar
        resultsTable->setItem(separatorRow, 0, separatorItem);
        resultsTable->setSpan(separatorRow, 0, 1, resultsTable->columnCount());
        resultsTable->setRowHeight(separatorRow, 5); // D√ºnne Trennlinie
        
        groupNumber++;
    }

    resultsTable->resizeColumnsToContents();
    
    qDebug() << "[MainWindow] üé® Gruppierte Anzeige:" << groupNumber - 1 << "Gruppen mit visuellen Trennern";
}

// üéØ NEUE GRUPPIERTE ANZEIGE mit FileInfo (inkl. Hash!)
void MainWindow::displayResultsGrouped(const DuplicateGroups &results)
{
    resultsTable->setRowCount(0);

    if (results.groups.isEmpty()) {
        if (!m_isScanning) {
            resultsTable->setRowCount(1);
            resultsTable->setColumnCount(3);
            
            QTableWidgetItem *messageItem = new QTableWidgetItem("üéâ Keine Duplikate gefunden!");
            messageItem->setTextAlignment(Qt::AlignCenter);
            messageItem->setBackground(QColor(144, 238, 144));
            messageItem->setFont(QFont("Arial", 12, QFont::Bold));
            resultsTable->setItem(0, 0, messageItem);
            
            QTableWidgetItem *detailItem = new QTableWidgetItem("Alle Dateien sind einzigartig");
            detailItem->setTextAlignment(Qt::AlignCenter);
            detailItem->setBackground(QColor(144, 238, 144));
            resultsTable->setItem(0, 1, detailItem);
            
            QTableWidgetItem *statusItem = new QTableWidgetItem("‚úÖ Scan erfolgreich");
            statusItem->setTextAlignment(Qt::AlignCenter);
            statusItem->setBackground(QColor(144, 238, 144));
            resultsTable->setItem(0, 2, statusItem);
            
            resultsTable->resizeColumnsToContents();
        }
        return;
    }

    // üéØ Tabellen-Konfiguration: Status | Hash | Name | Pfad | Gr√∂√üe
    resultsTable->setSortingEnabled(false); // Deaktiviere Sortierung w√§hrend Bef√ºllen
    resultsTable->setColumnCount(5);
    resultsTable->setHorizontalHeaderLabels({"Status", "Hash", "Dateiname", "Pfad", "Gr√∂√üe"});
    resultsTable->horizontalHeader()->setStretchLastSection(false);
    resultsTable->horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    resultsTable->setColumnWidth(1, 280); // Hash-Spalte auf 280px
    // üîê Hash-Cache laden f√ºr schnellen Zugriff
    QMap<QString, QPair<QString, qint64>> hashCacheMap;
    QString hashCacheFile = QDir::homePath() + "/.fileduper_hash_cache.dat";
    QFile cacheFile(hashCacheFile);
    if (cacheFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QTextStream in(&cacheFile);
        while (!in.atEnd()) {
            QString line = in.readLine().trimmed();
            if (line.isEmpty() || line.startsWith("#")) continue;
            
            QStringList parts = line.split("|");
            if (parts.size() >= 3) {
                QString hash = parts[0];
                qint64 size = parts[1].toLongLong();
                QString filePath = parts.mid(2).join("|");
                hashCacheMap[filePath] = qMakePair(hash, size);
            }
        }
        cacheFile.close();
    }
    
    int groupNumber = 1;
    for (const DuplicateGroup &group : results.groups)
    {
        if (group.duplicates.isEmpty()) continue; // Skip Gruppen ohne Duplikate
        
        // Original mit Hash aus Cache falls n√∂tig
        FileInfo originalWithHash = group.original;
        if (originalWithHash.hash.isEmpty()) {
            QString canonical = QFileInfo(originalWithHash.filePath).canonicalFilePath();
            QString rawPath = originalWithHash.filePath;
            
            // Versuche canonical lookup zuerst, dann raw
            if (!canonical.isEmpty() && hashCacheMap.contains(canonical)) {
                auto cached = hashCacheMap[canonical];
                if (cached.second == originalWithHash.size) {
                    originalWithHash.hash = cached.first;
                }
            } else if (hashCacheMap.contains(rawPath)) {
                auto cached = hashCacheMap[rawPath];
                if (cached.second == originalWithHash.size) {
                    originalWithHash.hash = cached.first;
                }
            }
        }
        addResultRowWithInfo(originalWithHash, true);
        
        // Duplikate mit Hash aus Cache falls n√∂tig
        for (const FileInfo &duplicate : group.duplicates) {
            FileInfo duplicateWithHash = duplicate;
            if (duplicateWithHash.hash.isEmpty()) {
                QString canonical = QFileInfo(duplicateWithHash.filePath).canonicalFilePath();
                QString rawPath = duplicateWithHash.filePath;
                
                if (!canonical.isEmpty() && hashCacheMap.contains(canonical)) {
                    auto cached = hashCacheMap[canonical];
                    if (cached.second == duplicateWithHash.size) {
                        duplicateWithHash.hash = cached.first;
                    }
                } else if (hashCacheMap.contains(rawPath)) {
                    auto cached = hashCacheMap[rawPath];
                    if (cached.second == duplicateWithHash.size) {
                        duplicateWithHash.hash = cached.first;
                    }
                }
            }
            addResultRowWithInfo(duplicateWithHash, false);
        }
        
        groupNumber++;
    }
    resultsTable->resizeColumnsToContents();
    // Keine Sortierung aktivieren - Reihenfolge bleibt wie eingef√ºgt
}

void MainWindow::addResultRowWithInfo(const FileInfo &fileInfo, bool isOriginal)
{
    int row = resultsTable->rowCount();
    resultsTable->insertRow(row);

    QString filePath = fileInfo.filePath;
    bool isNetworkFile = filePath.startsWith("ftp://") || filePath.startsWith("sftp://") || filePath.startsWith("smb://");
    QString networkType = "";
    QString displayPath = filePath;
    
    // Extrahiere Dateinamen IMMER aus dem Pfad (nicht aus fileInfo.fileName!)
    QString fileName;
    if (isNetworkFile) {
        QUrl url(filePath);
        fileName = url.fileName();  // Dateiname aus URL
        if (filePath.startsWith("ftp://")) networkType = "FTP";
        else if (filePath.startsWith("sftp://")) networkType = "SFTP";
        else if (filePath.startsWith("smb://")) networkType = "SMB";
        displayPath = QString("%1://%2%3").arg(networkType.toLower()).arg(url.host()).arg(url.path());
    } else {
        QFileInfo pathInfo(filePath);
        fileName = pathInfo.fileName();  // Dateiname aus lokalem Pfad
        displayPath = filePath;
    }

    auto createSelectableItem = [](const QString &text) -> QTableWidgetItem* {
        QTableWidgetItem *item = new QTableWidgetItem(text);
        item->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsEditable);
        item->setTextAlignment(Qt::AlignLeft | Qt::AlignVCenter);
        return item;
    };

    QTableWidgetItem *statusItem = createSelectableItem("");
    QTableWidgetItem *nameItem = createSelectableItem(
        isNetworkFile ? QString("üì° %1").arg(fileName) : QString("üìÇ %1").arg(fileName)
    );
    QTableWidgetItem *pathItem = createSelectableItem(displayPath);
    QTableWidgetItem *sizeItem = createSelectableItem(formatFileSize(fileInfo.size));
    
    // Hash-Display vorbereiten
    QString hashDisplay;
    QString cacheSource = "";
    
    if (!fileInfo.hash.isEmpty()) {
        hashDisplay = fileInfo.hash;
        cacheSource = "‚úÖ Scan";
    } else {
        // Versuche Hash aus Cache zu laden
        QString cachedHashFromFile = loadHashFromCacheFile(filePath, fileInfo.size);
        if (!cachedHashFromFile.isEmpty()) {
            hashDisplay = cachedHashFromFile;
            cacheSource = "üîê Cache";
        } else {
            hashDisplay = "‚è≥ Berechnung...";
            cacheSource = "‚ùå Fehlt";
        }
    }
    
    QTableWidgetItem *hashItem = createSelectableItem(hashDisplay);
    hashItem->setToolTip(QString("Quelle: %1 | Gr√∂√üe: %2")
                        .arg(cacheSource)
                        .arg(formatFileSize(fileInfo.size)));
    hashItem->setForeground(Qt::black);
    hashItem->setFont(QFont("Monospace", 9));

    if (isOriginal) {
        statusItem->setText("üü¢ ORIGINAL");
        statusItem->setToolTip(tr("Originaldatei - Diese behalten"));
        statusItem->setBackground(QColor(100, 200, 100));
        statusItem->setForeground(Qt::white);
        statusItem->setFont(QFont("Arial", 10, QFont::Bold));
        
        nameItem->setBackground(QColor(230, 255, 230));
        pathItem->setBackground(QColor(230, 255, 230));
        sizeItem->setBackground(QColor(230, 255, 230));
        hashItem->setBackground(QColor(230, 255, 230));
    } else {
        statusItem->setText("üî¥ DUPLIKAT");
        statusItem->setToolTip(tr("Duplikat - Kann gel√∂scht werden"));
        statusItem->setBackground(QColor(255, 100, 100));
        statusItem->setForeground(Qt::white);
        statusItem->setFont(QFont("Arial", 10, QFont::Bold));
        
        nameItem->setBackground(QColor(255, 240, 240));
        pathItem->setBackground(QColor(255, 240, 240));
        sizeItem->setBackground(QColor(255, 240, 240));
        hashItem->setBackground(QColor(255, 240, 240));
    }

    statusItem->setData(Qt::UserRole + 1, isOriginal);
    pathItem->setData(Qt::UserRole, filePath);

    // Spalten-Reihenfolge: Status, Hash, Name, Pfad, Gr√∂√üe
    resultsTable->setItem(row, 0, statusItem);
    resultsTable->setItem(row, 1, hashItem);
    resultsTable->setItem(row, 2, nameItem);
    resultsTable->setItem(row, 3, pathItem);
    resultsTable->setItem(row, 4, sizeItem);
}

void MainWindow::addResultRow(const QString &filePath, bool isOriginal, int row)
{
    if (row == -1)
    {
        row = resultsTable->rowCount();
        resultsTable->insertRow(row);
    }

    QFileInfo fileInfo(filePath);
    
    // ‚úÖ NEU: Erkenne ob es sich um eine Netzwerk-Datei handelt
    bool isNetworkFile = filePath.startsWith("ftp://") || filePath.startsWith("sftp://") || filePath.startsWith("smb://");
    QString networkType = "";
    QString displayPath = filePath;
    
    if (isNetworkFile) {
        if (filePath.startsWith("ftp://")) networkType = "FTP";
        else if (filePath.startsWith("sftp://")) networkType = "SFTP";
        else if (filePath.startsWith("smb://")) networkType = "SMB";
        
        // F√ºr Netzwerk-Dateien: Zeige kompakteren Pfad an
        QUrl url(filePath);
        displayPath = QString("%1://%2%3").arg(networkType.toLower()).arg(url.host()).arg(url.path());
    } else {
        displayPath = fileInfo.absoluteFilePath();
    }

    // üìã CREATE SELECTABLE TABLE ITEMS (text can be selected with mouse)
    auto createSelectableItem = [](const QString &text) -> QTableWidgetItem* {
        QTableWidgetItem *item = new QTableWidgetItem(text);
        item->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsEditable);
        item->setTextAlignment(Qt::AlignLeft | Qt::AlignVCenter);
        return item;
    };

    QTableWidgetItem *statusItem = createSelectableItem("");
    QTableWidgetItem *nameItem = createSelectableItem(isNetworkFile ? 
                                                      QString("üì° %1").arg(fileInfo.fileName()) : 
                                                      QString("üìÇ %1").arg(fileInfo.fileName()));
    QTableWidgetItem *pathItem = createSelectableItem(displayPath);
    QTableWidgetItem *sizeItem = createSelectableItem(isNetworkFile ? 
                                                      "Netzwerk" : 
                                                      QString::number(fileInfo.size()));
    QTableWidgetItem *hashItem = createSelectableItem(""); // Hash wird sp√§ter gesetzt

    if (isOriginal)
    {
        statusItem->setIcon(QIcon(":/icons/original.png"));
        statusItem->setText("üü¢ ORIGINAL");
        statusItem->setToolTip(isNetworkFile ? 
                               tr("Original file (Netzwerk: %1)").arg(networkType) : 
                               tr("Original file (Lokal)"));
        statusItem->setBackground(QColor(255, 255, 150, 50));
        
        // ‚úÖ NEU: Verschiedene Farben f√ºr lokale vs. Netzwerk-Originale
        if (isNetworkFile) {
            statusItem->setBackground(QColor(255, 200, 150, 70)); // Orange f√ºr Netzwerk-Original
        }
    }
    else
    {
        statusItem->setIcon(QIcon(":/icons/duplicate.png"));
        statusItem->setText("üî¥ DUPLIKAT");
        statusItem->setToolTip(isNetworkFile ? 
                               tr("Duplicate file (Netzwerk: %1)").arg(networkType) : 
                               tr("Duplicate file (Lokal)"));
        statusItem->setBackground(QColor(150, 255, 150, 50));
        
        // ‚úÖ NEU: Verschiedene Farben f√ºr lokale vs. Netzwerk-Duplikate
        if (isNetworkFile) {
            statusItem->setBackground(QColor(150, 200, 255, 70)); // Blau f√ºr Netzwerk-Duplikat
        }
    }

    // Hidden flag for robust original/duplicate classification
    statusItem->setData(Qt::UserRole + 1, isOriginal);

    // Hash berechnen und setzen (nur f√ºr lokale Dateien)
    if (!isNetworkFile) {
        QThreadPool::globalInstance()->start([this, filePath, row]()
        {
            HashEngine hashEngine;
            hashEngine.setAlgorithm(HashEngine::MD5);
            QString hash = hashEngine.calculateFileHash(filePath);
            QMetaObject::invokeMethod(this, "setHashForRow", Qt::QueuedConnection, Q_ARG(int, row), Q_ARG(QString, hash));
        });
    } else {
        // F√ºr Netzwerk-Dateien: Hash wird vom Scanner bereitgestellt
        hashItem->setText("FTP-Hash");
    }

    // Always store the canonical/original full path for deletion
    pathItem->setData(Qt::UserRole, isNetworkFile ? filePath : fileInfo.absoluteFilePath());

    resultsTable->setItem(row, 0, statusItem);
    resultsTable->setItem(row, 1, nameItem);
    resultsTable->setItem(row, 2, pathItem);
    resultsTable->setItem(row, 3, sizeItem);
    resultsTable->setItem(row, 4, hashItem);
}

void MainWindow::setHashForRow(int row, const QString &hash)
{
    if (row >= 0 && row < resultsTable->rowCount())
    {
        QTableWidgetItem *hashItem = resultsTable->item(row, 4);
        if (hashItem)
        {
            hashItem->setText(hash); // ‚úÖ VOLLST√ÑNDIGER Hash (32 Zeichen f√ºr MD5)
        }
    }
}

void MainWindow::handleScanError(const QString &error)
{
    m_activityIndicator->setActivity(false);
    QMessageBox::critical(this, tr("Scan Error"), error);
}

void MainWindow::showSettingsDialog()
{
    QMessageBox::information(this, tr("Settings"), tr("Settings dialog will be implemented here"));
}

void MainWindow::showPresetManager()
{
    QMessageBox::information(this, tr("Presets"), tr("Preset manager will be implemented here"));
}

void MainWindow::showAboutDialog()
{
    QMessageBox::about(this, tr("About FileDuper"),
                       tr("<h2>FileDuper v5.0</h2>"
                          "<p>Advanced duplicate file finder with network support</p>"
                          "<p><b>Features:</b></p>"
                          "<ul>"
                          "<li>Multi-protocol network scanning</li>"
                          "<li>Hardware-accelerated hashing</li>"
                          "<li>Smart duplicate detection</li>"
                          "<li>Customizable interface</li>"
                          "</ul>"
                          "<p>Copyright ¬© 2025 FileDuper Team</p>"));
}

// üåê Network Range Management Implementation
void MainWindow::showNetworkRangeSettings()
{
    if (!m_networkRangeWidget) {
        qWarning() << "NetworkRangeWidget not initialized!";
        return;
    }
    
    // Create dialog to show network range settings
    QDialog dialog(this);
    dialog.setWindowTitle(tr("üåê Netzwerk-IP-Bereiche verwalten"));
    dialog.setModal(true);
    dialog.resize(800, 600);
    
    QVBoxLayout *layout = new QVBoxLayout(&dialog);
    
    // Temporarily reparent widget to dialog (fix segfault)
    QWidget *oldParent = m_networkRangeWidget->parentWidget();
    m_networkRangeWidget->setParent(&dialog);
    layout->addWidget(m_networkRangeWidget);
    
    // Dialog buttons
    QHBoxLayout *buttonLayout = new QHBoxLayout();
    QPushButton *applyBtn = new QPushButton(tr("‚úÖ Anwenden"));
    QPushButton *cancelBtn = new QPushButton(tr("‚ùå Abbrechen"));
    
    applyBtn->setStyleSheet("font-weight: bold; background-color: #22c55e; color: white; padding: 8px 16px;");
    cancelBtn->setStyleSheet("background-color: #ef4444; color: white; padding: 8px 16px;");
    
    buttonLayout->addStretch();
    buttonLayout->addWidget(applyBtn);
    buttonLayout->addWidget(cancelBtn);
    layout->addLayout(buttonLayout);
    
    // Connect buttons
    connect(applyBtn, &QPushButton::clicked, [&dialog, this]() {
        updateNetworkRangeDisplay();
        dialog.accept();
    });
    connect(cancelBtn, &QPushButton::clicked, &dialog, &QDialog::reject);
    
    // Show dialog
    if (dialog.exec() == QDialog::Accepted) {
        statusBar()->showMessage(tr("üåê Netzwerk-Bereiche aktualisiert"), 3000);
        
        // NetworkRangeWidget handles all range management internally
        // No need to call addCustomNetworkRange here
    }
    
    // Restore widget to original parent after dialog closes
    m_networkRangeWidget->setParent(oldParent);
}

void MainWindow::onCustomNetworkRangeAdded(const QString &range, const QString &description)
{
    if (m_networkScanner) {
        m_networkScanner->addCustomNetworkRange(range, description);
        statusBar()->showMessage(tr("üåê Neuer IP-Bereich hinzugef√ºgt: %1").arg(range), 3000);
    }
}

void MainWindow::onNetworkRangeSelected(const QString &range)
{
    if (m_networkScanner) {
        // Set the selected range as active
        m_networkScanner->setActiveNetworkRange(range);
        
        // üßπ SMART CLEAR: Remove only IP items, keep credential structure
        qDebug() << "[MainWindow] üßπ Clearing IP items (keeping credentials) for new range:" << range;
        
        // Remove all top-level items (these are the IPs)
        // This keeps the credential manager intact but clears old scan results
        while (networkTree->topLevelItemCount() > 0) {
            delete networkTree->takeTopLevelItem(0);
        }
        
        // Trigger scan for specific range
        statusBar()->showMessage(tr("üîç Starte Scan f√ºr Netzwerk-Bereich: %1").arg(range), 3000);
        
        // Stop any running scan first
        if (m_networkScanner->isScanning()) {
            m_networkScanner->stopScan();
        }
        
        // Start scanning the selected range
        m_networkScanner->startScan();
    }
}

void MainWindow::updateNetworkRangeDisplay()
{
    if (m_networkRangeWidget && m_networkScanner) {
        // Get auto-detected ranges from scanner
        QStringList autoRanges = m_networkScanner->autoDetectNetworkRanges();
        
        // Update widget with current ranges
        m_networkRangeWidget->setAutoDetectedRanges(autoRanges);
        
        // Update status
        int totalRanges = autoRanges.size() + m_networkRangeWidget->getCustomRanges().size();
        networkProgressLabel->setText(tr("üì° %1 IP-Bereiche verf√ºgbar").arg(totalRanges));
    }
}

void MainWindow::closeEvent(QCloseEvent *event)
{
    // ‚úÖ CRASH PREVENTION: Sicheres Beenden der Anwendung
    qDebug() << "[MainWindow] üö™ closeEvent gestartet - Sichere Anwendungsbeendigung...";
    
    try {
        // ‚úÖ 1. Scanner-Check und sicherer Stop
        if (m_scanner && m_scanner->isScanning())
        {
            qDebug() << "[MainWindow] ‚è∏Ô∏è Scanner l√§uft noch - Benutzer fragen...";
            
            QMessageBox::StandardButton reply = QMessageBox::question(
                this,
                tr("Scan in Progress"),
                tr("A scan is currently running. Do you want to stop it and exit?"),
                QMessageBox::Yes | QMessageBox::No);

            if (reply == QMessageBox::No)
            {
                qDebug() << "[MainWindow] ‚ùå Benutzer hat Beenden abgebrochen";
                event->ignore();
                return;
            }

            qDebug() << "[MainWindow] üõë Stoppe Scanner vor Beenden...";
            m_scanner->stopScan();
        }
        
        // ‚úÖ 2. NetworkScanner sicher stoppen
        if (m_networkScanner) {
            qDebug() << "[MainWindow] üì° Stoppe NetworkScanner vor Beenden...";
            // NetworkScanner hat automatische Timer-Bereinigung
        }
        
        // ‚úÖ 3. ActivityIndicator sicher stoppen
        if (m_activityIndicator) {
            qDebug() << "[MainWindow] ‚è∞ Stoppe ActivityIndicator vor Beenden...";
            // ActivityIndicator hat automatische Timer-Bereinigung
        }

        // ‚úÖ 4. Settings sicher speichern
        qDebug() << "[MainWindow] üíæ Speichere Settings vor Beenden...";
        saveSettings();
        
        qDebug() << "[MainWindow] ‚úÖ closeEvent erfolgreich - Anwendung kann sicher beendet werden";
        event->accept();
        
    } catch (const std::exception& e) {
        qDebug() << "[MainWindow] ‚ùå Exception in closeEvent:" << e.what();
        // Trotz Fehler sicher beenden
        event->accept();
    } catch (...) {
        qDebug() << "[MainWindow] ‚ùå Unknown exception in closeEvent";
        // Trotz Fehler sicher beenden
        event->accept();
    }
}

void MainWindow::startProductionScan()
{
    // ‚úÖ PRODUCTION: Start real duplicate scan with user-selected directories
    if (m_selectedDirectories.isEmpty())
    {
        statusBar()->showMessage("‚ö†Ô∏è Keine Verzeichnisse ausgew√§hlt - bitte w√§hlen Sie Scan-Pfade");
        std::cout << "[MainWindow] ‚ö†Ô∏è Keine Verzeichnisse f√ºr Scan ausgew√§hlt" << std::endl;
        return;
    }

    // Starte echten Duplicate Scan mit ausgew√§hlten Verzeichnissen
    if (m_scanner)
    {
        m_scanner->startScan(m_selectedDirectories, "SHA256", "All Files");
        statusBar()->showMessage(QString("üîç Produktions-Scan gestartet f√ºr %1 Verzeichnisse").arg(m_selectedDirectories.size()));
        std::cout << "[MainWindow] üéØ PRODUKTIONS Duplicate Scan gestartet f√ºr " << m_selectedDirectories.size() << " Verzeichnisse" << std::endl;
        
        for (const QString &dir : m_selectedDirectories) {
            std::cout << "  üìÇ " << dir.toUtf8().constData() << std::endl;
        }
    }
    else
    {
        std::cout << "[MainWindow] ‚ùå Scanner nicht initialisiert!" << std::endl;
        statusBar()->showMessage("‚ùå Scanner-Fehler: Nicht initialisiert");
    }
}

void MainWindow::createProductionWorkspace()
{
    // ‚úÖ PRODUCTION: Setup working directories for real scanning
    QString workDir = QDir::currentPath() + "/scanner_workspace";
    QDir().mkpath(workDir);
    
    // Create cache directories for hash storage and FTP temp files
    QDir().mkpath(workDir + "/hash_cache");
    QDir().mkpath(workDir + "/ftp_temp");
    QDir().mkpath(workDir + "/results");
    
    std::cout << "[MainWindow] ‚úÖ Produktions-Workspace erstellt: " << workDir.toUtf8().constData() << std::endl;
    statusBar()->showMessage("‚úÖ Produktions-Workspace bereit f√ºr echte Scans");
}

// ‚úÖ ECHTE HILFSFUNKTION: Pr√ºft ob Verzeichnis Unterverzeichnisse hat
bool MainWindow::hasSubdirectories(const QString &path)
{
    QDir dir(path);
    if (!dir.exists() || !dir.isReadable()) {
        return false;
    }
    
    // Schnelle Pr√ºfung: Mindestens ein Unterverzeichnis vorhanden?
    QFileInfoList entries = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot, QDir::Name);
    return !entries.isEmpty();
}

// ‚úÖ Hardware Monitor Setup (private method implementation)
void MainWindow::setupBottomHardwareMonitor()
{
    qDebug() << "[MainWindow] ‚úÖ setupBottomHardwareMonitor() - Legacy compatibility method";
    // This method exists for MOC compatibility but actual setup is done inline in setupProgrammaticGUI()
}

// ‚úÖ Results Table Context Menu Implementation
void MainWindow::showResultsContextMenu(const QPoint &pos)
{
    // √ñffne Kontextmen√º auch wenn auf leere Fl√§che geklickt wurde
    // (fr√ºher: nur auf Items ‚Üí wir erlauben jetzt globale Aktionen wie "Alle Duplikate entfernen")
    QMenu contextMenu(this);

    // Auto-select row under cursor on right-click if it's not already selected
    QModelIndex idx = resultsTable->indexAt(pos);
    int rowUnderCursor = idx.isValid() ? idx.row() : -1;

    // Collect current selection
    QSet<int> selectedRowSet;
    for (QTableWidgetItem *it : resultsTable->selectedItems()) {
        if (it) selectedRowSet.insert(it->row());
    }

    if (rowUnderCursor >= 0 && !selectedRowSet.contains(rowUnderCursor)) {
        resultsTable->clearSelection();
        resultsTable->selectRow(rowUnderCursor);
        selectedRowSet.clear();
        selectedRowSet.insert(rowUnderCursor);
    }

    // Count duplicates vs originals in current results using hidden flag
    int totalDuplicates = 0;
    int totalOriginals = 0;
    for (int row = 0; row < resultsTable->rowCount(); ++row) {
        QTableWidgetItem *statusItem = resultsTable->item(row, 0); // Status column
        if (!statusItem) continue;
        bool isOriginal = statusItem->data(Qt::UserRole + 1).toBool();
        if (isOriginal) totalOriginals++; else totalDuplicates++;
    }

    // Count how many of the selection are duplicates (not originals)
    int selectedDuplicateCount = 0;
    for (int row : selectedRowSet) {
        QTableWidgetItem *statusItem = resultsTable->item(row, 0);
        if (!statusItem) continue;
        bool isOriginal = statusItem->data(Qt::UserRole + 1).toBool();
        if (!isOriginal) selectedDuplicateCount++;
    }

    // Context menu actions - COPY FIRST!
    QAction *copyPathAction = contextMenu.addAction("üìã Pfad kopieren");
    QAction *copyAllPathsAction = contextMenu.addAction("üìã Alle Pfade kopieren");
    QAction *copyRowAction = contextMenu.addAction("üìã Zeile kopieren");
    QAction *copyAllAction = contextMenu.addAction("üìã Alles kopieren");
    
    contextMenu.addSeparator();
    
    QAction *deleteAllAction = contextMenu.addAction("üóëÔ∏è Alle Duplikate entfernen");
    QAction *deleteSelectedAction = contextMenu.addAction("üóëÔ∏è Markierte entfernen");

    contextMenu.addSeparator();

    QAction *infoAction = contextMenu.addAction(QString("üìä Info: %1 Duplikate, %2 Originale")
                                               .arg(totalDuplicates).arg(totalOriginals));
    infoAction->setEnabled(false); // Info only

    // Enable/disable actions based on content
    copyPathAction->setEnabled(!selectedRowSet.isEmpty());
    copyAllPathsAction->setEnabled(resultsTable->rowCount() > 0);
    copyRowAction->setEnabled(!selectedRowSet.isEmpty());
    copyAllAction->setEnabled(resultsTable->rowCount() > 0);
    deleteAllAction->setEnabled(totalDuplicates > 0);
    deleteSelectedAction->setEnabled(selectedDuplicateCount > 0);

    // Execute selected action
    QAction *selectedAction = contextMenu.exec(resultsTable->mapToGlobal(pos));

    if (selectedAction == copyPathAction) {
        // Copy selected paths to clipboard
        QStringList paths;
        for (int row : selectedRowSet) {
            QTableWidgetItem *pathItem = resultsTable->item(row, 2); // Path column
            if (pathItem) paths.append(pathItem->text());
        }
        QApplication::clipboard()->setText(paths.join("\n"));
        statusBar()->showMessage(tr("üìã %1 Pfade kopiert").arg(paths.size()), 2000);
        
    } else if (selectedAction == copyAllPathsAction) {
        // Copy all paths to clipboard
        QStringList paths;
        for (int row = 0; row < resultsTable->rowCount(); ++row) {
            QTableWidgetItem *pathItem = resultsTable->item(row, 2);
            if (pathItem) paths.append(pathItem->text());
        }
        QApplication::clipboard()->setText(paths.join("\n"));
        statusBar()->showMessage(tr("üìã %1 Pfade kopiert").arg(paths.size()), 2000);
        
    } else if (selectedAction == copyRowAction) {
        // Copy selected rows as tab-separated values
        QStringList rows;
        QList<int> sortedRows = selectedRowSet.values();
        std::sort(sortedRows.begin(), sortedRows.end());
        for (int row : sortedRows) {
            QStringList cells;
            for (int col = 0; col < resultsTable->columnCount(); ++col) {
                QTableWidgetItem *item = resultsTable->item(row, col);
                cells.append(item ? item->text() : "");
            }
            rows.append(cells.join("\t"));
        }
        QApplication::clipboard()->setText(rows.join("\n"));
        statusBar()->showMessage(tr("üìã %1 Zeilen kopiert").arg(rows.size()), 2000);
        
    } else if (selectedAction == copyAllAction) {
        // Copy entire table with headers
        QStringList output;
        // Headers
        QStringList headers;
        for (int col = 0; col < resultsTable->columnCount(); ++col) {
            headers.append(resultsTable->horizontalHeaderItem(col)->text());
        }
        output.append(headers.join("\t"));
        // All rows
        for (int row = 0; row < resultsTable->rowCount(); ++row) {
            QStringList cells;
            for (int col = 0; col < resultsTable->columnCount(); ++col) {
                QTableWidgetItem *item = resultsTable->item(row, col);
                cells.append(item ? item->text() : "");
            }
            output.append(cells.join("\t"));
        }
        QApplication::clipboard()->setText(output.join("\n"));
        statusBar()->showMessage(tr("üìã Komplette Tabelle kopiert (%1 Zeilen)").arg(resultsTable->rowCount()), 2000);
        
    } else if (selectedAction == deleteAllAction) {
        deleteAllDuplicates();
    } else if (selectedAction == deleteSelectedAction) {
        deleteSelectedDuplicates();
    }
}

void MainWindow::deleteAllDuplicates()
{
    if (m_currentDuplicateGroups.groups.isEmpty()) {
        QMessageBox::information(this, "Keine Duplikate", 
            "Es wurden noch keine Duplikate gefunden.\n"
            "F√ºhren Sie zuerst einen Scan durch.");
        return;
    }
    
    // Collect all duplicate and original files
    QStringList duplicateFiles;
    QStringList originalFiles;
    
    for (const auto &group : m_currentDuplicateGroups.groups) {
        // Add original file to protected list
        originalFiles.append(group.original.filePath);
        
        // Add all duplicates to deletion list
        for (const auto &duplicate : group.duplicates) {
            duplicateFiles.append(duplicate.filePath);
        }
    }
    
    // üõë PAUSE Scanner to prevent race condition during deletion
    if (m_scanner && m_scanner->isScanning()) {
        qDebug() << "[MainWindow] ‚è∏Ô∏è Pausiere Scanner f√ºr sichere Deletion";
        m_scanner->pauseScan();
    }
    
    // Show deletion dialog
    DuplicateDeleteDialog *dialog = new DuplicateDeleteDialog(this);
    dialog->setPresetManager(m_presetManager);
    dialog->setDeletionMode("Alle Duplikate");
    dialog->setFileList(duplicateFiles, originalFiles);
    
    connect(dialog, &DuplicateDeleteDialog::deletionCompleted,
            this, &MainWindow::onDeletionCompleted);
    
    dialog->exec();
    dialog->deleteLater();
    
    // üîÑ RESUME Scanner after dialog closed
    if (m_scanner && !m_scanner->isScanning()) {
        qDebug() << "[MainWindow] ‚ñ∂Ô∏è Setze Scanner fort nach Deletion";
        m_scanner->resumeScan();
    }
}

void MainWindow::deleteSelectedDuplicates()
{
    QList<QTableWidgetItem*> selectedItems = resultsTable->selectedItems();
    if (selectedItems.isEmpty()) {
        QMessageBox::information(this, "Keine Auswahl", 
            "Bitte w√§hlen Sie die zu l√∂schenden Dateien aus.");
        return;
    }
    
    // Get selected file paths
    QStringList selectedFiles;
    QStringList originalFiles;
    QSet<int> selectedRows;
    
    for (QTableWidgetItem *item : selectedItems) {
        selectedRows.insert(item->row());
    }
    
    for (int row : selectedRows) {
        QTableWidgetItem *pathItem = resultsTable->item(row, 2); // Path column
        QTableWidgetItem *statusItem = resultsTable->item(row, 0); // Status column
        if (pathItem && statusItem) {
            QString filePath = pathItem->data(Qt::UserRole).toString();
            if (filePath.isEmpty()) {
                // Fallback to visible text if no stored path
                filePath = pathItem->text();
            }
            selectedFiles.append(filePath);
            bool isOriginal = statusItem->data(Qt::UserRole + 1).toBool();
            if (isOriginal) {
                originalFiles.append(filePath);
            }
        }
    }
    
    if (selectedFiles.isEmpty()) {
        QMessageBox::information(this, "Keine g√ºltigen Dateien", 
            "Die ausgew√§hlten Zeilen enthalten keine g√ºltigen Dateipfade.");
        return;
    }
    
    // üõë PAUSE Scanner to prevent race condition during deletion
    if (m_scanner && m_scanner->isScanning()) {
        qDebug() << "[MainWindow] ‚è∏Ô∏è Pausiere Scanner f√ºr sichere Deletion (selected)";
        m_scanner->pauseScan();
    }
    
    // Show deletion dialog
    DuplicateDeleteDialog *dialog = new DuplicateDeleteDialog(this);
    dialog->setPresetManager(m_presetManager);
    dialog->setDeletionMode("Markierte Dateien");
    dialog->setFileList(selectedFiles, originalFiles);
    
    connect(dialog, &DuplicateDeleteDialog::deletionCompleted,
            this, &MainWindow::onDeletionCompleted);
    
    dialog->exec();
    dialog->deleteLater();
    
    // üîÑ RESUME Scanner after dialog closed
    if (m_scanner && !m_scanner->isScanning()) {
        qDebug() << "[MainWindow] ‚ñ∂Ô∏è Setze Scanner fort nach Deletion (selected)";
        m_scanner->resumeScan();
    }
}

void MainWindow::onDeletionCompleted(const DeletionResult &result)
{
    // Update status bar with deletion results
    QString statusMessage = QString("‚úÖ %1 Duplikate gel√∂scht, %2 freigeworden - %3 Originale gesch√ºtzt")
                           .arg(result.duplicateFilesDeleted)
                           .arg(formatFileSize(result.totalBytesFreed))
                           .arg(result.originalFilesProtected);
    
    statusBar()->showMessage(statusMessage, 10000); // Show for 10 seconds
    
    // Refresh the results table by removing deleted files
    for (const QString &deletedFile : result.deletedFiles) {
        // üîê Entferne gel√∂schte Datei aus Hash-Cache
        if (m_scanner) {
            m_scanner->removeFromHashCache(deletedFile);
        }
        
        for (int row = resultsTable->rowCount() - 1; row >= 0; --row) {
            QTableWidgetItem *pathItem = resultsTable->item(row, 2);
            if (!pathItem) continue;
            const QString storedFullPath = pathItem->data(Qt::UserRole).toString();
            const QString visiblePath = pathItem->text();
            if (deletedFile == storedFullPath || deletedFile == visiblePath) {
                resultsTable->removeRow(row);
                qDebug() << "[MainWindow] üóëÔ∏è Entfernte Zeile f√ºr gel√∂schte Datei:" << deletedFile;
            }
        }
    }
    
    // Update duplicate groups to remove deleted files
    for (auto &group : m_currentDuplicateGroups.groups) {
        for (const QString &deletedFile : result.deletedFiles) {
            auto it = std::remove_if(group.duplicates.begin(), group.duplicates.end(),
                [&deletedFile](const FileInfo &file) {
                    return file.filePath == deletedFile;
                });
            group.duplicates.erase(it, group.duplicates.end());
        }
    }
    
    qDebug() << "[MainWindow] ‚úÖ Duplikat-L√∂schung abgeschlossen:"
             << result.duplicateFilesDeleted << "gel√∂scht,"
             << result.originalFilesProtected << "gesch√ºtzt";
    
    // üóëÔ∏è JETZT Hash-Indizes l√∂schen - Duplikate wurden gel√∂scht, Hashes nicht mehr ben√∂tigt
    if (m_scanner && result.duplicateFilesDeleted > 0) {
        qDebug() << "[MainWindow] üóëÔ∏è L√∂sche Hash-Indizes nach Duplikat-L√∂schung...";
        m_scanner->clearAllHashes();
        
        // üíæ Hash-Cache nach L√∂schung aktualisieren
        qDebug() << "[MainWindow] üíæ Speichere aktuellen Hash-Cache nach L√∂schung...";
        m_scanner->saveHashCache();
        
        qDebug() << "[MainWindow] ‚úÖ Hash-Indizes freigegeben + Cache aktualisiert - Memory bereinigt";
    }
}

// ‚úÖ ECHTE IMPLEMENTIERUNGEN F√úR FEHLENDE FUNKTIONEN

void MainWindow::deleteDuplicateFiles(const QStringList &filePaths)
{
    qDebug() << "[MainWindow] üóëÔ∏è deleteDuplicateFiles gestartet mit" << filePaths.size() << "Dateien";
    
    if (filePaths.isEmpty()) {
        statusBar()->showMessage("Keine Dateien zum L√∂schen ausgew√§hlt", 3000);
        return;
    }
    
    // Best√§tigungsdialog
    int result = QMessageBox::question(this, 
        tr("Dateien l√∂schen"), 
        tr("M√∂chten Sie wirklich %1 Dateien l√∂schen?").arg(filePaths.size()),
        QMessageBox::Yes | QMessageBox::No,
        QMessageBox::No);
    
    if (result != QMessageBox::Yes) {
        statusBar()->showMessage("L√∂schvorgang abgebrochen", 3000);
        return;
    }
    
    // üöÄ PARALLEL DELETE: Trennung von lokalen und FTP-Dateien
    QStringList localFiles;
    QStringList ftpFiles;
    
    for (const QString &filePath : filePaths) {
        if (filePath.startsWith("ftp://")) {
            ftpFiles.append(filePath);
        } else {
            localFiles.append(filePath);
        }
    }
    
    // Lokale Dateien sofort l√∂schen (schnell)
    int deletedCount = 0;
    for (const QString &filePath : localFiles) {
        QFile file(filePath);
        if (file.remove()) {
            deletedCount++;
            qDebug() << "[MainWindow] ‚úÖ Lokale Datei gel√∂scht:" << filePath;
        } else {
            qDebug() << "[MainWindow] ‚ùå Fehler beim L√∂schen:" << filePath;
        }
    }
    
    // FTP-Dateien parallel l√∂schen (50 gleichzeitig)
    if (!ftpFiles.isEmpty()) {
        deleteFtpFilesParallel(ftpFiles);
        statusBar()->showMessage(tr("üöÄ L√∂sche %1 lokale + %2 FTP-Dateien parallel...").arg(deletedCount).arg(ftpFiles.size()), 5000);
    } else {
        statusBar()->showMessage(tr("‚úÖ %1 lokale Dateien gel√∂scht").arg(deletedCount), 5000);
    }
}

bool MainWindow::deleteFtpFileSync(const QString &ftpPath)
{
    qDebug() << "[MainWindow] üì° deleteFtpFileSync:" << ftpPath;
    
    QUrl url(ftpPath);
    QString host = url.host();
    QString remotePath = url.path();
    
    // Hole Login-Daten
    if (m_presetManager) {
        LoginData login = m_presetManager->getLogin(host, 21);
        if (login.isValid()) {
            FtpClient *ftpClient = new FtpClient(this);
            ftpClient->setCredentials(host, 21, login.username, login.password);
            
            bool success = false;
            connect(ftpClient, &FtpClient::removeFinished, this, 
                [this, ftpPath, ftpClient, &success](const QString &file, bool result) {
                    success = result;
                    if (result) {
                        qDebug() << "[MainWindow] ‚úÖ FTP-Datei gel√∂scht:" << ftpPath;
                        statusBar()->showMessage(tr("FTP-Datei gel√∂scht: %1").arg(file), 3000);
                    } else {
                        qDebug() << "[MainWindow] ‚ùå FTP-L√∂schen fehlgeschlagen:" << ftpPath;
                        statusBar()->showMessage(tr("FTP-L√∂schen fehlgeschlagen: %1").arg(file), 5000);
                    }
                    ftpClient->deleteLater();
                });
            
            ftpClient->remove(remotePath);
            return success;
        } else {
            qDebug() << "[MainWindow] ‚ùå Keine FTP-Login-Daten f√ºr" << host;
            statusBar()->showMessage(tr("Keine FTP-Login-Daten f√ºr %1").arg(host), 5000);
            return false;
        }
    }
    return false;
}

void MainWindow::deleteFtpFilesParallel(const QStringList &ftpPaths)
{
    qDebug() << "[MainWindow] üöÄ deleteFtpFilesParallel:" << ftpPaths.size() << "Dateien";
    
    if (ftpPaths.isEmpty()) {
        statusBar()->showMessage("Keine FTP-Dateien zum L√∂schen", 3000);
        return;
    }
    
    // ThreadPool auf 50 setzen (wie beim Scannen)
    QThreadPool *pool = QThreadPool::globalInstance();
    if (pool->maxThreadCount() < 50) {
        pool->setMaxThreadCount(50);
        qDebug() << "[MainWindow] üöÄ ThreadPool erh√∂ht auf 50 parallele L√∂schvorg√§nge";
    }
    
    int totalFiles = ftpPaths.size();
    // Use shared_ptr for thread-safe counter access
    auto completedFiles = std::make_shared<std::atomic<int>>(0);
    auto successCount = std::make_shared<std::atomic<int>>(0);
    
    for (const QString &ftpPath : ftpPaths) {
        QUrl url(ftpPath);
        QString host = url.host();
        QString remotePath = url.path();
        
        qDebug() << "[MainWindow] üì° L√∂sche FTP-Datei:" << remotePath << "auf" << host;
        
        if (m_presetManager) {
            LoginData login = m_presetManager->getLogin(host, 21);
            if (login.isValid()) {
                // Callback f√ºr Completion
                auto callback = [this, totalFiles, completedFiles, successCount, ftpPath](const QString &/*file*/, bool success) {
                    int completed = ++(*completedFiles);
                    if (success) {
                        ++(*successCount);
                        qDebug() << "[MainWindow] ‚úÖ FTP-Datei gel√∂scht:" << ftpPath;
                    } else {
                        qDebug() << "[MainWindow] ‚ùå FTP-L√∂schen fehlgeschlagen:" << ftpPath;
                    }
                    
                    // Progress-Update im GUI-Thread
                    QMetaObject::invokeMethod(this, [this, completed, totalFiles, successCount]() {
                        statusBar()->showMessage(tr("üóëÔ∏è L√∂schen: %1/%2 (%3 erfolgreich)").arg(completed).arg(totalFiles).arg(successCount->load()), 2000);
                        
                        // Fertig?
                        if (completed >= totalFiles) {
                            statusBar()->showMessage(tr("‚úÖ %1 von %2 FTP-Dateien gel√∂scht").arg(successCount->load()).arg(totalFiles), 5000);
                        }
                    }, Qt::QueuedConnection);
                };
                
                FtpDeleteWorker *worker = new FtpDeleteWorker(host, 21, login.username, login.password, remotePath, callback);
                pool->start(worker);
            } else {
                qWarning() << "[MainWindow] ‚ùå Keine Login-Daten f√ºr" << host;
            }
        }
    }
}

void MainWindow::selectAllDuplicatesInTable()
{
    qDebug() << "[MainWindow] üìã selectAllDuplicatesInTable gestartet";
    
    if (!resultsTable) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è resultsTable ist null";
        return;
    }
    
    int selectedCount = 0;
    for (int row = 0; row < resultsTable->rowCount(); ++row) {
        QTableWidgetItem *statusItem = resultsTable->item(row, 0);
        if (statusItem && statusItem->toolTip().contains("Duplicate")) {
            resultsTable->selectRow(row);
            selectedCount++;
        }
    }
    
    statusBar()->showMessage(tr("üìã %1 Duplikate ausgew√§hlt").arg(selectedCount), 3000);
    qDebug() << "[MainWindow] ‚úÖ selectAllDuplicatesInTable:" << selectedCount << "Duplikate ausgew√§hlt";
}

void MainWindow::updateDuplicateResults(int totalFiles, int duplicateGroups)
{
    qDebug() << "[MainWindow] üìä updateDuplicateResults:" << totalFiles << "Dateien," << duplicateGroups << "Gruppen";
    
    QString resultText = tr("üìä Scan-Ergebnisse: %1 Dateien analysiert, %2 Duplikatgruppen gefunden")
                        .arg(totalFiles).arg(duplicateGroups);
    
    if (statusBar()) {
        statusBar()->showMessage(resultText, 10000);
    }
    
    // Update GUI-Labels wenn vorhanden
    QLabel *resultLabel = findChild<QLabel*>("resultSummaryLabel");
    if (resultLabel) {
        resultLabel->setText(resultText);
    }
}

void MainWindow::startFtpNpuTest()
{
    qDebug() << "[MainWindow] üß™ startFtpNpuTest gestartet - FTP + NPU Integration Test";
    
    if (!m_npuManager) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è NPU Manager nicht verf√ºgbar";
        statusBar()->showMessage("NPU Manager nicht verf√ºgbar f√ºr Test", 5000);
        return;
    }
    
    statusBar()->showMessage("üß™ Starte FTP-NPU-Integrations-Test...", 3000);
    
    // Filtere FTP-Pfade aus den ausgew√§hlten Verzeichnissen
    QStringList ftpPaths;
    for (const QString &dir : m_selectedDirectories) {
        if (dir.startsWith("ftp://")) {
            ftpPaths.append(dir);
        }
    }
    
    if (ftpPaths.isEmpty()) {
        statusBar()->showMessage("Keine FTP-Pfade f√ºr NPU-Test verf√ºgbar", 5000);
        return;
    }
    
    qDebug() << "[MainWindow] üß™ FTP-NPU-Test mit" << ftpPaths.size() << "FTP-Pfaden:" << ftpPaths;
    
    // Starte NPU-basierten Duplikat-Scan mit FTP-Integration
    if (m_scanner) {
        m_scanner->startScan(ftpPaths, "SHA256", "*.jpg,*.png,*.bmp,*.gif");
        statusBar()->showMessage("üß™ FTP-NPU-Test l√§uft...", 5000);
    }
}

void MainWindow::showCriticalErrorDialog(const QString &title, const QString &message)
{
    qDebug() << "[MainWindow] ‚ùå showCriticalErrorDialog:" << title << "-" << message;
    
    QMessageBox::critical(this, title, message);
    
    // Log kritischen Fehler
    qCritical() << "[MainWindow] CRITICAL ERROR:" << title << message;
}

void MainWindow::showFtpCredentialDialog(const QString &host, int port, const QString &service)
{
    qDebug() << "[MainWindow] üîê showFtpCredentialDialog f√ºr" << host << ":" << port << service;
    
    LoginDialog dialog(this);
    dialog.setServiceInfo(host, port, service);
    dialog.setWindowTitle(tr("FTP-Anmeldung erforderlich"));
    
    if (dialog.exec() == QDialog::Accepted) {
        LoginData loginData = dialog.getLoginData();
        
        if (loginData.saveCredentials && m_presetManager) {
            m_presetManager->saveLogin(host, port, loginData);
            qDebug() << "[MainWindow] üíæ FTP-Credentials gespeichert f√ºr" << host;
        }
        
        statusBar()->showMessage(tr("FTP-Anmeldung f√ºr %1 erfolgreich").arg(host), 3000);
    } else {
        statusBar()->showMessage(tr("FTP-Anmeldung f√ºr %1 abgebrochen").arg(host), 3000);
    }
}

void MainWindow::updateDownloadProgress(int current, int total, bool isComplete)
{
    if (!progressBar) return;
    
    if (isComplete) {
        progressBar->setValue(progressBar->maximum());
        statusBar()->showMessage(tr("‚úÖ Download abgeschlossen: %1 Dateien").arg(total), 5000);
        qDebug() << "[MainWindow] ‚úÖ Download abgeschlossen:" << total << "Dateien";
    } else {
        int percentage = (total > 0) ? (current * 100 / total) : 0;
        progressBar->setValue(percentage);
        statusBar()->showMessage(tr("üì• Download: %1/%2 (%3%)").arg(current).arg(total).arg(percentage));
        
        // Update File Count Label wenn vorhanden
        if (fileCountLabel) {
            fileCountLabel->setText(tr("üì• %1/%2 Dateien").arg(current).arg(total));
        }
    }
}

void MainWindow::requestFtpSubdirectoriesForDialog(const QString &host, const QString &path, SimpleTreeDialog *dialog)
{
    qDebug() << "[MainWindow] üöÄ requestFtpSubdirectoriesForDialog:" << host << path;
    
    if (!dialog || !m_presetManager) {
        qDebug() << "[MainWindow] ‚ö†Ô∏è Dialog oder PresetManager null";
        return;
    }
    
    LoginData loginData = m_presetManager->getLogin(host, 21);
    if (!loginData.isValid()) {
        qDebug() << "[MainWindow] ‚ùå Keine Login-Daten f√ºr" << host;
        return;
    }
    
    FtpClient *ftpClient = new FtpClient(this);
    ftpClient->setCredentials(host, 21, loginData.username, loginData.password);
    
    connect(ftpClient, &FtpClient::listFinished, this, 
        [this, host, path, dialog, ftpClient](const QStringList &subdirs, bool success) {
            if (success && dialog) {
                qDebug() << "[MainWindow] ‚úÖ FTP-Unterverzeichnisse empfangen:" << subdirs.size();
                dialog->addSubdirectories(path, subdirs);
            } else {
                qDebug() << "[MainWindow] ‚ùå FTP-LIST fehlgeschlagen f√ºr" << path;
            }
            ftpClient->deleteLater();
        });
    
    connect(ftpClient, &FtpClient::connected, ftpClient, [ftpClient, path]() {
        qDebug() << "[FtpClient] üöÄ Verbunden - starte LIST f√ºr:" << path;
        ftpClient->list(path);
    });
    
    ftpClient->connectToHost();
}

// üìä HashEngine Status-Updates in GUI anzeigen
void MainWindow::onHashEngineStatusUpdate(const QString &operation, const QString &details)
{
    // Aktualisiere StatusBar mit HashEngine-Aktivit√§t
    QString statusMessage = QString("üîß %1: %2").arg(operation, details);
    
    // F√ºr Hardware-Tests l√§nger anzeigen, f√ºr andere kurz
    int displayTime = 10000;  // 10 Sekunden Standard
    if (operation.contains("Hardware") || operation.contains("GPU") || operation.contains("NPU") || 
        operation.contains("Test") || operation.contains("Erkenn") || operation.contains("Load")) {
        displayTime = 15000;  // 15 Sekunden f√ºr Hardware-Tests
    }
    
    // StatusBar aktualisieren
    statusBar()->showMessage(statusMessage, displayTime);
    
    // ZUS√ÑTZLICH: Auch das Hauptfenster-Title aktualisieren f√ºr bessere Sichtbarkeit
    QString windowTitle = QString("FileDuper - %1").arg(statusMessage);
    setWindowTitle(windowTitle);
    
    // Optional: Ausgabe f√ºr Debug
    qDebug() << "[GUI] HashEngine Status:" << operation << "-" << details;
    
    // GUI mehrfach aktualisieren f√ºr bessere Sichtbarkeit
    // REMOVED: QApplication::processEvents();
    update();
    repaint();
    
    // Kurze Pause f√ºr GUI-Update
    QThread::msleep(100);
}

// üß† INTELLIGENTE SERVICE-KATEGORISIERUNG
QString MainWindow::categorizeIntelligentService(const QString &service, int port)
{
    if (service.contains("FTP") || port == 21) return "üóÇÔ∏è File Transfer (FTP/SFTP)";
    if (service.contains("SSH") || service.contains("SFTP") || port == 22) return "üóÇÔ∏è File Transfer (FTP/SFTP)";
    if (service.contains("SMB") || service.contains("CIFS") || port == 445 || port == 139) return "üóÇÔ∏è File Transfer (FTP/SFTP)";
    if (service.contains("NFS") || port == 2049) return "üóÇÔ∏è File Transfer (FTP/SFTP)";
    if (service.contains("HTTP") || port == 80 || port == 443) return "üåê Web Services";
    if (service.contains("Telnet") || port == 23) return "üîß Management Services";
    if (service.contains("SNMP") || port == 161) return "üîß Management Services";
    if (service.contains("Database") || port == 3306 || port == 5432) return "üóÑÔ∏è Database Services";
    return "üîç Other Services";
}

QString MainWindow::calculateServicePriority(const QString &service, int port, const QString &/*ip*/)
{
    int score = getPriorityScore(service, port);
    if (score >= 9) return "üî• Sehr Hoch";
    if (score >= 7) return "‚ö° Hoch";
    if (score >= 5) return "üìä Mittel";
    if (score >= 3) return "üìù Niedrig";
    return "‚è∏Ô∏è Info";
}

int MainWindow::getPriorityScore(const QString &service, int port)
{
    // FTP/SFTP = H√∂chste Priorit√§t f√ºr File Duper
    if (service.contains("FTP") || port == 21) return 10;
    if (service.contains("SFTP") || port == 22) return 9;
    if (service.contains("SMB") || service.contains("CIFS")) return 8;
    if (service.contains("NFS")) return 7;
    if (service.contains("HTTP") && port == 80) return 4;
    if (service.contains("HTTPS") && port == 443) return 5;
    return 2;
}

QString MainWindow::getServiceIcon(const QString &service, int port)
{
    if (service.contains("FTP") || port == 21) return "üìÅ";
    if (service.contains("SSH") || service.contains("SFTP") || port == 22) return "üîê";
    if (service.contains("SMB") || service.contains("CIFS")) return "üóÇÔ∏è";
    if (service.contains("NFS")) return "üìÇ";
    if (service.contains("HTTP") || port == 80) return "üåê";
    if (service.contains("HTTPS") || port == 443) return "üîí";
    return "üîß";
}

QString MainWindow::getAuthenticationStatus(const QString &ip, int port)
{
    if (m_presetManager) {
        auto login = m_presetManager->getLogin(ip, port);
        if (!login.username.isEmpty()) {
            return QString("‚úÖ %1").arg(login.username);
        }
    }
    return "‚ùå Kein Login";
}

QTreeWidgetItem* MainWindow::findOrCreateCategory(const QString &category)
{
    // Suche existierende Kategorie
    for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {
        QTreeWidgetItem *item = networkTree->topLevelItem(i);
        if (item->text(0) == category) {
            return item;
        }
    }
    
    // Erstelle neue Kategorie
    QTreeWidgetItem *categoryItem = new QTreeWidgetItem(networkTree);
    categoryItem->setText(0, category);
    categoryItem->setText(1, "Kategorie");
    categoryItem->setText(4, "üè∑Ô∏è Gruppe");
    categoryItem->setExpanded(false);
    
    // Styling f√ºr Kategorie
    QFont categoryFont = categoryItem->font(0);
    categoryFont.setBold(true);
    categoryFont.setPointSize(14);
    categoryItem->setFont(0, categoryFont);
    categoryItem->setBackground(0, QColor(75, 85, 105, 100));
    
    return categoryItem;
}

QTreeWidgetItem* MainWindow::findOrCreateServer(QTreeWidgetItem *categoryItem, const QString &ip)
{
    // Suche existierenden Server in der Kategorie
    for (int i = 0; i < categoryItem->childCount(); ++i) {
        QTreeWidgetItem *child = categoryItem->child(i);
        if (child->data(0, Qt::UserRole).toString() == ip) {
            return child;
        }
    }
    
    // Erstelle neuen Server
    QTreeWidgetItem *serverItem = new QTreeWidgetItem(categoryItem);
    serverItem->setText(0, QString("üñ•Ô∏è %1").arg(ip));
    serverItem->setText(1, "Server");
    serverItem->setText(4, "üè† Host");
    serverItem->setData(0, Qt::UserRole, ip);
    serverItem->setExpanded(false);
    
    // Server-Styling
    QFont serverFont = serverItem->font(0);
    serverFont.setBold(true);
    serverItem->setFont(0, serverFont);
    serverItem->setBackground(0, QColor(59, 130, 246, 50));
    
    return serverItem;
}

void MainWindow::applyIntelligentServiceStyling(QTreeWidgetItem *serviceItem, const QString &service, int port)
{
    // Priorit√§ts-basierte Styling
    int priority = getPriorityScore(service, port);
    
    if (priority >= 9) {
        serviceItem->setBackground(0, QColor(239, 68, 68, 80));  // Rot f√ºr h√∂chste Priorit√§t
        serviceItem->setForeground(0, QColor(255, 255, 255));
    } else if (priority >= 7) {
        serviceItem->setBackground(0, QColor(245, 158, 11, 80)); // Orange f√ºr hohe Priorit√§t
        serviceItem->setForeground(0, QColor(255, 255, 255));
    } else if (priority >= 5) {
        serviceItem->setBackground(0, QColor(59, 130, 246, 80)); // Blau f√ºr mittlere Priorit√§t
    } else {
        serviceItem->setBackground(0, QColor(107, 114, 128, 50)); // Grau f√ºr niedrige Priorit√§t
    }
}

void MainWindow::updateNetworkStatistics()
{
    int totalServices = 0;
    int fileTransferServices = 0;
    int authenticatedServices = 0;
    
    for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {
        QTreeWidgetItem *category = networkTree->topLevelItem(i);
        for (int j = 0; j < category->childCount(); ++j) {
            QTreeWidgetItem *server = category->child(j);
            for (int k = 0; k < server->childCount(); ++k) {
                QTreeWidgetItem *service = server->child(k);
                totalServices++;
                
                QString serviceName = service->text(1);
                if (serviceName.contains("FTP") || serviceName.contains("SFTP") || 
                    serviceName.contains("SMB") || serviceName.contains("NFS")) {
                    fileTransferServices++;
                }
                
                if (service->text(2).contains("‚úÖ")) {
                    authenticatedServices++;
                }
            }
        }
    }
    
    // Update Status in der ersten Kategorie
    if (networkTree->topLevelItemCount() > 0) {
        QTreeWidgetItem *firstCategory = networkTree->topLevelItem(0);
        firstCategory->setText(3, QString("üìä %1 Services").arg(totalServices));
    }
}

// üöÄ ECHTZEIT HARDWARE-MONITORING IMPLEMENTATION
void MainWindow::updateHardwareMonitoring()
{
    // CPU Load auslesen
    int cpuLoad = getCurrentCpuLoad();
    updateCpuDisplay(cpuLoad);
    
    // GPU Load auslesen (wenn aktiv)
    int gpuLoad = getCurrentGpuLoad();
    updateGpuDisplay(gpuLoad);
    
    // NPU Load auslesen (wenn aktiv)
    int npuLoad = getCurrentNpuLoad();
    updateNpuDisplay(npuLoad);
}

int MainWindow::getCurrentCpuLoad()
{
    // Linux: /proc/stat auslesen
    static qint64 lastTotalTime = 0;
    static qint64 lastIdleTime = 0;
    
    QFile file("/proc/stat");
    if (!file.open(QIODevice::ReadOnly)) {
        return 0;
    }
    
    QString line = file.readLine();
    file.close();
    
    // Parse "cpu" line: cpu user nice system idle iowait irq softirq
    QStringList parts = line.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
    if (parts.size() < 5) return 0;
    
    qint64 user = parts[1].toLongLong();
    qint64 nice = parts[2].toLongLong();
    qint64 system = parts[3].toLongLong();
    qint64 idle = parts[4].toLongLong();
    
    qint64 totalTime = user + nice + system + idle;
    qint64 idleTime = idle;
    
    if (lastTotalTime == 0) {
        lastTotalTime = totalTime;
        lastIdleTime = idleTime;
        return 0;
    }
    
    qint64 totalDelta = totalTime - lastTotalTime;
    qint64 idleDelta = idleTime - lastIdleTime;
    
    lastTotalTime = totalTime;
    lastIdleTime = idleTime;
    
    if (totalDelta == 0) return 0;
    
    int cpuUsage = 100 - (idleDelta * 100 / totalDelta);
    return qBound(0, cpuUsage, 100);
}

int MainWindow::getCurrentGpuLoad()
{
    // üéÆ ECHTZEIT GPU-AUSLASTUNG: Intel Arrow Lake-S Graphics
    static int minFreq = -1;
    static int maxFreq = -1;
    static QString cardPath;
    
    // Auto-Detect GPU card beim ersten Aufruf (card0 oder card1)
    if (maxFreq == -1) {
        // Probiere card1 (Arrow Lake-S), dann card0 (√§ltere Intel GPUs)
        QStringList cardPaths = {"/sys/class/drm/card1", "/sys/class/drm/card0"};
        
        for (const QString &testPath : cardPaths) {
            QFile maxFile(testPath + "/gt_max_freq_mhz");
            QFile minFile(testPath + "/gt_min_freq_mhz");
            
            if (maxFile.exists() && minFile.exists()) {
                cardPath = testPath;
                
                if (maxFile.open(QIODevice::ReadOnly)) {
                    maxFreq = maxFile.readAll().trimmed().toInt();
                    maxFile.close();
                }
                
                if (minFile.open(QIODevice::ReadOnly)) {
                    minFreq = minFile.readAll().trimmed().toInt();
                    minFile.close();
                }
                
                qDebug() << "[GPU] ‚úÖ Intel GPU gefunden:" << cardPath;
                qDebug() << "[GPU] üéÆ Min:" << minFreq << "MHz, Max:" << maxFreq << "MHz";
                break;
            }
        }
        
        if (cardPath.isEmpty()) {
            qDebug() << "[GPU] ‚ùå Keine Intel GPU gefunden (card0/card1)";
            return 0;
        }
    }
    
    // Lese aktuelle Frequenz
    QFile curFile(cardPath + "/gt_cur_freq_mhz");
    if (curFile.open(QIODevice::ReadOnly)) {
        int curFreq = curFile.readAll().trimmed().toInt();
        curFile.close();
        
        if (maxFreq > 0 && minFreq >= 0 && curFreq > 0) {
            // Berechne Prozent basierend auf Frequenz-Range
            int load = ((curFreq - minFreq) * 100) / (maxFreq - minFreq);
            load = qBound(0, load, 100);
            
            // Debug nur bei √Ñnderung > 5%
            static int lastLoad = -1;
            if (abs(load - lastLoad) > 5) {
                qDebug() << "[GPU] üéÆ ECHTZEIT:" << curFreq << "MHz ‚Üí" << load << "%";
                lastLoad = load;
            }
            
            return load;
        }
    }
    
    return 0; // GPU nicht verf√ºgbar oder idle
}

int MainWindow::getCurrentNpuLoad()
{
    // üß† ECHTZEIT NPU-AUSLASTUNG: Intel VPU Detection
    
    // Intel NPU/VPU: /sys/class/misc/intel_vpu0/device/power_state
    static bool npuChecked = false;
    static bool npuAvailable = false;
    static QString npuPath;
    
    // Einmalige NPU-Detection beim Start
    if (!npuChecked) {
        QDir vpu("/sys/class/misc");
        QStringList vpuDevices = vpu.entryList(QStringList() << "intel_vpu*", QDir::Dirs);
        
        if (!vpuDevices.isEmpty()) {
            npuPath = QString("/sys/class/misc/%1/device/power_state").arg(vpuDevices.first());
            npuAvailable = QFile::exists(npuPath);
            qDebug() << "[NPU] üß† Intel VPU gefunden:" << vpuDevices.first() << "‚Üí" << npuPath;
        }
        
        npuChecked = true;
    }
    
    // Pr√ºfe NPU Power State
    if (npuAvailable) {
        QFile powerFile(npuPath);
        if (powerFile.open(QIODevice::ReadOnly)) {
            QString state = powerFile.readAll().trimmed();
            powerFile.close();
            
            // Debug bei State-√Ñnderung
            static QString lastState;
            if (state != lastState) {
                qDebug() << "[NPU] üß† Power State:" << state;
                lastState = state;
            }
            
            // D0/D1/D2 = Aktiv, D3 = Suspend
            if (state.startsWith("D0") || state.startsWith("D1") || state.startsWith("D2")) {
                return 80; // NPU aktiv
            } else if (state == "D3" || state == "off") {
                return 0; // NPU suspended
            }
        }
    }
    
    // Fallback: CPU-basierte Detection (wenn CPU niedrig aber Scanner l√§uft)
    if (m_scanner && m_scanner->isScanning()) {
        int cpuLoad = getCurrentCpuLoad();
        if (cpuLoad < 40) {
            // Scanner l√§uft aber CPU niedrig ‚Üí NPU k√∂nnte arbeiten
            return 50;
        }
    }
    
    return 0; // Inaktiv oder nicht verf√ºgbar
}

void MainWindow::updateCpuDisplay(int load)
{
    if (!cpuLoadLabel) return;
    
    QString text = QString("CPU: %1%").arg(load);
    cpuLoadLabel->setText(text);
    
    // Farb-Coding basierend auf Last
    QString color;
    if (load >= 90) {
        color = "#DC2626"; // Rot - KRITISCH (blinkend)
        cpuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; animation: blink 0.5s infinite; }").arg(color));
    } else if (load >= 70) {
        color = "#F59E0B"; // Orange - HOCH
        cpuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; }").arg(color));
    } else if (load >= 30) {
        color = "#FBBF24"; // Gelb - MODERAT
        cpuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; }").arg(color));
    } else {
        color = "#10B981"; // Gr√ºn - IDLE
        cpuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; }").arg(color));
    }
}

void MainWindow::updateGpuDisplay(int load)
{
    if (!gpuLoadLabel) return;
    
    if (load == 0) {
        gpuLoadLabel->setText("GPU: Inaktiv");
        gpuLoadLabel->setStyleSheet("QLabel { color: #6B7280; font-family: monospace; font-weight: bold; }");
    } else {
        QString text = QString("GPU: %1%").arg(load);
        gpuLoadLabel->setText(text);
        
        QString color;
        if (load >= 90) {
            color = "#DC2626"; // Rot
        } else if (load >= 70) {
            color = "#F59E0B"; // Orange
        } else {
            color = "#3B82F6"; // Blau (GPU aktiv)
        }
        gpuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; }").arg(color));
    }
}

void MainWindow::updateNpuDisplay(int load)
{
    if (!npuLoadLabel) return;
    
    if (load == 0) {
        npuLoadLabel->setText("NPU: Inaktiv");
        npuLoadLabel->setStyleSheet("QLabel { color: #6B7280; font-family: monospace; font-weight: bold; }");
    } else {
        QString text = QString("NPU: %1%").arg(load);
        npuLoadLabel->setText(text);
        
        QString color = "#8B5CF6"; // Lila f√ºr NPU (AI-Acceleration)
        npuLoadLabel->setStyleSheet(QString("QLabel { color: %1; font-family: monospace; font-weight: bold; }").arg(color));
    }
}

// ‚úÖ HARDWARE STATUS SLOTS IMPLEMENTATION
void MainWindow::onHardwareStatusUpdate(bool hasSHANI, bool hasSHA512NI, bool hasAVX2, bool hasAVX512)
{
    m_hasShaNI = hasSHANI;
    m_hasSha512NI = hasSHA512NI;
    m_hasAVX2 = hasAVX2;
    m_hasAVX512 = hasAVX512;
    qDebug() << "[MainWindow] Hardware Update: SHA-NI=" << hasSHANI << "SHA512-NI=" << hasSHA512NI 
             << "AVX2=" << hasAVX2 << "AVX512=" << hasAVX512;
}

void MainWindow::onCpuStatusUpdated(int cores, int score) 
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateCpuStatus(cores, score);
    }
}

void MainWindow::onGpuStatusUpdated(bool available, const QString &name, int score)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateGpuStatus(available, name, score);
    }
}

void MainWindow::onGpuMemoryUpdated(int usedMB, int totalMB)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateGpuMemory(usedMB, totalMB);
    }
}

void MainWindow::onGpuClockUpdated(int clockMHz)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateGpuClock(clockMHz);
    }
}

void MainWindow::onGpuTemperatureUpdated(int tempC)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateGpuTemperature(tempC);
    }
}

void MainWindow::onNpuStatusUpdated(bool available, int score)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateNpuStatus(available, score);
    }
}

void MainWindow::onNpuActivityUpdated(int activeUnits, int totalUnits, const QString &currentTask)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateNpuActivity(activeUnits, totalUnits, currentTask);
    }
}

void MainWindow::onNpuPowerUpdated(int powerW)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateNpuPower(powerW);
    }
}

void MainWindow::onIoStatusUpdated(int score)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateIoStatus(score);
    }
}

void MainWindow::onMemoryStatusUpdated(int availableMB)
{
    if (m_hardwareStatusWidget) {
        m_hardwareStatusWidget->updateMemoryStatus(availableMB);
    }
}

// ‚úÖ BENCHMARK MONITOR SLOTS
void MainWindow::onBenchmarkActivityLogged(const QString &activity, const QString &details)
{
    if (m_liveBenchmarkMonitor) {
        m_liveBenchmarkMonitor->onActivityLogged(activity, details);
    }
}

void MainWindow::onBenchmarkProgressUpdated(int filesProcessed, int filesHashed, int duplicatesFound)
{
    if (m_liveBenchmarkMonitor) {
        m_liveBenchmarkMonitor->onScanProgress(filesProcessed, filesHashed, duplicatesFound);
    }
}

void MainWindow::onBenchmarkSpeedUpdated(double /*filesPerSecond*/)
{
    // Speed calculation can be added here
}

void MainWindow::onBenchmarkTimeElapsedUpdated(int /*seconds*/)
{
    // Time tracking can be added here
}

// ‚úÖ SETTINGS DIALOG
void MainWindow::onSettingsApplied(const QVariantMap &settings)
{
    qDebug() << "[MainWindow] Settings applied:" << settings;
    // Apply settings to scanner and other components
}


// üé® THEME MANAGEMENT: Handle theme selection changes
void MainWindow::onThemeChanged(int index)
{
    QStringList themes = {
        "System Default",
        "Light High Contrast",
        "Dark Blue",
        "Dark Green",
        "Dark Purple",
        "Dark Red/Orange",
        "Ice Blue",
        "Forest Green",
        "High Contrast BW",
        "Sakura Pink"
    };
    
    if (index >= 0 && index < themes.size()) {
        QString themeName = themes[index];
        qDebug() << "[MainWindow] üé® Theme gewechselt zu:" << themeName;
        applyTheme(themeName);
        saveThemeToSettings(themeName);
    }
}

// üé® APPLY THEME: Set application-wide stylesheet
void MainWindow::applyTheme(const QString &themeName)
{
    QString styleSheet;
    
    if (themeName == "System Default") {
        qApp->setStyleSheet(""); // Reset to default
        return;
    }
    else if (themeName == "Light High Contrast") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #FFFFFF; color: #000000; }
            QGroupBox { border: 3px solid #000000; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #F5F5F5; }
            QGroupBox::title { color: #000000; font-size: 14pt; }
            QPushButton { background-color: #E0E0E0; color: #000000; border: 2px solid #000000; padding: 8px; font-weight: bold; }
            QPushButton:hover { background-color: #2196F3; color: #FFFFFF; }
            QLineEdit, QComboBox { background-color: #FFFFFF; color: #000000; border: 2px solid #000000; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #FFFFFF; color: #000000; border: 2px solid #000000; }
            QLabel { color: #000000; }
            QProgressBar { border: 2px solid #000000; background-color: #E0E0E0; }
            QProgressBar::chunk { background-color: #2196F3; }
        )";
    }
    else if (themeName == "Dark Blue") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #1E1E2E; color: #CDD6F4; }
            QGroupBox { border: 2px solid #89B4FA; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #181825; }
            QGroupBox::title { color: #89B4FA; font-size: 13pt; }
            QPushButton { background-color: #313244; color: #CDD6F4; border: 2px solid #89B4FA; padding: 8px; }
            QPushButton:hover { background-color: #89B4FA; color: #1E1E2E; }
            QLineEdit, QComboBox { background-color: #313244; color: #CDD6F4; border: 2px solid #89B4FA; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #181825; color: #CDD6F4; border: 2px solid #89B4FA; }
            QHeaderView::section { background-color: #313244; color: #89B4FA; border: 1px solid #89B4FA; }
            QLabel { color: #CDD6F4; }
            QProgressBar { border: 2px solid #89B4FA; background-color: #313244; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #89B4FA; }
        )";
    }
    else if (themeName == "Dark Green") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #1A1D1A; color: #A6E3A1; }
            QGroupBox { border: 2px solid #A6E3A1; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #11140F; }
            QGroupBox::title { color: #A6E3A1; font-size: 13pt; }
            QPushButton { background-color: #2D3A2E; color: #A6E3A1; border: 2px solid #A6E3A1; padding: 8px; }
            QPushButton:hover { background-color: #A6E3A1; color: #1A1D1A; }
            QLineEdit, QComboBox { background-color: #2D3A2E; color: #A6E3A1; border: 2px solid #A6E3A1; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #11140F; color: #A6E3A1; border: 2px solid #A6E3A1; }
            QHeaderView::section { background-color: #2D3A2E; color: #A6E3A1; border: 1px solid #A6E3A1; }
            QProgressBar { border: 2px solid #A6E3A1; background-color: #2D3A2E; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #A6E3A1; }
        )";
    }
    else if (themeName == "Dark Purple") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #1E1E2E; color: #CBA6F7; }
            QGroupBox { border: 2px solid #CBA6F7; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #181825; }
            QGroupBox::title { color: #CBA6F7; font-size: 13pt; }
            QPushButton { background-color: #313244; color: #CBA6F7; border: 2px solid #CBA6F7; padding: 8px; }
            QPushButton:hover { background-color: #CBA6F7; color: #1E1E2E; }
            QLineEdit, QComboBox { background-color: #313244; color: #CBA6F7; border: 2px solid #CBA6F7; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #181825; color: #CBA6F7; border: 2px solid #CBA6F7; }
            QHeaderView::section { background-color: #313244; color: #CBA6F7; border: 1px solid #CBA6F7; }
            QProgressBar { border: 2px solid #CBA6F7; background-color: #313244; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #CBA6F7; }
        )";
    }
    else if (themeName == "Dark Red/Orange") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #1E1616; color: #FAB387; }
            QGroupBox { border: 2px solid #F38BA8; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #181111; }
            QGroupBox::title { color: #F38BA8; font-size: 13pt; }
            QPushButton { background-color: #3A2626; color: #FAB387; border: 2px solid #F38BA8; padding: 8px; }
            QPushButton:hover { background-color: #F38BA8; color: #1E1616; }
            QLineEdit, QComboBox { background-color: #3A2626; color: #FAB387; border: 2px solid #F38BA8; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #181111; color: #FAB387; border: 2px solid #F38BA8; }
            QHeaderView::section { background-color: #3A2626; color: #F38BA8; border: 1px solid #F38BA8; }
            QProgressBar { border: 2px solid #F38BA8; background-color: #3A2626; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #F38BA8; }
        )";
    }
    else if (themeName == "Ice Blue") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #E8F4F8; color: #0D47A1; }
            QGroupBox { border: 2px solid: #0277BD; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #B3E5FC; }
            QGroupBox::title { color: #0277BD; font-size: 13pt; }
            QPushButton { background-color: #B3E5FC; color: #0D47A1; border: 2px solid #0277BD; padding: 8px; }
            QPushButton:hover { background-color: #0277BD; color: #FFFFFF; }
            QLineEdit, QComboBox { background-color: #FFFFFF; color: #0D47A1; border: 2px solid #0277BD; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #FFFFFF; color: #0D47A1; border: 2px solid #0277BD; }
            QHeaderView::section { background-color: #B3E5FC; color: #0D47A1; border: 1px solid #0277BD; }
            QProgressBar { border: 2px solid #0277BD; background-color: #E0F7FA; color: #000000; }
            QProgressBar::chunk { background-color: #0277BD; }
        )";
    }
    else if (themeName == "Forest Green") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #0D1F0D; color: #76FF03; }
            QGroupBox { border: 2px solid #76FF03; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #1B5E20; }
            QGroupBox::title { color: #76FF03; font-size: 13pt; }
            QPushButton { background-color: #1B5E20; color: #76FF03; border: 2px solid #76FF03; padding: 8px; }
            QPushButton:hover { background-color: #76FF03; color: #0D1F0D; }
            QLineEdit, QComboBox { background-color: #1B5E20; color: #76FF03; border: 2px solid #76FF03; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #0D1F0D; color: #76FF03; border: 2px solid #76FF03; }
            QHeaderView::section { background-color: #1B5E20; color: #76FF03; border: 1px solid #76FF03; }
            QProgressBar { border: 2px solid #76FF03; background-color: #1B5E20; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #76FF03; }
        )";
    }
    else if (themeName == "High Contrast BW") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #000000; color: #FFFFFF; }
            QGroupBox { border: 3px solid #FFFFFF; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #000000; }
            QGroupBox::title { color: #FFFFFF; font-size: 14pt; }
            QPushButton { background-color: #FFFFFF; color: #000000; border: 3px solid #FFFFFF; padding: 8px; font-weight: bold; }
            QPushButton:hover { background-color: #FFFF00; color: #000000; }
            QLineEdit, QComboBox { background-color: #000000; color: #FFFFFF; border: 3px solid #FFFFFF; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #000000; color: #FFFFFF; border: 3px solid #FFFFFF; }
            QHeaderView::section { background-color: #000000; color: #FFFFFF; border: 2px solid #FFFFFF; }
            QLabel { color: #FFFFFF; }
            QProgressBar { border: 3px solid #FFFFFF; background-color: #000000; color: #FFFFFF; }
            QProgressBar::chunk { background-color: #FFFFFF; }
        )";
    }
    else if (themeName == "Sakura Pink") {
        styleSheet = R"(
            QMainWindow, QWidget { background-color: #FFF0F5; color: #880E4F; }
            QGroupBox { border: 2px solid #E91E63; font-weight: bold; padding: 10px; margin-top: 10px; background-color: #FCE4EC; }
            QGroupBox::title { color: #C2185B; font-size: 13pt; }
            QPushButton { background-color: #F8BBD0; color: #880E4F; border: 2px solid #E91E63; padding: 8px; }
            QPushButton:hover { background-color: #E91E63; color: #FFFFFF; }
            QLineEdit, QComboBox { background-color: #FFFFFF; color: #880E4F; border: 2px solid #E91E63; padding: 5px; }
            QTreeWidget, QTableWidget { background-color: #FFFFFF; color: #880E4F; border: 2px solid #E91E63; }
            QHeaderView::section { background-color: #F8BBD0; color: #880E4F; border: 1px solid #E91E63; }
            QProgressBar { border: 2px solid #E91E63; background-color: #FCE4EC; color: #000000; }
            QProgressBar::chunk { background-color: #E91E63; }
        )";
    }
    
    qApp->setStyleSheet(styleSheet);
    qDebug() << "[MainWindow] üé® Theme angewendet:" << themeName;
}

// üíæ SAVE THEME: Persist theme selection to INI file
void MainWindow::saveThemeToSettings(const QString &themeName)
{
    QSettings settings("FileDuper", "Settings");
    settings.setValue("theme/selected", themeName);
    settings.sync();
    qDebug() << "[MainWindow] üíæ Theme gespeichert in INI:" << themeName;
}

// üìÇ LOAD THEME: Restore theme from INI file
QString MainWindow::loadThemeFromSettings()
{
    QSettings settings("FileDuper", "Settings");
    QString savedTheme = settings.value("theme/selected", "System Default").toString();
    qDebug() << "[MainWindow] üìÇ Theme geladen aus INI:" << savedTheme;
    return savedTheme;
}
